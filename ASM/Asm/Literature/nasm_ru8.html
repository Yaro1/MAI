<html><head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r"><title>Руководство по NASM</title></head>

<META NAME="GENERATOR" CONTENT="Super-Puper-Mega-Proga"></head>
<body bgcolor="#DDE1C2"><b><a href="http://www.opennet.ru/docs/">Архив документации OpenNet.ru</a> / 
Раздел "<a href="http://www.opennet.ru/docs/124.shtml">Программирование, языки</a>" /
<a href="index.html">Индекс</a>
</b>
<hr noshade size=1>

<h1 align=center>Расширенный Ассемблер: NASM</h1>

<p align=center><a href="nasm_ru9.html">Следующая глава</a> | <a href="nasm_ru7.html">Предыдущая 
  глава</a> | <a href="contents.html">Содержание</a> | Указатель</p>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr> 
    <td width="71%"> 
      <h2><a name="chapter-8">Глава 8: Написание 32-х битного кода <br>
        (Unix, Win32, DJGPP)</a></h2>
    </td>
    <td width="29%"> 
      <div align="right"><font size="-1" color="#666666">Перевод: <a href="http://asmdev.narod.ru/asmos.html">AsmOS 
        group</a>, &copy; 2001</font></div>
    </td>
  </tr>
</table>
Эта глава повествует о наиболее распространенных проблемах, возникающих
при написании 32-ух разрядного кода для Win32 или Unix, или для сборки
(linking) с Си-кодом, полученным компилятором Си Unix-стиля, таким как
DJGPP. Здесь также рассматривается как писать ассемблерный код для
взаимодействия (interface) с кодом, полученным 32-ух битным компилятором
с Cи и как создавать перемещаемый код для разделяемых библиотек.

<p>Почти весь 32-ух битный код и практически весь код, выполняемый под Win32, 
  DJGPP или под любой вариант Unix для ПК выполняется в <em>плоской</em> (<em>flat</em>) 
  модели памяти. Это означает, что сегментные регистры и механизм страничной адресации 
  уже установлены заранее для того, чтобы дать вам одно и то же 32-битное адресное 
  пространство в 4 Гб, не зависимо относительно какого сегмента вы работаете, 
  и поэтому вы должны полностью игнорировать (не использовать) все сегментные 
  регистры. Когда вы пишите приложение под плоскую модель памяти, вам никогда 
  не потребуется замещение сегментов или изменение значения каких-либо сегментных 
  регистров, и адреса сегмента кода, которые вы передаете инструкциям <font color="#000099">CALL</font> 
  и <font color="#000099">JMP</font> остаются в том же адресном пространстве, 
  что и адреса сегмента данных через которые вы обращаетесь к переменным и адреса 
  сегмента стека, которые вы используете для доступа к локальным переменным и 
  параметрам процедур. Каждый адрес имеет размер 32 бита и содержит только смещение 
  (offset-ную) часть адреса. 
<h3><a name="section-8.1">8.1 Интерфейс с 32-ух битными программами на Си</a></h3>

<p>Все рассуждения в <a href="nasm_ru7.html#section-7.4">параграфе 7.4</a>, относящиеся 
  к интерфейсу с 16-ти битными программами на Си также применимы и к 32-ух битным. 
  Отсутствие моделей памяти или сегментации не должно вызывать у вас беспокойства. 
<h4><a name="section_8_1_1">8.1.1 Внешние символьные имена</a></h4>
<p>Большинство 32-ух битных Си-компиляторов поддерживают конвенцию,
используемую в 16-ти битных компиляторах: имена всех глобальных
имен (функций или переменных) они определяют префиксом
⌠подчеркивание■ (например: extrn_link в Си будет _extrnlink в
линкуемом файле), добавляемое к имени, действующем в Си-программе.
Правда, не все это делают: спецификация ELF указывает, что все имена
в Си-программе <em>не имеют</em> предваряющего подчеркивания в их
эквивалентах на языке ассемблера.

<p>Старый Си-компилятор в Линуксе <font color="#000099">a.out</font>, все компиляторы 
  для Win32, DJGPP, NetBSD и FreeBSD, все они используют предваряющее ⌠подчеркивание■; 
  для этих компиляторов макросы <font color="#000099">cextern</font> и <code><font color="#000099">cglobal</font></code>, 
  как они описаны в <a href="nasm_ru7.html#section-7.4.1">параграфе 7.4.1</a>, 
  будут работать. Для ELF, разумеется, предваряющее подчеркивание не используется. 
<h4><a name="section_8_1_2">8.1.2 Определение и вызов функций</a></h4>
<p>Конвенция Си для вызова в 32-ух битных программах приведена ниже.
В этом описании использованы выражения <em>вызывающий код</em> и
<em>вызываемая функция</em> для того, чтобы указать делает ли
функция вызов, или функция получает управление.

<ul>
  <li>Вызывающий код проталкивает параметры в стек один за другим в обратном порядке 
    (справа налево, таким образом, первый объявленный аргумент функции будет помещен 
    в стек последним). 
  <li>Затем вызывающий код выполняет ближний вызов, чтобы передать управление 
    вызываемой функции. 
  <li>Вызываемая функция, получая управление, и обычно (хотя это не всегда необходимо 
    в функциях, которые не обращаются к своим параметрам) начиная с сохранения 
    значений <font color="#000099">ESP</font> в <font color="#000099">EBP</font>,чтобы 
    можно было использовать <font color="#000099">EBP</font> как базовый указатель 
    для доступа к параметрам в стеке. Однако, вызывающий код возможно делает тоже 
    самое (устанавливает <font color="#000099">EBP</font> на свой стек), поэтому 
    по этой части конвенции о вызове, состояние <font color="#330099">EBP</font> 
    должно быть сохранено во всех Си-функциях. Поэтому вызываемая функция, если 
    она хочет установить <font color="#000099">EBP</font> как указатель на свои 
    параметры должна сначала сохранить в стеке его предыдущее значение. 
  <li>Вызываемая функция может обращаться к своим параметрам относительно <font color="#000099">EBP</font>. 
    Двойное слово по адресу <font color="#000099">[EBP]</font> содержит предыдущее 
    значение <font color="#000099">EBP</font>, т.к. оно было сохранено в стеке; 
    следующее двойное слово по адресу <font color="#000099">[EBP+4]</font> содержит 
    адрес возврата, протолкнутый туда инструкцией <font color="#000099">CALL</font>. 
    После этого начинаются параметры &#151; с адреса <font color="#000099">[EBP+8]</font>. 
    Самый левый параметр функции, т.к. он был помещен в стек последним, доступен 
    по этому смещению от <font color="#000099">EBP</font>; остальные расположены 
    по бОльшим смещениям. Поэтому, в таких функциях как <font color="#000099">printf</font>, 
    которые имеют переменное число параметров, заталкивание параметров в обратном 
    порядке позволяет функции узнать где находится первый параметр, в котором 
    содержится информация о количестве и типах остальных. 
  <li>Вызываемая функция также может уменьшить значение <font color="#000099">ESP</font> 
    для того, чтобы зарезервировать место в стеке для локальных переменных, которые 
    будут доступны как отрицательные смещения относительно <font color="#000099">EBP</font>. 
  <li>Вызываемая функция, если она хочет вернуть значение вызывающему коду, должна 
    оставить это значение в <font color="#000099">AL, AX</font> или <font color="#000099">EAX</font>, 
    в зависимости от размера. Значения с плавающей запятой обычно возвращаются 
    в <font color="#000099">ST0</font>. 
  <li>Как только вызываемая функция закончила свои основные действия, она восстанавливает 
    <font color="#000099">ESP</font> из <font color="#000099">EBP</font> если 
    она резервировала место в стеке, затем выталкивает предыдущее значение <font color="#000099">EBP</font>, 
    и возвращает управление через <font color="#000099">RET</font> (эквивалентно, 
    <font color="#000099">RETN</font>). 
  <li>Когда вызывающий код снова получает контроль от вызываемой функции, параметры 
    функции все еще остаются в стеке, поэтому обычно к значению <font color="#000099">ESP</font> 
    прибавляется непосредственное значение, чтобы убрать их (вместо выполнения 
    нескольких медленных инструкций <font color="#000099">POP</font>). Поэтому, 
    если функция случайно будет вызвана с неверным числом параметров, т.е. не 
    соответствующем прототипу, стек будет возвращен вызывающим кодом в то состояние, 
    в котором он находился до вызова этой функции, который <em>знает</em> сколько 
    параметров было помещено в стек, и удаляет их оттуда. 
</ul>

<p>Существует альтернативная конвенция вызова, используемая в <font color="#000099">Win32</font> 
  программах для вызовов через Windows API, а также для функций, вызываемых Windows 
  API, таких как оконные процедуры (window procedures): они описаны так, чтобы 
  использовать Microsoft <font color="#000099">__stdcal</font>l конвенцию. Это 
  очень похоже на конвенцию Паскаля, в вызываемой функции очищаются параметры 
  из стека, используя параметр с инструкцией <font color="#000099">RET</font>. 
  Однако, параметры также передаются справа налево. 
<p>Если вы определите функцию в стиле языка Си следующим образом:
<p><pre>
          global _myfunc 
_myfunc:  push ebp 
          mov ebp,esp 
          sub esp,0x40           ; 64 байта для локальных переменных
          mov ebx,[ebp+8]        ; Первый параметр функции
          ; еще какой-нибудь код 
          leave                  ; mov esp,ebp / pop ebp 
          ret
</pre>

<p>С другой стороны, чтобы вызывать Си-функцию из вашего
ассемблерного кода, вы должны сделать что-то вроде этого:

<p><pre>
          extern _printf 
          ; и затем... 
          push dword [myint]     ; одна из моих переменных целого типа 
          push dword mystring    ; указатель в моем сегменте данных
          call _printf 
          add esp,byte 8         ; `byte' уменьшит размер кода 
          ; и теперь объявления данных... 
          segment _DATA 
myint     dd 1234 
mystring  db 'Это число -&gt; %d &lt;- должно быть 1234',10,0
</pre>


<p>Этот фрагмент кода √ ассемблерный эквивалент Си-кода
<p><pre>
    int myint = 1234; 
    printf("Это число -&gt; %d &lt;- должно быть 1234\n", myint);
</pre>

<h4><a name="section_8_1_3">8.1.3 Доступ к переменным</a></h4>

<p>Чтобы получить доступ к Си-переменным, или чтобы объявить переменные, к которым 
  может обращаться Си, вам достаточно объявить имена как <font color="#000099">GLOBAL</font> 
  или <font color="#000099">EXTERN</font>. (Опять же, имена нужно предварять подчеркиванием, 
  как это описано в <a href="#section-8.1.1"> параграфе 8.1.1</a>.) Таким образом, 
  Си-переменные, объявленные как<font color="#000099"> int i </font>могут быть 
  доступны из ассемблера как 
<p><pre>
          extern _i 
          mov eax,[_i]
</pre>

<p>И чтобы объявить ваши собственные переменные, которые будут доступны Си-программе 
  как<font color="#000099"> int j</font>, делайте это так (проверьте, что вы ассемблируете 
  это в <font color="#000099">_DATA</font> сегменте, если это необходимо): 
<p><pre>
          global _j 
_j        dd 0
</pre>

<p>Чтобы обращаться с Си-массивами необходимо знать размер элементов этого массива. 
  Например, <font color="#000099">int</font> переменные имеют размер 4 байта, 
  поэтому если в Си-программе объявлен массив как <font color="#000099">int a[10]</font>, 
  можно обращаться к <font color="#000099">a[3]</font> так: <font color="#000099">mov 
  ax,[_a+12]</font>. ( Смещение 12 полчается в результате умножения номера в массиве, 
  3 на размер элемента массива, 4.) Размеры базовых типов в 32-х разрядных Си-компиляторах: 
  1 для <font color="#000099">char</font>, 2 для <font color="#000099">short</font>, 
  4 для <font color="#000099">int, long</font> и <font color="#000099">float</font>, 
  и 8 для <font color="#000099">double</font>. Указатель, содержащий 32-ух битный 
  адрес имеет также размер 4 байта. 
<p>Чтобы обращаться к структурам языка Си, необходимо знать смещение от базового 
  адреса структуры до интересующего вас поля. Вы можете просто это делать, конвертируя 
  определения Си-структур в определения структур NASM (<font color="#000099">STRUC</font>), 
  или вычисляя одно смещение и используя только его. 
<p>Чтобы делать это проще, вам необходимо причитать руководство по вашему компилятору 
  языка Си и найти как он организует структуры данных. NASM не делает специальных 
  выравниваний членов структуры в его макросе <font color="#000099">STRUC</font>, 
  поэтому вы должны указывать выравнивания самостоятельно, если Си-компилятор 
  генерирует их. Обычно вы можете обнаружить, что подобная структура 
<p><pre>
struct { 
    char c; 
    int i; 
} foo;
</pre>
<p>имеет размер не 5 байт, а 8, так как <font color="#000099">int</font> поле 
  будет выровнено на границу двойного слова. Однако, эту возможность иногда можно 
  настроить в Си-компиляторе, используя параметры командной строки или <font color="#000099">#pragma</font> 
  &#151; директивы, поэтому можно найти как ваш компилятор это делает. 
<h4><a name="section-8.1.4">8.1.4 c32.mac: Вспомогательные макросы для 32-ух битного 
  интерфейса с Си</a></h4>
<p>Файл макроса <font color="#000099">c32.mac</font> включен в архив NASM, в каталог 
  <font color="#000099">misc</font>. В этом файле определены 3 макроса: <font color="#000099">proc, 
  arg</font> и <font color="#000099">endproc</font>. Они введены для использования 
  в определении процедур в стиле Си, и она автоматизируют операции, необходимые 
  для соблюдения конвенции вызова. 
<p>Пример ассемблерной функции, использующей этот набор макросов приведен ниже: 
<p><pre>
          proc _proc32 
%$i       arg 
%$j       arg 
          mov eax,[ebp + %$i] 
          mov ebx,[ebp + %$j] 
          add eax,[ebx] 
          endproc
</pre>

<p>Этот фрагмент определяет<font color="#000099"> _proc32</font> как процедуру 
  с двумя аргументами, первый (<font color="#000099">i</font>) является <font color="#000099">integer</font> 
  и второй (<font color="#000099">j</font>) является указателем на <font color="#000099">integer</font>. 
  Процедура возвращяет<font color="#000099"> i + *j</font>. 
<p>Заметьте, что макрос <font color="#000099">arg</font> при его разворачивании 
  содержит в первой строке <font color="#000099">EQU</font>, которая в результате 
  определяет <font color="#000099">%$i</font> как смещение от <font color="#000099">BP</font>. 
  При этом используются контекстно-локальные переменные (локальные к контексту, 
  сохраняемому в контекстном стеке макросом <font color="#000099">proc</font> 
  и удаляемому оттуда макросом <font color="#000099">endproc</font>), поэтому 
  в других процедурах может быть использовано то же самое имя аргумента. Конечно, 
  вы можете этого <i>не делать</i>.
<p><font color="#000099">arg</font> можно передать необязательный параметр, указывающий 
  размер аргумента. Если размер не задан, он предполагается равным 4-ем, потому 
  что абсолютное большинство параметров функции будут типа <font color="#000099">int</font> 
  или указателями. 
<h3><a name="section-8.2">8.2 Написание разделяемых библиотек для NetBSD/FreeBSD/OpenBSD 
  и Linux/ELF</a></h3>

<p>ELF замещает старый объектный формат<font color="#000099"> a.out</font> для 
  Линукса, потому что он поддерживает перемещаемый код (position-independent code 
  &#151; PIC), который позволяет писать разделяемые библиотеки намного проще. 
  NASM поддерживает особености перемещаемого кода для <font color="#000099">ELF</font>, 
  поэтому вы можете писать разделяемый библиотеки для Линукс ELF на NASM. 
<p>NetBSD, и его близкие родственники FreeBSD и OpenBSD, используют другой подход, 
  добавив поддержку перемещаемого кода в формат <font color="#000099">a.out</font>. 
  NASM поддерживает это как формат <font color="#000099">aoutb</font> для скомпилированных 
  файлов, поэтому вы можете писать разделяемые библиотеки для BSD на NASM тоже. 
<p>Операционная система загружает разделяемую PIC (пермещаемый код) 
библиотеку, делая
отображение в память файла библиотеки в произвольно выбранное 
место в адресном пространстве выполняемого процесса. Поэтому содержимое
секции кода библиотеки должно не зависеть от места в памяти, куда она 
загружена.

<p>Поэтому, вы не можете обращаться к вашей переменной таким вот способом:
<p><pre>
          mov eax,[myvar]        ; ОШИБКА
</pre>

<p>Вместо этого, линковщик предоставляет область памяти, называемую <em>глобальной 
  таблицей смещений (global offset table)</em>, или просто ГТС (GOT); ГТС расположена 
  на постоянном расстоянии от кода вашей библиотеки, поэтому если вы сможете узнать 
  куда загружена ваша библиотека (что обычно осуществляется комбинацией <font color="#000099">CALL</font> 
  и <font color="#000099">POP</font>), вы сможете получить адрес ГТС, и затем 
  загрузить адрес вашей переменной из сгенерированной линковщиком записи в ГТС. 
<p>Секция <em>data</em> PIC (перемещяемый код) разделяемой библиотеки не имеет 
  подобных ограничений: поскольку секция данных доступна для записи, она может 
  быть скопирована в память каким бы то ни было образом, не только отображением 
  в страницы из файла библиотеки, поэтому как только она будет скопирована, она 
  может быть также перемещена. Поэтому вы можете обычный способ для доступа в 
  секции данных, особо не заботясь об этом (но посмотрите в <a href="#section-8.2.4">параграфе 
  8.2.4</a> предостережения). 
<h4><a name="section-8.2.1">8.2.1 Получение адреса ГТС</a></h4>

<p>Каждый фрагмент кода в вашей разделяемой библиотеке должен
определить ГТС как внешнее имя:

<p><pre>
          extern _GLOBAL_OFFSET_TABLE_   ; в ELF 
          extern __GLOBAL_OFFSET_TABLE_  ; в BSD a.out
</pre>

<p>В начале каждой функции вашей разделяемой библиотеки, которая собирается
обращаться к вашим секциям data или BSS, должен вычисляться адрес ГТС.
Это обычно осуществляется написанием функции в такой форме:

<p><pre>
func:     push ebp 
          mov ebp,esp 
          push ebx 
          call .get_GOT 
.get_GOT: pop ebx 
          add ebx,_GLOBAL_OFFSET_TABLE_+$$-.get_GOT wrt ..gotpc 
          ; Тело функции начинается отсюда 
          mov ebx,[ebp-4] 
          mov esp,ebp 
          pop ebp 
          ret
</pre>
<p>(Для BSD, снова, имя <font color="#000099">_GLOBAL_OFFSET_TABLE</font> нужно 
  предварить вторым знаком подчеркивания.) 
<p>Первые две сточки этой функции &#151; это просто стандартное начало для Си, 
  чтобы установить стековый кадр, и последние три строчки &#151; стандартное завершение 
  Си-функции. Третья строка, и с четвертой по последнюю сктроки, сохраняют и восстанавливают 
  регистр <font color="#000099">EBX</font>, потому что PIC (перемещаемый код) 
  разделяемая библиотека использует этот регистр для сохранения адреса ГТС. 
<p>Интересный фрагмент это инструкция <font color="#000099">CALL</font> и следующие 
  за ней две строки. Комбинация <font color="#000099">CALL</font> и <font color="#000099">POP</font> 
  получают адрес метки<font color="#000099"> .get_GOT</font>, без узнавания в 
  точности куда загружена программа (потому что инструкция <font color="#000099">CALL</font> 
  кодируется относительно текущей позиции). Инструкция <font color="#000099">ADD</font> 
  позволяет использовать специальный PIC (перемещаемый код) тип размещения: <font color="#000099">GOTPC</font> 
  размещение. Со спецификатором <font color="#000099">WRT ..gotpc</font> размещение 
  имен (здесь <font color="#000099">_GLOBAL_OFFSET_TABLE_</font>, специальное 
  имя, связанное с ГТС) дается как смещение от начала секции. (Вобще-то, ELF кодирует 
  это как смещение от поля операндов инстуркции <font color="#000099">ADD</font>, 
  но NASM нарочно это упрощает, поэтому этот метод подходит для обоих ELF и BSD.) 
  Таким образом, затем инструкция <em>добавляет</em> начало секции, чтобы получить 
  настоящий адрес ГТС, и вычитает значение <font color="#000099">.get_GOT</font> 
  которое находится в <font color="#000099">EBX</font>. Поэтому, в то время, когда 
  инструкция завершится, <font color="#000099">EBX</font> содержит адрес ГТС. 
<p>Если вы не следили за рассуждениями, не беспокойтесь:
никогда не приходится получать адрес ГТС другими способами,
поэтому вы можете поместить эти три инструкции в макрос и
не обращать на них внимания:
<p><pre>
%macro get_GOT 0 
          call %%getgot 
%%getgot: pop ebx 
          add ebx,_GLOBAL_OFFSET_TABLE_+$$-%%getgot wrt ..gotpc 
%endmacro
</pre>


<h4><a name="section-8.2.2">8.2.2 Нахождение ваших локальных переменных</a></h4>

<p>Имея ГТС, вы можете использовать ее для получения адресов ваших переменных. 
  Большинство переменных будут постоянно находится в секциях, которые вы объявили; 
  к ним можно получить доступ, используя <font color="#000099">..gotoff</font> 
  специальный тип <font color="#000099">WRT</font>. Вот как это работает: 
<p><pre>
          lea eax,[ebx+myvar wrt ..gotoff]
</pre>

<p>Выражение <font color="#000099">myvar wrt ..gotoff</font> вычисляется, затем 
  разделяемая библиотека линкуется, чтобы оно стало смещением локальной переменной 
  <font color="#000099">myvar</font> от начала ГТС Поэтому, прибавление его к 
  <font color="#000099">EBX</font>, как это показано выше, помещает настоящий 
  адрес <font color="#000099">myvar</font> в <font color="#000099">EAX</font>. 
<p>Если объявить переменные как <font color="#000099">GLOBAL</font> без указания 
  их размера, они разделяются между фрагментами кода в библиотеке, но не могут 
  быть экспортированы из библиотеки в программу, которая ее загрузила. Они будут 
  по прежнему в вашей обычных секциях <font color="#000099">data</font> и <font color="#000099">BSS</font>, 
  поэтому доступ к ним можно получить таким же методом, что и к локальным переменных, 
  используя описанный ранее механизм <font color="#000099">..gotoff</font>. 
<p>Обратите внимание, что из-за специфики в BSD <font color="#000099">a.out</font> 
  формата описатели этого перемещаемого типа, должно существовать хотя бы одно 
  нелокальное имя в той же секции, что и адрес, к которому вы обращаетесь. 
<h4><a name="section-8.2.3">8.2.3 Нахождение внешних и общих переменных</a></h4>

<p>Если вашей библиотеки требуется получить внешнюю переменную (внешнюю по отношению 
  к <em>library</em>, не только к одному модулю в ней), необходимо использовать 
  тип <font color="#000099">..got</font>, чтобы этого добиться. Тип <font color="#000099">..got</font>, 
  вместо того, чтобы давать смещение от базы ГТС до переменной, дает смещение 
  от базы ГТС до <em>элемента</em> ГТС, содержащего адрес переменной. Линковщик 
  настраивает этот элемент ГТС когда делает библиотеку, и динамический линковщик 
  помещает правильный адрес во время загрузки. Таким образом, чтобы получить адрес 
  внешней переменной <font color="#000099">extvar</font> в <font color="#000099">EAX</font>, 
  вам понадобиться написать: 
<p><pre>
          mov eax,[ebx+extvar wrt ..got]
</pre>

<p>Эта строчка загружает адрес <font color="#000099">extvar</font> из элемента 
  ГТС. Линковщик, когда он делает разделяемую библиотеку, собирает вместе все 
  перемещения типа<font color="#000099"> ..got</font>, и создает ГТС, поэтому 
  это обеспечивает существование каждого необходимого элемента. 
<p>Общие переменные должны использоваться таким же образом. 
<h4><a name="section-8.2.4">8.2.4 Экспортирование имен в библиотеку пользователя</a></h4>

<p>Чтобы экспортировать имена пользователю библиотеки, необходимо объявить являются 
  ли они функциями или данными, и если это данные, необходимо указать размер переменной. 
  Это нужно для того, чтобы динамический линковщик создает таблицу связей входов 
  процедур для каждой экспортированной функции, а также перемещает экспортированные 
  переменные из секции данных библиотеки в которой они были объявлены. 
<p>Таким образом, чтобы экспортировать функцию в библиотеку пользователя, 
необходимо использовать
<p><pre>
          global func:function   ; объявить это как функцию 
func:     push ebp 
          ; etc.
</pre>
<p>А чтобы экспортировать переменные, такие как массивы, понадобится
такой код
<p><pre>
          global array:data array.end-array ; и указать размер... 
array:    resd 128 
.end:
</pre>

<p>Будьте осторожны: если экспортировать переменную в библиотеку пользователя, 
  объявив ее как <font color="#000099">GLOBAL</font> и указать ее размер, переменная 
  окажется в сегменте данных главной программы, вместо сегмента данных вашей библиотеки, 
  в котором объявлена. Поэтому получать доступ к вашей глобальной переменной вам 
  нужно, используя механизм <font color="#000099">..got</font>, вместо<font color="#000099"> 
  ..gotoff</font>, как если бы она была внешней (которая, вобщем, таковой и стала). 
<p>В равной мере, если необходимо сохранить адрес экспортированной
глобальной переменной в вашем сегменте данных, вам ен удастся это
сделать стандартным образом:

<p><pre>
dataptr:  dd global_data_item    ; ОШИБКА
</pre>

<p>NASM интерпретирует этот код как обычное резервирование, в котором <font color="#000099">global_data_item</font> 
  просто смещение от начала сегмента <font color="#000099">.data</font> (или чего-то 
  другого); поэтому это определение будет указывать на ваш сегмент данных, вместо 
  экспортирования глобальной переменной, которая находится в другом месте. 
<p>Вместо вышеописанного кода, тогда, используйте 
<p><pre>
dataptr:  dd global_data_item wrt ..sym
</pre>

<p>что использует специальный тип <font color="#000099">WRT ..sym</font>, чтобы 
  указать NASM-у искать в таблице имен особое имя для этого объявления, место 
  простого определения относительно базы сегмента. 
<p>Тотже метод будет работать и для функций: объявление одной
из ваших функций следующим образом
<p><pre>
funcptr:  dd my_function
</pre>

<p>предоставит пользователю адрес вашего кода, тогда как

<p><pre>
funcptr:  dd my_function wrt ..sym
</pre>
<p>предоставит адрес процедуры сборки (линковки) таблицы для этой функции, который 
  вызывающая прогамма будет полагать как местоположение функции. Получение этого 
  адреса &#151; правильный способ вызова функции. 
<h4><a name="section-8.2.5">8.2.5 Вызов процедур вне библиотеки</a></h4>

<p>Вызов процедур извне вашей разделяемой библиотеки может быть
осуществлен через <em>таблицу сборки процедуры(procedure linkage table)</em>, 
или ТСП(PLT). ТСП помещается по известному смещению от того места, куда
загружена библиотека, поэтому библиотечный код может делать вызовы
к ТСП в переносимом (не зависимого от места) стиле. Внутри ТСП есть
код для перехода на смещения, расположенные в ГТС, поэтому вызовы
из функции к другим разделяемым библиотекам или к коду в главной программе
могут быть незаметно направлены на их реальные местоположения.
 
<p>Чтобы вызывать внешний код, необходимо использовать другой специальный PIC 
  (переносимый код) тип переноса, <font color="#000099">WRT ..plt</font>. Это 
  намного проще, чем использовать ГТС: просто замещается вызовы, например, такие 
  <font color="#000099">CALL printf </font>на версию, использующую ТСП &#151; 
  <font color="#000099">CALL printf WRT ..plt</font>. 
<h4><a name="section-8.2.6">8.2.6 Создание библиотечного файла</a></h4>

<p>Написав несколько модулей с кодом и ассемблировав их в <font color="#000099">.o</font> 
  файлы, вы создаете вашу разделяемую библиотеку командами наподобие таких: 
<p><pre>
ld -shared -o library.so module1.o module2.o       # for ELF 
ld -Bshareable -o library.so module1.o module2.o   # for BSD
</pre>

<p>Для ELF, если вашу разделяемую библиотеку предполагается использовать в системных 
  каталогах, таких как <font color="#000099">/usr/lib</font> или<font color="#000099"> 
  /lib</font>, это обычно делают, использую параметр <font color="#000099">-soname</font> 
  при сборке (линковке), чтобы сохранить конечный библиотечный файл с именем, 
  с номером версии в библиотеке: 
<p><pre>
ld -shared -soname library.so.1 -o library.so.1.2 *.o
</pre>
<p>А вы потом скопируете файл <font color="#000099">library.so.1.2</font> в библиотечный 
  каталог, и создадите символьную ссылку <font color="#000099">library.so.1</font> 
  к нему. 
<p align=center><a href="nasm_ru9.html">Следующая глава</a> | <a href="nasm_ru7.html">Предыдущая 
  глава</a> | <a href="contents.html">Содержание</a> | Указатель
<hr noshade size=1>
<b><a href="http://www.opennet.ru/docs/">Архив документации на OpenNet.ru</a>
</body></html>
