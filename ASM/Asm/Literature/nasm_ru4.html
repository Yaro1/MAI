<html><head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r"><title>Руководство по NASM</title>

<META NAME="GENERATOR" CONTENT="Super-Puper-Mega-Proga">
</head>
<body bgcolor="#DDE1C2"><b><a href="http://www.opennet.ru/docs/">Архив документации OpenNet.ru</a> / 
Раздел "<a href="http://www.opennet.ru/docs/124.shtml">Программирование, языки</a>" /
<a href="index.html">Индекс</a>
</b>
<hr noshade size=1>

<h1 align=center>Расширенный ассемблер: NASM</h1>

<p align=center><a href="nasm_ru5.html">Следующая глава </a> | <a href="nasm_ru3.html">Предыдущая 
  глава</a> | <a href="contents.html">Содержание</a> | Указатель
</p>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr> 
    <td width="60%"> 
      <h2><a name="chapter-4">Глава 4: Препроцессор NASM</a></h2>
    </td>
    <td> 
      <div align="right"><font size="-1" color="#666666">Перевод: <a href="http://asmdev.narod.ru/asmos.html">AsmOS 
        group</a>, &copy; 2001</font></div>
    </td>
  </tr>
</table>
NASM содержит мощный макропроцессор, поддерживающий условное ассемблирование, 
многоуровневое включение файлов, две формы макро-определений (однострочные и многострочные) 
и механизм "контекстного стека", расширяющий возможности макро-определений (далее 
√ макросы). Все директивы препроцессора начинаются со знака <font color="#000099">%</font>. 
<h3><a name="section-4.1">4.1 Однострочные макросы</a></h3>
<h4><a name="section-4.1.1">4.1.1 Обычный способ: <font color="#000099">%define</font></a></h4>
<p>Однострочные макросы описываются при помощи директивы препроцессора <font color="#000099">%define</font>. 
  Определения работают подобно языку С; т.е. вы можете сделать что-то наподобие 
</p>
<pre><font color="#666666">%define ctrl 0x1F &amp; 
%define param(a,b) ((a)+(a)*(b)) 
          mov byte [param(2,ebx)], ctrl 'D'</font></pre>
<p>что будет развернуто в </p>
<pre><font color="#666666">          mov byte [(2)+(2)*(ebx)], 0x1F &amp; 'D'</font></pre>
<p>Если однострочный макрос содержит символы, вызывающие другой макрос, то развертывание 
  первого осуществляется в процессе вызова, а не при определении. Так, код</p>
<pre><font color="#666666">%define a(x) 1+b(x) 
%define b(x) 2*x 
          mov ax,a(8)</font></pre>
<p>будет обработан как и ожидается &#151; <font color="#000099">mov ax,1+2*8</font>, 
  несмотря на то, что при описании <font color="#000099">a</font> макрос <font color="#000099">b</font> 
  еще не определен. </p>
<p>Макросы, описываемые конструкцией <font color="#000099">%defin</font>e, регистрочувствительны: 
  после <font color="#000099">%define foo bar</font> только <font color="#000099">foo</font> 
  будет развернуто в <font color="#000099">bar</font>, но никак не <font color="#000099">Foo</font> 
  или <font color="#000099">FOO</font>. При использовании вместо <font color="#000099">%define</font> 
  конструкции <font color="#000099">%idefine</font> ('<font color="#000099">i</font>' 
  от слова 'insensitive') вы можете сразу описать все варианты комбинации строчных 
  и прописных букв в имени макроса, поэтому <font color="#000099">%idefine foo 
  bar</font> будет развертывать в <font color="#000099">bar</font> не только <font color="#000099">foo</font>, 
  но и <font color="#000099">Foo, FOO, fOO</font> и т.п. </p>
<p>Существует механизм, следящий за рекурсивным развертыванием макросов, предотвращающий 
  циклические ссылки и бесконечные циклы. Когда это случается, препроцессор будет 
  развертывать только первое вхождение макроса. Так, в коде </p>
<pre><font color="#666666">%define a(x) 1+a(x) 
          mov ax,a(3)</font></pre>
<p>макрос <font color="#000099">a(3)</font> будет развернут единожды, т.е. в конструкцию 
  <font color="#000099">1+a(3)</font> и дальнейшее развертывание производиться 
  не будет. Данная возможность может быть полезна: в <a href="nasm_ru8.html#section-8.1">параграфе 
  8.1</a> имеется соответствующий пример. </p>
<p>Вы можете перегружать однострочные макросы: если вы напишете </p>
<pre><font color="#666666">%define foo(x) 1+x 
%define foo(x,y) 1+x*y</font></pre>
<p>препроцессор, подсчитав передаваемые вами параметры, корректно обработает оба 
  типа вызова макроса: <font color="#000099">foo(3)</font> будет развернуто в 
  <font color="#000099">1+3</font>, в то время как <font color="#000099">foo(ebx,2)</font> 
  &#151; в <font color="#000099">1+ebx*2</font>. В то же время, если вы напишете 
</p>
<pre><font color="#666666">%define foo bar</font></pre>
<p>последующие описания <font color="#000099">foo</font> будут запрещены: макрос 
  без параметров не допускает описание макроса с тем же именем, но с <i>параметрами</i>, 
  и наоборот. </p>
<p>Несмотря на это, <i>переопределение</i> однострочных макросов не запрещается: 
  вы можете легко описать макрос как </p>
<pre><font color="#666666">%define foo bar</font></pre>
<p>и затем, в том же самом исходном файле, переопределить его как </p>
<pre><font color="#666666">%define foo baz</font></pre>
<p>Когда макрос <font color="#000099">foo</font> будет вызван, он развернется 
  в соответствии с самым поздним своим описанием. Это полезно в основном при описании 
  однострочных макросов с конструкцией <font color="#000099">%assign</font> (см. 
  <a href="#section-4.1.4">параграф 4.1.4</a>). </p>
<p>Вы можете переопределить однострочный макрос при помощи ключа '<font color="#000099">-d</font>' 
  командной строки NASM: см. <a href="nasm_ru2.html#section-2.1.8">параграф 2.1.8</a>. 
</p>
<p>При описании однострочных макросов вы можете объединять строки при помощи псевдо-оператора 
  <font color="#000099">%+</font>. Например: </p>
<pre><font color="#666666">%define _myfunc _otherfunc 
%define cextern(x) _ %+ x 
cextern (myfunc)</font></pre>
<p>После первого развертывания третья строка примет вид "<font color="#000099">_myfunc</font>". 
  При дальнейшей обработке препроцессор развернет эту строку в "<font color="#000099">_otherunc</font>". 
</p>
<p>
<h4><a name="section-4.1.2">4.1.2 Однострочные макросы раннего связыванияs: <font color="#000099">%xdefine</font></a></h4>
<p>Механизм <font color="#000099">%define</font>, описанный в предыдущем параграфе, 
  обеспечивает описание однострочных макросов с <i>поздним связыванием</i>, при 
  котором ссылки на другие макросы разворачиваются при их вызове, поэтому если 
  вы в это время измените внутренний макрос, значение развернутого макроса соответственно 
  изменится. Это свойство полезно, но в некоторых случаях нежелательно. Например: 
</p>
<pre><font color="#666666">%assign ofs 0 
%macro arg 1 
        %xdefine %1 dword [esp+ofs] 
        %assign ofs ofs+4 
%endmacro 
        arg  a 
        arg  b</font>
</pre>
<p>Если в этом примере вместо <font color="#000099">%xdefine</font> мы используем 
  <font color="#000099">%define</font>, оба макроса будут развернуты в одно и 
  то же значение <font color="#000099">dword [esp+8]</font>, что неверно. При 
  использовании конструкции <font color="#000099">%xdefine</font> макрос разворачивается 
  во время его определения, поэтому <font color="#000099">a</font> будет развернуто 
  в <font color="#000099">dword [esp+0]</font>, а <font color="#000099">b</font> 
  &#151; в <font color="#000099">dword [esp+4]</font>. </p>
<p>Макрос <font color="#000099">%xdefine</font> имеет нечувствительный к регистру 
  эквивалент <font color="#000099">%ixdefine</font>, работающий так же, как и 
  <font color="#000099">%idefine</font> по отношению к <font color="#000099">%define</font>. 
</p>
<h4><a name="section-4.1.3">4.1.3 Отмена определения макроса: <font color="#000099">%undef</font></a></h4>
<p>Команда <font color="#000099">%undef</font> удаляет однострочные макросы. Например, 
  следующая последовательность: </p>
<pre><font color="#666666">%define foo bar 
%undef foo 
        mov eax, foo</font>
</pre>
<p>будет развернута в инструкцию <font color="#000099">mov eax, foo</font>, так 
  как после <font color="#000099">%undef</font> макрос <font color="#000099">foo</font> 
  больше не определен. </p>
<p>Отмена определения предопределенных макросов может быть осуществлена при помощи 
  ключа '<font color="#000099">-u</font>' командной строки NASM: см. <a href="nasm_ru2.html#section-2.1.9">параграф 
  2.1.9</a>. </p>
<h4><a name="section-4.1.4">4.1.4 Переменные препроцессора: <font color="#000099">%assign</font></a></h4>
<p>Альтернативным способом определения однострочных макросов является использование 
  директивы <font color="#000099">%assign</font> (и ее нечувствительного к регистру 
  эквивалента <font color="#000099">%iassign</font>, отличающегося от <font color="#000099">%assign</font> 
  тем же самым, чем <font color="#000099">%idefine</font> отличается от <font color="#000099">%define</font>). 
</p>
<p>Данная директива используется для определения однострочного макроса без параметров, 
  но включающего числовое значение. Это значение может быть задано в форме выражения 
  и обрабатывается оно только один раз &#151; при обработке директивы <font color="#000099">%assign</font>. 
</p>
<p>Как и в случае <font color="#000099">%define</font>, макрос, определенный при 
  помощи <font color="#000099">%assign</font>, может быть позднее переопределен, 
  например следующая строка </p>
<pre><font color="#666666">%assign i i+1</font></pre>
<p>увеличивает числовое значение макроса. </p>
<p><font  color="#000099">%assign</font> полезна для контроля завершения препроцессорных 
  циклов <font color="#000099">%rep</font>: пример этого см. в <a href="#section-4.4">параграфе 
  4.4</a>. Другие примеры применения <font color="#000099">%assign</font> можно 
  найти в <a href="nasm_ru7.html#section-7.4">параграфе 7.4</a> и <a href="nasm_ru8.html#section-8.1">парарафе 
  8.1</a>. </p>
<p>Выражение, передаваемое <font color="#000099">%assign</font>, является критическим 
  (см. <a href="nasm_ru3.html#section-3.7">параграф 3.7</a>) и должно на выходе 
  давать просто число (не включая в себя различные перемещающиеся ссылки наподобие 
  адресов кода и данных). </p>
<h3><a name="section-4.2">4.2 Многострочные макросы: <font color="#000099">%macro</font></a></h3>
<p>Многострочные макросы в большинстве своем похожи на макросы в MASM и TASM: 
  определение многострочного макроса в NASM выглядит похоже. </p>
<pre><font color="#666666">%macro prologue 1 
          push ebp 
          mov ebp,esp 
          sub esp,%1 
%endmacro</font>
</pre>
<p>Здесь определяется как макрос С-подобная функция <font color="#000099">prologue</font>: 
  теперь вы можете вызвать макрос следующим образом: </p>
<pre><font color="#666666">myfunc:   prologue 12</font></pre>
<p>что будет развернуто в три строки кода </p>

<pre><font color="#666666">myfunc:   push ebp 
          mov ebp,esp 
          sub esp,12</font>
</pre>
<p>Число 1 после имени макроса в строке <font color="#000099">%macro</font> определяет 
  число параметров, которые ожидает получить макрос <font color="#000099">prologue</font>. 
  Конструкция <font color="#000099">%1</font> внутри тела макроса ссылается на 
  первый передаваемый параметр. В случае макросов, принимающих более одного параметра, 
  ссылка на них осуществляется как <font color="#000099">%2,%3</font> и т.д. </p>
<p>Многострочные макросы, как и однострочные, чувствительны к регистру символов, 
  за исключением случая, когда вы примените альтернативную директиву <font color="#000099">%imacro</font>.</p>
<p>Если вам требуется передать в многострочный макрос запятую в качестве составной 
  части параметра, вы можете сделать это, заключив параметр в фигурные скобки. 
  Например: </p>
<pre><font color="#666666">%macro silly 2 
%2:       db %1 
%endmacro 
          silly 'a', letter_a    ; letter_a:  db 'a' 
          silly 'ab', string_ab  ; string_ab: db 'ab' 
          silly {13,10}, crlf    ; crlf:      db 13,10</font>
</pre>
<h4><a name="section-4.2.1">4.2.1 Перегрузка многострочных макросов</a></h4>
<p>Многострочные макросы, как и однострочные, могут быть перегружены путем определения 
  одного и того же имени несколько раз с разным числом параметров. В отличие от 
  однострочных макросов, здесь не делается исключений даже для макросов без параметров. 
  Так, вы можете написать </p>

<pre><font color="#666666">%macro prologue 0 
          push ebp 
          mov ebp,esp 
%endmacro</font>
</pre>
<p>для определения альтернативной формы функции-пролога, не выделяющей место в 
  стеке.</p>
<p>Иногда вам может захотеться "перегрузить" процессорные инструкции; например, 
  если вы определите </p>

<pre><font color="#666666">%macro push 2 
          push %1 
          push %2 
%endmacro</font>
</pre>
<p>позже вы сможете написать </p>

<pre><font color="#666666">          push ebx               ; эта строка не вызов макроса! 
          push eax,ecx           ; а это - вызов</font>
</pre>
<p>По умолчанию NASM будет выдавать предупреждение при обработке первой из этих 
  строк, так как <font color="#000099">push</font> теперь определена как макрос 
  и вызывается с числом параметров, определения для которого нет. При этом будет 
  сгенерирован корректный код, однако ассемблер даст предупреждение. Данное предупреждение 
  можно отключить при помощи ключа командной строки <font color="#000099">-w-macro-params</font> 
  (см. <a href="nasm_ru2.html#section-2.1.12">параграф 2.1.12</a>). </p>
<h4><a name="section-4.2.2">4.2.2 Локальные метки в макросах</a></h4>
<p>NASM позволяет внутри определения многострочного макроса описать метки, которые 
  останутся локальными для каждого вызова макроса: при многократном вызове макроса 
  имена меток каждый раз будут изменяться. Описание такой метки осуществляется 
  при помощи префикса <font color="#000099">%%</font>. Например, вы можете описать 
  инструкцию, выполняющую <font color="#000099">RET</font> если флаг <font color="#000099">Z</font> 
  установлен, следующим образом: </p>

<pre><font color="#666666">%macro retz 0 
          jnz %%skip 
          ret 
%%skip: 
%endmacro</font>
</pre>
<p>После этого вы можете вызывать этот макрос столько раз, сколько нужно, и при 
  этом в каждом вызове вместо метки <font color="#000099">%%skip</font> NASM будет 
  подставлять разные "реальные" имена. NASM создает имена в форме <font color="#000099">..@2345.skip</font>, 
  где число <font color="#000099">2345</font> изменяется при каждом вызове макроса. 
  Префикс <font color="#000099">..@</font> предотвращает пересечение имен локальных 
  меток макросов с механизмом обычных локальных меток, описанным в <a href="nasm_ru3.html#section-3.8">параграфе 
  3.8</a>. В связи с этим вам нужно избегать определения собственных меток в такой 
  форме (префикс <font color="#000099">..@</font>, затем число, затем точка), 
  иначе они могут совпасть с локальными метками макросов. </p>
<h4><a name="section-4.2.3">4.2.3 Поглощающие параметры макросов</a></h4>
<p>Иногда полезно определить макрос, собирающий всю командную строку в один параметр 
  после извлечения одного или двух небольших параметров из начала очереди. Примером 
  здесь может служить макрос, записывающий строку в файл MS-DOS, где вы можете 
  захотеть написать что-то вроде </p>
<pre><font color="#666666">          writefile [filehandle],"Привет, фуфел!",13,10</font></pre>
<p>NASM позволяет определить последний параметр макроса в качестве поглощающего. 
  Это означает, что если вы вызовете макрос с большим числом параметров, чем ожидалось, 
  все "лишние" параметры вместе с разделительными запятыми присоединятся к последнему 
  ожидаемому параметру. Так, если вы напишете: </p>
<pre><font color="#666666">%macro writefile 2+ 
          jmp %%endstr 
%%str:    db %2 
%%endstr: mov dx,%%str 
          mov cx,%%endstr-%%str 
          mov bx,%1 
          mov ah,0x40 
          int 0x21 
%endmacro</font>
</pre>
<p>то приведенный выше пример вызова макроса <font color="#000099">writefile</font> 
  будет работать как нужно: текст перед первой запятой <font color="#000099">[filehandle]</font> 
  используется в качестве первого параметра и развернется, когда встретится ссылка 
  <font color="#000099">%1</font>, весь последующий текст объединится в <font color="#000099">%2</font> 
  и расположится после <font color="#000099">db</font>. </p>
<p>Поглощающая природа макроса указывается в NASM при помощи знака (+) после количества 
  параметров в строке <font color="#000099">%macro</font>. </p>
<p>При определении поглощающего макроса вы тем самым говорите NASM, как он должен 
  разворачивать <i>любое</i> число параметров свыше явно указанного; в приведенном 
  случае, например, он будет знать, что должен делать при вызове <font color="#000099">writefile</font> 
  с 2,3,4 или большим числом параметров. NASM также будет это учитывать при перегрузке 
  макросов и не позволит вам определить другую форму <font color="#000099">writefile</font>, 
  принимающую к примеру 4 параметра. </p>
<p>Естественно, приведенный выше макрос может быть реализован и обычным образом 
  (не как поглощающий). В этом случае его вызов должен выглядеть так: </p>

<pre><font color="#666666">          writefile [filehandle], {"Привет, фуфел!",13,10}</font></pre>
<p>NASM поддерживает оба механизма помещения запятых в параметры макроса и вам 
  самим выбирать, какой предпочтительнее в каждом конкретном случае. </p>
<p>В <a href="nasm_ru5.html#section-5.2.1">параграфе 5.2.1</a> приведен более &quot;продвинутый&quot; 
  способ написания рассмотренного макроса</p>

<h4><a name="section-4.2.4">4.2.4 Параметры макросов по умолчанию</a></h4>
<p>NASM позволяет также определять многострочный макрос с указанием диапазона 
  допустимого количества параметров. Если вы используете эту возможность, то можете 
  задать значения по умолчанию для пропускаемых параметров. Например: </p>
<pre><font color="#666666">%macro die 0-1 "Полный кабздец твоей проге, фуфел!" 
          writefile 2,%1 
          mov ax,0x4c01 
          int 0x21 
%endmacro</font>
</pre>
<p>Данный макрос (использующий макрос <font color="#000099">writefile</font>, 
  описанный в <a href="#section-4.2.3">параграфе 4.2.3</a>) может быть вызван 
  как с явно указанным сообщением об ошибке, помещаемым в выходной поток перед 
  закрытием, так и без параметров. В последнем случае в качестве параметра будет 
  подставлено сообщение по умолчанию, введенное при определении макроса. </p>
<p>Обычно для макроса данного типа вы задаете минимальное и максимальное число 
  параметров; минимальное число &#151; это параметры, требующиеся при вызове макроса, 
  а для остальных вы задаете значения по умолчанию. Так, если определение макроса 
  начинается со строки </p>

<pre><font color="#666666">%macro foobar 1-3 eax,[ebx+2]</font></pre>
<p>то он может быть вызван с числом параметров от одного до трех; при этом параметр 
  <font color="#000099">%1</font> всегда берется из строки вызова макроса, параметр 
  <font color="#000099">%2</font> (если не задан) примет значение <font color="#000099">eax</font>, 
  а параметр <font color="#000099">%3</font> (если не задан) &#151; значение <font color="#000099">[ebx+2]</font>. 
</p>
<p>Вы не обязаны задавать значения по умолчанию при определении макроса &#151; 
  в этом случае они будут пустые. Это может быть полезно для макросов, принимающих 
  различное число параметров, так как число реально передаваемых параметров вы 
  можете указать при помощи конструкции <font color="#000099">%0</font> (см. <a href="#section-4.2.5">параграф 
  4.2.5</a> ниже). </p>
<p>Механизм параметров по умолчанию может комбинироваться с механизмом поглощающих 
  параметров; например, описанный выше макрос <font color="#000099">die</font> 
  может быть сделан более продвинутым и полезным путем изменения первой строки 
  определения: </p>

<pre><font color="#666666">%macro die 0-1+ "Полный кабздец твоей проге, фуфел!",13,10</font></pre>
<p>Максимальное число параметров может быть неограниченным, что обозначается как 
  <font color="#000099">*</font>. В этом случае, конечно невозможно предусмотреть 
  полный набор параметров по умолчанию. Примеры такого типа макросов см. в <a href="#section-4.2.6">параграфе 
  4.2.6</a>. </p>
<h4><a name="section-4.2.5">4.2.5 <font color="#000099">%0</font>: Счетчик макро-параметров</a></h4>
<p>Параметр <font color="#000099">%0</font> возвращает числовую константу, представляющую 
  собой количество передаваемых в макрос параметров. Он может использоваться как 
  аргумент для <font color="#000099">%rep</font> (см. <a href="#section-4.4">параграф 
  4.4</a>) с целью перебора всех параметров макроса. Примеры см. в <a href="#section-4.2.6">параграфе 
  4.2.6</a> ниже. 
<h4><a name="section-4.2.6">4.2.6 <font color="#000099">%rotate</font>: "Вращение" 
  параметров макросов</a></h4>
<p>Unix-программисты знакомы с командой <font color="#000099">shift</font> оболочки, 
  позволяющей "сдвигать" переданные шелл-скриптом аргументы (<font color="#000099">$1, 
  $2</font> и т.д.) так, что аргумент, имевший до этого ссылку <font color="#000099">$2</font>, 
  получает ссылку <font color="#000099">$1</font>, а имевший ссылку <font color="#000099">$1</font>, 
  становится недоступен. </p>
<p>NASM обеспечивает подобный механизм при помощи <font color="#000099">%rotate</font>. 
  Как видно по имени, эта команда отличается от команды Unix тем, что параметры 
  не теряются: "выталкиваемые" с левого конца списка аргументов, они появляются 
  на правом, и наоборот. </p>
<p><font  color="#000099">%rotate</font> вызывается с одним числовым аргументом 
  (который может быть выражением). Параметры макроса "вращаются" влево на количество 
  мест, указанных аргументом. Если аргумент отрицателен, параметры вращаются вправо.</p>
<p>Например, пара макросов для сохранения и восстановления набора регистров может 
  работать так: </p>

<pre><font color="#666666">%macro multipush 1-* 
%rep %0 
          push %1 
%rotate 1 
%endrep 
%endmacro</font>
</pre>
<p>Этот макрос вызывает инструкцию <font color="#000099">PUSH</font> для каждого 
  аргумента, слева-направо. Начинается это дело с сохранения первого аргумента, 
  <font color="#000099">%1</font>, затем вызывается <font color="#000099">%rotate</font> 
  для перемещения всех аргументов на один шаг влево, так что изначально второй 
  аргумент становится доступен как <font color="#000099">%1</font>. Повторение 
  данной процедуры для всего набора аргументов (достигается это передачей <font color="#000099">%0</font> 
  как аргумента для <font color="#000099">%rep</font>) позволяет сохранить каждый 
  из них. </p>
<p>Обратите внимание на использование звездочки (<font color="#000099">*</font>) 
  в качестве максимального числа параметров. Это означает, что число передаваемых 
  макросу <font color="#000099">multipush</font> параметров не ограничено. </p>
<p>Удобно иметь под рукой и обратный макрос, извлекающий регистры из стека, особенно 
  если он не требует передавать ему аргументы в обратном порядке относительно 
  <font color="#000099">PUSH</font>. В идеале вы будете помещать в текст программы 
  вызов макроса <font color="#000099">multipush</font>, затем копировать эту строку, 
  вставлять ее туда, где требуется извлечение из стека и заменять имя вызываемого 
  макроса на <font color="#000099">multipop</font>. И этот макрос будет извлекать 
  регистры со стека в порядке, обратном тому, в каком их туда поместили. </p>
<p>Все это может быть реализовано при помощи следующего определения: </p>

<pre><font color="#666666">%macro multipop 1-* 
%rep %0 
%rotate -1 
          pop %1 
%endrep 
%endmacro</font>
</pre>
Данный макрос начинает работу с поворота своих аргументов <i>вправо</i>, поэтому 
исходный <i>последний</i> аргумент становится аргументом <font color="#000099">%1</font>. 
Затем этот аргумент извлекается из стека, список аргументов снова поворачивается 
вправо и теперь аргументом <font color="#000099">%1</font> становится аргумент, 
бывший в начале предпоследним. Таким образом, аргументы извлекаются из стека в 
обратном порядке. 
<h4><a name="section-4.2.7">4.2.7 Объединение параметров макросов</a></h4>
<p>NASM может объединять параметры макросов с окружающим их текстом. Это позволяет 
  при определении макроса объявлять, например семейства символов. Если вы, например, 
  захотите создать таблицу кодов клавиш вместе со смещениями в этой таблице, вы 
  можете написать: </p>

<pre><font color="#666666">%macro keytab_entry 2 
keypos%1 equ $-keytab 
          db %2 
%endmacro 
keytab: 
          keytab_entry F1,128+1 
          keytab_entry F2,128+2 
          keytab_entry Return,13</font>
</pre>
<p>Это будет развернуто следующим образом: </p>

<pre><font color="#666666">keytab: 
keyposF1 equ $-keytab 
          db 128+1 
keyposF2 equ $-keytab 
          db 128+2 
keyposReturn equ $-keytab 
          db 13</font>
</pre>
<p>Точно также можно присоединять текст к другому концу параметра, написав <font color="#000099">%1foo</font>. 
</p>
<p>Если вам требуется присоединить к параметру макроса <i>цифру</i>, например 
  для определения меток <font color="#000099">foo1</font> и <font color="#000099">foo2</font> 
  при передаче параметра <font color="#000099">foo</font>, вы не можете написать 
  <font color="#000099">%11</font>, так как это будет воспринято как одиннадцатый 
  параметр макроса. Вместо этого вы должны написать <font color="#000099">%{1}1</font>, 
  где первая единица (определяющая номер параметра макроса) будет отделена от 
  второй (представляющей собой присоединяемый к параметру текст). </p>
<p>Объединение может быть применено и к другим встраиваемым объектам препроцессора, 
  таким как локальные метки макросов (<a href="#section-4.2.2">параграф 4.2.2</a>) 
  и контекстно-локальные метки (<a href="#section-4.6.2">параграф 4.6.2</a>). 
  В любом случае, неопределенность синтаксиса может быть разрешена путем заключения 
  всего, находящегося после знака <font color="#000099">%</font> и перед присоединяемым 
  текстом, в фигурные скобки: <font color="#000099">%{%foo}bar</font> прицепит 
  текст <font color="#000099">bar</font> к действительному имени локальной метки 
  <font color="#000099">%%foo</font>. (Это вообще-то излишне, так как форма, используемая 
  NASM для генерации реальных имен локальных макро-меток подразумевает, что и 
  <font color="#000099">%{%foo}bar</font>, и <font color="#000099">%%foobar</font> 
  будут развернуты в одно и то же, однако возможность существует). </p>

<h4><a name="section-4.2.8">4.2.8 </a>Коды условий в качестве параметров макросов</h4>
<p>NASM может особым образом обрабатывать параметры макросов, содержащие коды 
  условий. Во первых, вы можете ссылаться на макро-параметр <font color="#000099">%1</font> 
  при помощи альтернативного синтаксиса <font color="#000099">%+1</font>, информирующего 
  NASM о том, что этот параметр содержит код условия и заставляющего препроцессор 
  сообщать об ошибке, если макрос вызывается с параметром, <i>не являющимся</i> 
  действительным кодом условия. </p>
<p>Однако более полезной возможностью является ссылка на макро-параметр вида <font color="#000099">%-1</font>, 
  которую NASM будет разворачивать как обратный код условия. Так, макрос <font color="#000099">retz</font>, 
  описанный в <a href="#section-4.2.2">параграфе 4.2.2</a>, может быть заменен 
  макросом условного возврата более общего вида: </p>

<pre><font color="#666666">%macro retc 1 
          j%-1 %%skip 
          ret 
%%skip: 
%endmacro</font>
</pre>
<p>Данный макрос может быть теперь вызван как <font color="#000099">retc ne</font>, 
  что будет развернуто в инструкцию условного перехода <font color="#000099">JE</font>, 
  или как <font color="#000099">retc po</font>, что будет преобразовано в переход 
  <font color="#000099">JPE</font>. </p>
<p>Ссылка <font color="#000099">%+1</font> на макро-параметр может вполне спокойно 
  интерпретировать аргументы <font color="#000099">CXZ</font> и <font color="#000099">ECXZ</font> 
  как правильные коды условий; однако если передать эту лабуду ссылке <font color="#000099">%-1</font>, 
  будет сообщено об ошибке, так как обратных кодов условий к таким параметрам 
  не существует. </p>
<h4><a name="section-4.2.9">4.2.9 Подавление развертывания макросов в листинге</a></h4>
<p>Когда NASM генерирует из программы файл листинга, он обычно разворачивает многострочные 
  макросы посредством записи макро-вызова и последующим перечислением каждой строки, 
  полученной в результате развертывания. Это позволяет увидеть, как генерируются 
  инструкции из макроса в реальный код; однако для некоторых макросов данное загромождение 
  листинга не требуется. </p>
<p>NASM предусматривает для этой цели спецификатор <font color="#000099">.nolist</font>, 
  который вы можете включить в определение макроса с целью подавления развертывания 
  макроса в файле листинга. Спецификатор <font color="#000099">.nolist</font> 
  ставится сразу после количества параметров, например так: </p>

<pre><font color="#666666">%macro foo 1.nolist</font></pre>
<p>Или так: </p>
<pre><font color="#666666">%macro bar 1-5+.nolist a,b,c,d,e,f,g,h</font></pre>
<h3><a name="section-4.3">4.3 Условное ассемблирование</a></h3>
<p>Как и препроцессор языка С, NASM позволяет ассемблировать отдельные секции 
  исходного файла только тогда, когда выполняются определенные условия. Синтаксис 
  в общем виде выглядит следующим образом: </p>

<pre><font color="#666666">%if&lt;условие&gt; 
; некоторый код, ассемблируемый только при выполнении &lt;условия&gt;
%elif&lt;условие2&gt; 
; ассемблируется, если <условие> не выполняется, а выполняется <условие2> 
%else 
; ассемблируется, если и <условие>, и <условие2> не выполняются 
%endif</font>
</pre>
<p>Оператор <font color="#000099">%else</font> необязателен, так же как и оператор 
  <font color="#000099">%elif</font>. Если нужно, вы можете использовать более 
  одного оператора <font color="#000099">%elif</font>. </p>
<h4><a name="section-4.3.1">4.3.1 <font color="#000099">%ifdef</font>: Проверка 
  присутствия однострочного макроса</a></h4>
<p>Начинающийся со строки <font color="#000099">%ifdef MACRO</font> условно-ассемблируемый 
  блок будет обрабатываться <i>только</i> в том случае, если определен однострочный 
  макрос <font color="#000099">MACRO</font>. Если он не определен, вместо этого 
  будут обрабатываться блоки <font color="#000099">%elif</font> и <font color="#000099">%else</font> 
  (если они есть). </p>
<p>Например, для отладки программы вы можете захотеть ввести следующий код: </p>

<pre><font color="#666666">          ; выполнение некоторой функции 
%ifdef DEBUG 
          writefile 2,"Функция выполнена полностью.",13,10 
%endif 
          ; выполнение чего-нибудь еще</font>
</pre>
<p>После этого вы можете использовать ключ <font color="#000099">-dDEBUG</font> 
  командной строки для создания версии программы, выдающей отладочные сообщения, 
  а удалив этот ключ &#151; создавать окончательный релиз. </p>
<p>Для осуществления обратной проверки (отсутствия определения макроса) вы можете 
  использовать вместо <font color="#000099">%ifdef</font> оператор <font color="#000099">%ifndef</font>. 
  Вы можете также тестировать наличие определения макроса в блоках <font color="#000099">%elif</font> 
  при помощи операторов <font color="#000099">%elifdef</font> и <font color="#000099">%elifndef</font>. 
</p>
<h4><a name="section-4.3.2">4.3.2 <font color="#000099">%ifctx</font>: Проверка 
  контекстного стека</a></h4>
<p>Конструкция условного ассемблирования <font color="#000099">%ifctx ctxname</font> 
  предполагает обработку идущего вслед за ней кода только тогда, когда на вершине 
  контекстного стека препроцессора находится имя <font color="#000099">ctxname</font>. 
  Как и в случае с <font color="#000099">%ifdef</font>, поддерживаются также формы 
  <font color="#000099">%ifnctx,%elifctx</font> и <font color="#000099">%elifnctx</font>. 
</p>
<p>Более подробно о контекстном стеке можно узнать в <a href="#section-4.6">параграфе 
  4.6</a>. а пример использования <font color="#000099">%ifctx</font> приведен 
  в <a href="#section-4.6.5">параграфе 4.6.5</a>.</p>
<h4><a name="section-4.3.3">4.3.3 <font color="#000099">%if</font>: Проверка произвольных 
  числовых выражений</a></h4>
<p>Конструкция условного ассемблирования <font color="#000099">%if expr</font> 
  будет вызывать обработку последующего кода <i>только</i> в том случае, если 
  выражение <font color="#000099">expr</font> не нулевое. Примером использования 
  данной конструкции может служить проверка выхода из препроцессорного цикла <font color="#000099">%rep</font>: 
  пример смотрите в <a href="#section-4.4">параграфе 4.4</a>. </p>
<p>Выражения, указываемые для <font color="#000099">%if</font>, а также его эквивалента 
  <font color="#000099">%elif</font>, являются критическими (см. <a href="nasm_ru3.html#section-3.7">параграф 
  3.7</a>). </p>
<p><font  color="#000099">%if</font> расширяет обычный синтаксис выражений NASM, 
  предусматривая набор операторов отношения, которые в выражениях обычно запрещены. 
  Операторы <font color="#000099">=, <, >, <=, >=</font> и <font color="#000099"><></font> 
  проверяют на равенство, отношения "меньше чем", "больше чем", "меньше или равно", 
  "больше или равно" и на неравенство соответственно. С-подобные формы <font color="#000099">==</font> 
  и <font color="#000099">!=</font> также поддерживаются и являются альтернативными 
  формами <font color="#000099">=</font> и <font color="#000099"><></font>. И 
  наконец, имеются операторы низкого приоритета <font color="#000099">&&, ^^</font> 
  и <font color="#000099">||</font>, производящие логические операции <font color="#000099">И, 
  ИСКЛЮЧАЮЩЕЕ ИЛИ</font> и <font color="#000099">ИЛИ</font>. Они работают также, 
  как логические операторы в С (за исключением того, что в С нет логического &quot;ИСКЛЮЧАЮЩЕЕ 
  ИЛИ&quot;), то есть возвращают всегда 0 или 1 и обрабатывают любое ненулевое 
  значение как 1 (например, <font color="#000099">^^</font> возвращает 1 только 
  если одно из его входных значений нулевое, а второе &#151; ненулевое). Операторы 
  отношения также возвращают 1 если условие истинно и 0 &#151; если ложно. </p>
<h4><a name="section-4.3.4">4.3.4 <font color="#000099">%ifidn</font> и <font color="#000099">%ifidni</font>: 
  </a>Проверка на идентичность текста</h4>
<p>Конструкция <font color="#000099">%ifidn text1,text2</font> будет вызывать 
  ассемблирование последующего кода <i>только</i> в том случае, если текст аргументов 
  <font color="#000099">text1</font> и <font color="#000099">text2</font> после 
  развертывания однострочных макросов становится идентичным. Отличия в виде пробелов 
  не считаются. </p>
<p><font  color="#000099">%ifidni</font> подобна <font color="#000099">%ifidn</font>, 
  но нечувствительна к регистру символов. </p>
<p>Например, следующий макрос помещает регистр или число в стек, позволяя при 
  этом обрабатывать <font color="#000099">IP</font> как реальный регистр: </p>

<pre><font color="#666666">%macro pushparam 1 
%ifidni %1,ip 
          call %%label 
%%label: 
%else 
          push %1 
%endif 
%endmacro</font>
</pre>
<p>Как и большинство других <font color="#000099">%if</font>-конструкций, <font color="#000099">%ifidn</font> 
  имеет эквивалент <font color="#000099">%elifidn</font> и обратные формы <font color="#000099">%ifnidn</font> 
  и <font color="#000099">%elifnidn</font>. Соответственно, <font color="#000099">%ifidni</font> 
  имеет эквивалент <font color="#000099">%elifidni</font> и обратные формы <font color="#000099">%ifnidni</font> 
  и <font color="#000099">%elifnidni</font>. </p>
<h4><a name="section-4.3.5">4.3.5 <font color="#000099">%ifid, %ifnum, %ifstr</font>: 
  Проверка типов символов</a></h4>
<p>Иногда вам может понадобиться, чтобы макросы выполняли различные задачи в зависимости 
  от того, что им передано в качестве аргумента: число, строка или идентификатор. 
  Например, может быть необходимо чтобы макрос смог обрабатывать как строковые 
  константы, так и указатели на уже существующие строки. </p>

<p>Конструкция условного ассемблирования <font color="#000099">%ifid</font>, принимающая 
  один параметр (который может быть пустым), обрабатывает последующий код <i>только</i> 
  в том случае, если первый символ в параметре существует и является идентификатором. 
  <font color="#000099">%ifnum</font> работает аналогично, но проверяет символ 
  на соответствие числовой константе; <font color="#000099">%ifstr</font> тестирует 
  на соответствие символа строке. </p>
<p>Например, описанный в <a href="#section-4.2.3">параграфе 4.2.3</a> макрос <font color="#000099">writefile</font> 
  может быть расширен для использования преимуществ конструкции <font color="#000099">%ifstr</font> 
  следующим образом: </p>

<pre><font color="#666666">%macro writefile 2-3+ 
%ifstr %2 
          jmp %%endstr 
%if %0 = 3 
%%str:	  db %2,%3 
%else 
%%str:	  db %2 
%endif 
%%endstr: mov dx,%%str 
          mov cx,%%endstr-%%str 
%else 
	  mov dx,%2 
	  mov cx,%3 
%endif 
          mov bx,%1 
          mov ah,0x40 
          int 0x21 
%endmacro</font>
</pre>
<p>После этого макрос <font color="#000099">writefile</font> может "справиться" 
  со следующими двумя своими вызовами: </p>

<pre><font color="#666666">          writefile [file], strpointer, length 
          writefile [file], "Привет!", 13, 10</font>
</pre>
<p>В первом случае <font color="#000099">strpointer</font> используется в качестве 
  адреса уже объявленной строки, а <font color="#000099">length</font> &#151; 
  как длина этой строки. Во втором случае макросу передается строка, которую макрос 
  объявляет и получает ее адрес и длину самостоятельно. </p>
<p>Обратите внимание на использование <font color="#000099">%if</font> внутри 
  <font color="#000099">%ifstr</font>: это нужно для определения того, передано 
  ли макросу 2 аргумента (в этом случае строка &#151; просто константа и ей достаточно 
  <font color="#000099">db %2</font>) или больше (в этом случае все аргументы 
  кроме первых двух объединяются в <font color="#000099">%3</font> и тогда уже 
  требуется <font color="#000099">db %2,%3</font>). </p>
<p>Для всех трех конструкций <font color="#000099">%ifid</font>, <font color="#000099">%ifnum</font> 
  и <font color="#000099">%ifstr</font> существуют соответствующие версии <font color="#000099">%elifXXX, 
  %ifnXXX</font> и <font color="#000099">%elifnXXX</font>. </p>
<h4><a name="section-4.3.6">4.3.6 <font color="#000099">%error</font>: </a>Сообщения 
  об ошибках, определяемых пользователем</h4>
<p>Директива препроцессора <font color="#000099">%error</font> заставляет NASM 
  сообщать об ошибках, случающихся на стадии ассемблирования. Так, если ваши исходники 
  будет ассемблировать кто-то еще, вы можете проверить, определен ли нужный макрос 
  при помощи следующего кода: </p>

<pre><font color="#666666">%ifdef SOME_MACRO 
; производятся некоторые настройки 
%elifdef SOME_OTHER_MACRO 
; производятся другие настройки 
%else 
%error Не определены ни SOME_MACRO, ни SOME_OTHER_MACRO. 
%endif</font>
</pre>
<p>Таким образом любой пользователь, не знающий, как правильно ассемблировать 
  ваш код, будет быстро предупрежден об этом несоответствии, вместо того, чтобы 
  увидеть крах программы при ее выполнении и не знать, что этот крах вызвало. 
</p>
<h3><a name="section-4.4">4.4 Препроцессорные циклы: %rep</a></h3>
<p>Несмотря на то,что префикс <font color="#000099">TIMES</font> в NASM весьма 
  удобен, он не может быть использован в многострочных макросах, потому как обрабатывается 
  уже после полного разворачивания последних. Вследствие этого, NASM предусматривает 
  другую форму циклов, работающих на уровне препроцессора, а именно <font color="#000099">%rep</font>. 
</p>
<p>Директивы <font color="#000099">%rep</font> и <font color="#000099">%endrep</font> 
  (<font color="#000099">%rep</font> принимает числовой аргумент или выражение; 
  <font color="#000099">%endrep</font> не принимает никаких аргументов) используются 
  для заключения в них куска кода, который при этом реплицируется столько раз, 
  сколько указано препроцессору: </p>

<pre><font color="#666666">%assign i 0 
%rep 64 
          inc word [table+2*i] 
%assign i i+1 
%endrep</font>
</pre>
<p>Этот пример будет генерировать 64 инструкции <font color="#000099">INC</font>; 
  инкрементируя каждое слово в памяти от <font color="#000099">[table]</font> 
  до <font color="#000099">[table+126]</font>. </p>
<p>Для образования более сложных условий окончания цикла или его принудительного 
  завершения вы можете использовать директиву <font color="#000099">%exitrep</font>, 
  например: </p>

<pre><font color="#666666">fibonacci: 
%assign i 0 
%assign j 1 
%rep 100 
%if j &gt; 65535 
%exitrep 
%endif 
          dw j 
%assign k j+i 
%assign i j 
%assign j k 
%endrep 
fib_number equ ($-fibonacci)/2</font>
</pre>
<p>Этот пример создает список всех чисел Фибоначчи, вписывающихся в размер 16 
  бит. Заметьте, что и в этом случае для <font color="#000099">%rep</font> должно 
  быть указано максимальное число повторов. Это необходимо для того, чтобы NASM 
  на стадии препроцессирования не впал в бесконечный цикл, что (в многозадачных 
  или многопользовательских системах) приводит обычно к быстрому исчерпанию памяти 
  и невозможности запуска других приложений. </p>
<h3><a name="section-4.5">4.5 Подключение других файлов</a></h3>
<p>Препроцессор NASMа, используя очень похожий на С синтаксис, позволяет подключать 
  к текщему исходнику другие файлы. Это осуществляется при помощи директивы <font color="#000099">%include</font>: 
</p>

<pre><font color="#666666">%include "macros.mac"</font></pre>
<p>Эта строка включит файл <font color="#000099">macros.mac</font> в исходный 
  файл, содержащий директиву <font color="#000099">%include</font>. </p>
<p>Поиск подключаемых файлов производится в текущем каталоге (каталоге, из которого 
  запускается NASM, а не того, где содержатся его исполнимые файлы или где находится 
  исходный файл) и в любых других каталогах, указанных в командной строке NASM 
  при помощи ключа <font color="#000099">-i</font>. </p>
<p>Стандартная идиома С, предотвращающая многократное включение одного и того 
  же файла, точно также срабатывает и в NASM: если файл <font color="#000099">macros.mac</font> 
  имеет форму </p>
<pre><font color="#666666">%ifndef MACROS_MAC 
%define MACROS_MAC 
; какие-то определения и объявления 
%endif</font>
</pre>
<p>то многократное его включение не будет вызывать ошибок, так как после первого 
  включения символ <font color="#000099">MACROS_MAC</font> будет уже определен. 
</p>
<p>При помощи ключа командной строки <font color="#000099">-p</font> (см. <a href="nasm_ru2.html#section-2.1.7">параграф 
  2.1.7</a>) вы можете подключить файл даже не используя явным образом директиву 
  <font color="#000099">%include</font> в файле-потребителе.</p>
<h3><a name="section-4.6">4.6 </a>Контекстный стек</h3>
<p>Локальные по отношению к макроопределению метки иногда не обеспечивают необходимую 
  гибкость: вполне возможно, что иногда вы захотите разделить метки между несколькими 
  макровызовами. Примером может служить цикл <font color="#000099">REPEAT ... 
  UNTIL</font>, в котором расширению макроса <font color="#000099">REPEAT</font> 
  может понадобиться ссылаться на метки, определенные в макросе <font color="#000099">UNTIL</font>. 
  Ситуация еще более усложнится, когда вы захотите сделать эти циклы вложенными.</p>
<p>NASM обеспечивает данный уровень гибкости при помощи контекстного стека. Препроцессор 
  поддерживает стек контекстов, каждый из которых характеризуется именем. Добавление 
  нового контекста в стек осуществляется директивой <font color="#000099">%push</font>, 
  а извлечение из стека &#151; директивой <font color="#000099">%pop</font>. Вы 
  можете определять метки, являющиеся локальными по отношению к определенному 
  контексту в стеке. </p>
<h4><a name="section-4.6.1">4.6.1 <font color="#000099">%push</font> и <font color="#000099">%pop</font>: 
  Создание и удаление контекста</a></h4>
<p>Директива <font color="#000099">%push</font> используется для создания нового 
  контекста и помещения его на вершину контекстного стека. Эта директива требует 
  указания одного аргумента, а именно имени контекста. Например: </p>
<pre><font color="#666666">%push foobar</font></pre>
<p>Эта команда помещает в стек новый контекст <font color="#000099">foobar</font>. 
  Вы можете иметь в стеке несколько контекстов с одним и тем же именем: они все 
  равно будут отличаться друг от друга. </p>
<p>Директива <font color="#000099">%pop</font>, не требующая аргументов, удалает 
  самый верхний контекст из стека и разрушает его вместе с любыми связанными с 
  ним метками. </p>

<h4><a name="section-4.6.2">4.6.2 Контектно-локальные метки</a></h4>
<p>Точно так же, как использование <font color="#000099">%%foo</font> вводит локальную 
  по отношению к определенному макросу метку, конструкция <font color="#000099">%$foo</font> 
  используется для определения метки, локальной по отношению к контексту на вершине 
  контекстного стека. Таким образом, пример с циклом <font color="#0000CC">REPEAT 
  √ UNTIL</font> может быть реализован следующим образом: </p>
<pre><font color="#666666">%macro repeat 0 
%push repeat 
%$begin: 
%endmacro

%macro until 1 
          j%-1 %$begin 
%pop 
%endmacro</font>
</pre>
<p>Вызовы могут производиться, например, так:</p>
<pre><font color="#666666">          mov cx,string 
          repeat 
          add cx,3 
          scasb 
          until e</font>
</pre>
<p>В этом примере будет сканироваться каждый четвертый байт строки с целью поиска 
  байта, равного <font color="#000099">AL</font>. <i><font color="#FF0066">(Прим.перев. 
  Скорее всего, в примере ошибка)</font></i>. </p>
<p>Если вам требуется определить или получить доступ к меткам, локальным к контексту, 
  находящемуся <i>ниже</i> вершины стека, вы можете использовать <font color="#000099">%$$foo</font>, 
  или <font color="#000099">%$$$foo</font> для еще более "глубокого" контекста 
  и т.д. </p>

<h4><a name="section-4.6.3">4.6.3 Контекстно-локальные однострочные макросы</a></h4>
<p>NASM позволяет определять однострочные макросы, локальные по отношению к определенному 
  контексту. Например, </p>
<pre><font color="#666666">%define %$localmac 3</font></pre>
<p>будет определять однострочный макрос <font color="#000099">%$localmac</font>, 
  локальный к контексту на вершине стека. Само собой, после создания еще одного 
  контекста директивой <font color="#000099">%push</font>, данный макрос может 
  быть доступен по имени <font color="#000099">%$$localmac</font>. </p>
<h4><a name="section-4.6.4">4.6.4 <font color="#000099">%repl</font>: </a>Переименование 
  контекста</h4>
<p>Если вам требуется изменить имя контекста, находящегося на вершине стека , 
  вы можете выполнить <font color="#000099">%pop</font> с последующим <font color="#000099">%push</font>; 
  однако это будет иметь "побочный" эффект в виде разрушения всех локальных по 
  отношению к извлеваемому контексту меток и макросов. </p>
<p>В NASM для этой цели предусмотрена директива <font color="#000099">%repl</font>, 
  <i>изменяющая</i> имя контекста без затрагивания связанных с этим контекстом 
  локальных меток и макросов. Теперь вы можете заменить деструктивный код </p>
<pre><font color="#666666">%pop 
%push newname</font>
</pre>
<p>на недеструктивную версию <font color="#000099">%repl newname</font>. </p>
<h4><a name="section-4.6.5">4.6.5 Пример использования контекстного стека: Блок 
  IF</a></h4>
<p>В данном примере для реализации блока <font color="#000099">IF</font> как набора 
  макросов использованы почти все возможности контекстного стека, включая конструкцию 
  условного ассемблирования <font color="#000099">%ifctx</font>. </p>
<pre><font color="#666666">%macro if 1 
    %push if 
    j%-1 %$ifnot 
%endmacro

</font><font color="#666666">%macro else 0 
    %ifctx if 
        %repl else 
        jmp %$ifend 
        %$ifnot: 
    %else 
        %error "Перед 'else' ожидается 'if' !" 
    %endif 
%endmacro

</font><font color="#666666">%macro endif 0 
    %ifctx if 
        %$ifnot: 
        %pop 
    %elifctx else 
        %$ifend: 
        %pop 
    %else 
        %error "Перед 'endif' ожидается 'if' или 'else'!" 
    %endif 
%endmacro</font>
</pre>
<p>Данный код более устойчив, чем макросы <font color="#000099">REPEAT</font> 
  и <font color="#000099">UNTIL</font> из <a href="#section-4.6.2">параграфа 4.6.2</a>, 
  так как он использует условное ассемблирование для проверки правильного порядка 
  следования макросов (например, нельзя перед <font color="#000099">if</font> 
  вызвать <font color="#000099">endif</font>) и привлекает директиву <font color="#000099">%error</font>, 
  если порядок нарушен. </p>
<p>Кроме того, макрос <font color="#000099">endif</font> способен справиться сразу 
  с двумя разными условиями: следует ли он сразу за <font color="#000099">if</font> 
  или за <font color="#000099">else</font>. Достигается это опять же за счет условного 
  ассемблирования, при котором производятся разные действия в зависимости от того, 
  что на вершине стека &#151; <font color="#000099">if</font> или <font color="#000099">else</font>. 
</p>
<p>&nbsp;</p>
<p>Макрос <font color="#000099">else</font> должен сохранить контекст в стеке, 
  чтобы метка <font color="#000099">%$ifnot</font>, на которую ссылается <font color="#000099">if</font> 
  была той же самой, что и определенная в макросе <font color="#000099">endif</font>, 
  но в то же время он должен изменить имя контекста, чтобы <font color="#000099">endif</font> 
  знал, что тут поработал <font color="#000099">else</font>. Он делает это при 
  помощи <font color="#000099">%repl</font>. </p>
<p>Пример использования макроса выглядит следующим образом: </p>
<pre><font color="#666666">          cmp ax,bx 
          if ae 
            cmp bx,cx 
            if ae 
              mov ax,cx 
            else 
              mov ax,bx 
            endif 
          else 
            cmp ax,cx 
            if ae 
              mov ax,cx 
            endif 
          endif</font>
</pre>
<p>Макросы блока <font color="#000099">IF</font> совершенно спокойно обрабатывают 
  вложенность посредством сохранения контекста, вводимого внутри <font color="#000099">if</font> 
  поверх контекста, описанного извне <font color="#000099">if</font>; таким образом 
  <font color="#000099">else</font> и <font color="#000099">endif</font> всегда 
  ссылаются на последние <font color="#000099">if</font> или <font color="#000099">else</font>, 
  не имеющие на этот момент пары. </p>
<h3><a name="section-4.7">4.7 </a>Стандартные макросы</h3>
<p>NASM вводит набор стандартных макросов, которые на момент начала обработки 
  любого исходного файла будут уже определены. Если вам позарез нужно, чтобы программа 
  ассемблировалась без предопределенных макросов, можете для очистки препроцессорного 
  пространства имен использовать директиву <font color="#000099">%clear</font>. 
</p>
<p>Большинство пользовательских директив ассемблера реализованы как макросы, вызывающие 
  примитивные директивы; все они описываются в <a href="nasm_ru5.html">главе 5</a>. 
  Оставшийся набор стандартных макросов описан ниже. </p>
<h4><a name="section-4.7.1">4.7.1 <font color="#000099">__NASM_MAJOR__</font> 
  и <font color="#000099">__NASM_MINOR__</font>: Версия NASM</a></h4>
<p>Однострочные макросы <font color="#000099">__NASM_MAJOR__</font> и <font color="#000099">__NASM_MINOR__</font> 
  разворачиваются соответственно в старшую и младшую части номера версии NASM. 
  Так, в NASM 0.96 <font color="#000099">__NASM_MAJOR__</font> будет определен 
  как 0, а <font color="#000099">__NASM_MINOR__</font> &#151; как 96. 
<h4><a name="section-4.7.2">4.7.2 <font color="#000099">__FILE__</font> и <font color="#000099">__LINE__</font>: 
  Имя файла и номер строки</a></h4>
<p>Как и в препроцессоре С, NASM позволяет пользователю узнать имя файла и номер 
  строки, содержащие текущую инструкцию. Макрос<font color="#000099"> __FILE__</font> 
  разворачивается в строковую константу, представляющую собой имя текущего входного 
  файла (которое в ходе ассемблирования может изменяться, если используется директива 
  <font color="#000099">%include</font>), а <font color="#000099">__LINE__</font> 
  разворачивается в числовую константу, означающую текущий номер строки во входном 
  файле. </p>
<p>Эти макросы могут быть использованы, например, для передачи макросу отладочной 
  информации, так как вызов <font color="#000099">__LINE__</font> внутри макроопределения 
  (неважно, одно- или многострочного) будет возвращать номер строки <i>макровызова</i>, 
  а не строки <i>определения</i>. Так, например, для определения в какой части 
  кода наступает крах, пишется подпрограммка <font color="#000099">stillhere</font>, 
  которой передается в <font color="#000099">EAX</font> номер строки, а на выходе 
  получается что-то вроде "<font color="#000099">строка 155: я еще жива</font>". 
  Затем вы пишете макрос </p>
<pre><font color="#666666">%macro notdeadyet 0 
          push eax 
          mov eax,__LINE__ 
          call stillhere 
          pop eax 
%endmacro</font>
</pre>
<p>и &quot;утыкаете&quot; ваш код вызовами <font color="#000099">notdeadyet</font> 
  до тех пор, пока не найдете точку краха. </p>
<h4><a name="section-4.7.3">4.7.3 <font color="#000099">STRUC</font> и <font color="#000099">ENDSTRUC</font>: 
  Объявление структурных типов данных</a></h4>
<p>Ядро NASM не содержит внутренних механизмов для определения структур данных; 
  вместо этого сделан довольно мощный препроцессор, который кроме всего прочего 
  способен реализовать структуры данных в виде набора макросов. Для определения 
  структур данных используются макросы <font color="#000099">STRUC</font> и <font color="#000099">ENDSTRUC</font>. 
</p>
<p><font  color="#000099">STRUC</font> принимает один параметр, являющийся именем 
  типа данных. Данное имя описывается как символ со значением 0, затем к нему 
  присоединяется суффикс <font color="#000099">_size</font> и оно определяется 
  как <font color="#000099">EQU</font> с размером структуры. После того, как <font color="#000099">STRUC</font> 
  выполнена, вы описываете структуру данных путем определения полей при помощи 
  семейства псевдо-инструкций <font color="#000099">RESB</font>. В конце описания 
  вы должны вызвать <font color="#000099">ENDSTRUC</font>. </p>
<p>Например, для определения структуры <font color="#000099">mytype</font>, содержащей 
  двойное слово, слово, байт и строку, вы можете написать: </p>
<pre><font color="#666666">          struc mytype 
mt_long:  resd 1 
mt_word:  resw 1 
mt_byte:  resb 1 
mt_str:   resb 32 
          endstruc</font>
</pre>
<p>Данный код определяет шесть символов: <font color="#000099">mt_long</font> 
  как <font color="#000099">0</font> (смещение от начала структуры <font color="#000099">mytype</font> 
  до поля с двойным словом), <font color="#000099">mt_word</font> как <font color="#0000CC">4</font>, 
  <font color="#000099">mt_byte</font> как <font color="#000099">6</font>, <font color="#000099">mt_str</font> 
  как <font color="#000099">7</font>, <font color="#000099">mytype_size</font> 
  как <font color="#000099">39</font> и собственно <font color="#000099">mytype</font> 
  как ноль. </p>
<p>Причиной, по которой имя структуры описывается как ноль, является побочный 
  эффект, позволяющий структурам работать с механизмом локальных меток: если члены 
  вашей структуры имеют метки с именами, совпадающими с именами меток других структур, 
  вы можете переписать приведенный выше код следующим образом: </p>
<pre><font color="#666666">          struc mytype 
.long:    resd 1 
.word:    resw 1 
.byte:    resb 1 
.str:     resb 32 
          endstruc</font>
</pre>
<p>Здесь описываются смещения к полям структуры в виде <font color="#000099">mytype.long</font>, 
  <font color="#000099">mytype.word</font>, <font color="#000099">mytype.byte</font> 
  и <font color="#000099">mytype.str</font>. </p>
<p>Так как NASM не имеет <i>встроенной</i> поддержки структур, он не поддерживает 
  формы нотации как в языке С с использованием точки для ссылки на элементы структуры 
  (за исключением нотации локальных меток), поэтому код наподобие <font color="#000099">mov 
  ax,[mystruc.mt_word]</font> будет ошибочным. Константа <font color="#000099">mt_word</font> 
  подобна любым другим константам, поэтому корректным синтаксисом в этом случае 
  будет <font color="#000099">mov ax,[mystruc+mt_word]</font> или <font color="#000099">mov 
  ax,[mystruc+mytype.word]</font>. </p>
<h4><a name="section-4.7.4">4.7.4 <font color="#000099">ISTRUC, AT</font> и<font color="#000099">IEND</font>: 
  Объявление экземпляров структур</a></h4>
<p>Имея определение структуры, вы вслед за этим обычно захотите объявить экземпляры 
  этой структуры в сегменте данных (иначе зачем она вообще нужна). NASM предусматривает 
  для этого простой способ с использованием механизма <font color="#000099">ISTRUC</font>. 
  Для объявления в программе структуры типа <font color="#000099">mytype</font> 
  вы должны написать следующий код: </p>
<pre><font color="#666666">mystruc:  istruc mytype 
          at mt_long, dd 123456 
          at mt_word, dw 1024 
          at mt_byte, db 'x' 
          at mt_str, db 'Привет, фуфел!', 13, 10, 0 
          iend</font>
</pre>
<p>Функцией макроса <font color="#000099">AT</font> является продвижение позиции 
  ассемблирования (при помощи префикса <font color="#000099">TIMES</font>) в корректную 
  точку заданного поля структуры и затем объявления указанных данных. Вследствие 
  этого, поля структуры должны объявляться в том же самом порядке, в каком они 
  следовали при определении. </p>
<p>Если данные, передаваемые в поле структуры, не помещаются на одной строке, 
  оставшаяся их часть может просто следовать за строкой с <font color="#000099">AT</font>. 
  Например: </p>
<pre><font color="#666666">          at mt_str, db 123,134,145,156,167,178,189 
          db 190,100,0</font>
</pre>
<p>В зависимости от личных предпочтений, вы можете также полностью пропустить 
  код на строке <font color="#000099">AT</font> и начать поле структуры со следующей 
  строки: </p>
<pre><font color="#666666">          at mt_str 
          db 'Привет, фуфел!' 
          db 13,10,0</font>
</pre>
<h4><a name="section-4.7.5">4.7.5 <font color="#000099">ALIGN</font> и <font color="#000099">ALIGNB</font>: 
  Выравнивание данных</a></h4>
<p>Макросы <font color="#000099">ALIGN</font> и <font color="#000099">ALIGNB</font> 
  предоставляют удобный способ выравнивания кода или данных по словам, двойным 
  словам, параграфам (16 байт) или другим границам. (В некоторых ассемблерах для 
  этой цели служит директива <font color="#000099">EVEN</font>). Синтаксис <font color="#000099">ALIGN</font> 
  и <font color="#000099">ALIGNB</font> следующий: </p>
<pre><font color="#666666">          align 4                ; выравнивание по 4-байтной границе 
          align 16               ; выравнивание по параграфам 
          align 8,db 0           ; заполнение 0 вместо NOP 
          align 4,resb 1         ; выравнивание 4 в BSS (неиниц. данные) 
          alignb 4               ; эквивалент предыдущей строки</font>
</pre>
<p>Оба макроса требуют, чтобы их первый аргумент был степенью двойки; они подсчитывают 
  число дополнительных байт, требуемых для подгонки длины текущей секции до соответствующей 
  границы (произведение со степенью двойки) и затем осуществляют выравнивание 
  путем применения к своему второму аргументу префикса <font color="#000099">TIMES</font>.</p>
<p>Если второй аргумент не задан, используется значение по умолчанию: <font color="#000099">NOP</font> 
  для <font color="#000099">ALIGN</font> и <font color="#000099">RESB 1</font> 
  для <font color="#000099">ALIGNB</font>. Если второй аргумент задан, оба макроса 
  становятся эквивалентными. Обычно вы должны использовать <font color="#000099">ALIGN</font> 
  в секциях кода и данных, а <font color="#000099">ALIGNB</font> &#151; в секции 
  BSS. Тогда никакого второго аргумента не понадобится (кроме, конечно, специальных 
  случаев). </p>
<p>Так как <font color="#000099">ALIGN</font> и <font color="#000099">ALIGNB</font> 
  являются простыми макросами, проверки ошибок в них нет: они не могут сообщить 
  вам о том, что переданный аргумент не является степенью двойки или что второй 
  аргумент генерирует более одного байта кода. В любом таком случае они будут 
  "молча делать плохие вещи". </p>
<p><font  color="#000099">ALIGNB</font> (или <font color="#000099">ALIGN</font> 
  со вторым аргументом <font color="#000099">RESB 1</font>) могут использоваться 
  при определении структур:</p>
<pre><font color="#666666">          struc mytype2 
mt_byte:  resb 1 
          alignb 2 
mt_word:  resw 1 
          alignb 4 
mt_long:  resd 1 
mt_str:   resb 32 
          endstruc</font>
</pre>
<p>Таким образом гарантируется, что члены структуры осмысленно выровнены относительно 
  ее базы. </p>
<p>И последнее замечание: <font color="#000099">ALIGN</font> и <font color="#000099">ALIGNB</font> 
  работают относительно начала секции, а не начала адресного пространства в конечном 
  исполнимом файле. Например, выравнивание по параграфам в секциях, гарантирующих 
  свое выравнивание только по двойным словам &#151; пустая трата времени. NASM 
  не в состоянии проверить, что характеристики выравнивания секции подходят для 
  использования <font color="#000099">ALIGN</font> или <font color="#000099">ALIGNB</font>. 
</p>
<p align=center><a href="nasm_ru5.html">Следующая глава </a> | <a href="nasm_ru3.html">Предыдущая 
  глава</a> | <a href="contents.html">Содержание</a> | Указатель
<hr noshade size=1>
<b><a href="http://www.opennet.ru/docs/">Архив документации на OpenNet.ru</a>
</body></html>
