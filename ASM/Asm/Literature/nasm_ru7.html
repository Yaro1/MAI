<html><head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r"><title>Руководство по NASM</title>

<META NAME="GENERATOR" CONTENT="Super-Puper-Mega-Proga"></head>
<body bgcolor="#DDE1C2"><b><a href="http://www.opennet.ru/docs/">Архив документации OpenNet.ru</a> / 
Раздел "<a href="http://www.opennet.ru/docs/124.shtml">Программирование, языки</a>" /
<a href="index.html">Индекс</a>
</b>
<hr noshade size=1>

<h1 align=center>Расширенный ассемблер: NASM</h1>

<p align=center><a href="nasm_ru8.html">Следующая глава</a> | <a href="nasm_ru6.html">Предыдущая 
  глава </a> | <a href="contents.html">Содержание</a> | Указатель</p>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr> 
    <td width="71%"> 
      <h2><a name="chapter-7">Глава 7: Написание 16-битного кода (DOS, 
        Windows 3/3.1)</a></h2>
    </td>
    <td width="29%"> 
      <div align="right"><font size="-1" color="#666666">Перевод: <a href="http://asmdev.narod.ru/asmos.html">AsmOS 
        group</a>, &copy; 2001</font></div>
    </td>
  </tr>
</table>
В данной главе рассмотрены некоторые общие вопросы создания 16-битного кода, 
  выполняющегося под MS-DOS или Windows 3.x: как скомпоновать программы для получения 
  <font color="#000099">.EXE</font> или <font color="#000099">.COM</font> файлов, 
  как создать драйвер устройства <font color="#000099">.SYS</font>, а также как 
  ассемблерный код взаимодействует с 16-битными компиляторами и с Borland Pascal. 
<h3><a name="section-7.1">7.1 Получение <font color="#000099">.EXE</font> файлов</a></h3>
<p>Любые большие программы, написанные под DOS, необходимо создавать как <font color="#000099">.EXE</font> 
  файлы: только они имеют необходимую внутреннюю структуру для захвата более одного 
  64К сегмента. Программы Windows также требуется создавать как <font color="#000099">.EXE</font> 
  файлы, так как <font color="#000099">.COM</font> файлы Windows не поддерживает. 
<p>Обычно <font color="#000099">.EXE</font> файлы генерируются при помощи выходного 
  формата <font color="#000099">obj</font> (при этом создаются один или более 
  <font color="#000099">.OBJ</font> файлов, связываемых затем друг с другом компоновщиком). 
  Однако при помощи выходного формата <font color="#000099">bin</font> и некоторых 
  макросредств NASM поддерживает также непосредственное создание простых <font color="#000099">.EXE</font> 
  файлов DOS (заголовок <font color="#000099">.EXE</font> файла конструируется 
  при помощи <font color="#000099">DB</font> и <font color="#000099">DW</font>). 
  Спасибо Yann Guidon за содействие при кодировании этого. 
<p>В будущем NASM может быть станет поддерживать и "родной" выходной <font color="#000099">.EXE</font> 
  формат. 
<h4><a name="section-7.1.1">7.1.1 Использование формата <font color="#000099">obj</font> 
  для получения <font color="#000099">.EXE</font> файлов</a></h4>
<p>В данном параграфе описан обычный способ создания <font color="#000099">.EXE</font> 
  файлов путем компоновки друг с другом <font color="#000099">.OBJ</font> файлов. 
<p>Большинство 16-битных языков программирования поставляются с собственным компоновщиком; 
  если у вас нет ни одного, возьмите с <a href="ftp://x2ftp.oulu.fi/pub/msdos/programming/lang/">x2ftp.oulu.fi</a> 
  свободно распространяемый компоновщик VAL, упакованный в формате LZH. LZH-архиватор 
  можно найти на <a href="ftp://ftp.simtel.net/pub/simtelnet/msdos/arcers">ftp.simtel.net</a>. 
  На <a href="http://www.pcorner.com/tpc/old/3-101.htm">www.pcorner.com</a> имеется 
  еще один бесплатный компоновщик <font color="#000099">FREELINK</font> (только 
  он без исходников), и наконец, на <a href="http://www.delorie.com/djgpp/16bit/djlink/">www.delorie.com</a> 
  можно взять компоновщик <font color="#000099">djlink</font>, написанный DJ Delorie. 
<p>При компоновке нескольких <font color="#000099">.OBJ</font> файлов в один <font color="#000099">.EXE</font> 
  файл вы должны убедиться, что только один из них (<font color="#000099">.OBJ</font>) 
  имеет точку входа (при помощи специального символа <font color="#000099">..start</font>, 
  определяемого <font color="#000099">obj</font> форматом: см. <a href="nasm_ru6.html#section-6.2.6">параграф 
  6.2.6</a>). Если ни один из модулей не определяет точки входа, компоновщик не 
  будет знать, какое значение записать в заголовок выходного файла в качестве 
  стартового адреса; если же точка входа определена в нескольких файлах, компоновщик 
  не сможет понять, <i>какое</i> именно значение использовать. 
<p>Здесь приводится пример исходного файла, который ассемблируется NASMом в <font color="#000099">.OBJ</font> 
  файл и им же компонуется в <font color="#000099">.EXE</font>. На этом примере 
  продемонстрированы основные принципы определения стека, инициализации сегментных 
  регистров и объявления точки входа. Данный файл содержится также в подкаталоге 
  <font color="#000099">test</font> NASM-архивов под именем <font color="#000099">objexe.asm</font>. 
<p><pre>
          segment code 

..start:  mov ax,data 
          mov ds,ax 
          mov ax,stack 
          mov ss,ax 
          mov sp,stacktop
</pre>
<p>Эта инициализационная часть кода устанавливает <font color="#000099">DS</font> 
  на сегмент данных и инициализирует <font color="#000099">SS</font> и <font color="#000099">SP</font> 
  для указания на вершину стека. Заметьте, что после записи в <font color="#000099">SS</font> 
  прерывания неявно запрещаются на время выполнения следующей команды, в качестве 
  которой подразумевается загрузка <font color="#000099">SP</font>. Это необходимо 
  для корректной инициализации стека. 
<p>Заметьте также, что в начале данного кода определен символ <font color="#000099">..start</font>, 
  который в результирующем исполнимом файле будет являться точкой входа. 
<p><pre>
          mov dx,hello 
          mov ah,9 
          int 0x21
</pre>
<p>Здесь начинается основная программа: загрузка в <font color="#000099">DS:DX</font> 
  указателя на приветствующее сообщение (<font color="#000099">hello</font> является 
  неявной ссылкой на сегмент <font color="#000099">data</font>, загруженный в 
  <font color="#000099">DS</font> настроечным кодом, поэтому полный указатель 
  корректен) и вызов DOS-функции вывода строки на экран. 
<p><pre>
          mov ax,0x4c00 
          int 0x21
</pre>
<p>Здесь программа завершается при помощи другого системного DOS-вызова. 
<p>
<pre>
          segment data 
hello:    db 'Привет, фуфел!', 13, 10, '$'
</pre>
<p>Сегмент данных содержит строку, которую нужно отобразить на экране. 
<p><pre>
          segment stack stack 
          resb 64 
stacktop:
</pre>
<p>Данный код объявляет сегмент стека, содержащий 64 байта неинициализированного 
  стекового пространства, где символ <font color="#000099">stacktop</font> указывает 
  на его вершину. Директива <font color="#000099">segment stack stack</font> определяет 
  сегмент под <i>именем</i> <font color="#000099">stack</font>, <i>тип</i> которого 
  также <font color="#000099">STACK</font>. В нашем случае не требуется дальнейшее 
  выполнение программы, но если в ней не определить сегмент <font color="#000099">STACK</font>, 
  компоновщики вероятнее всего выдадут предупреждение или сообщение об ошибке. 
<p>Приведенный выше файл будет ассемблироваться в <font color="#000099">.OBJ</font> 
  файл, затем компоноваться NASM в корректный <font color="#000099">.EXE</font> 
  файл, который при запуске будет выводить на экран строку '<font color="#000099">Привет, 
  фуфел!</font>' и затем завершаться. 
<h4><a name="section-7.1.2">7.1.2 Использование формата <font color="#000099">bin</font> 
  для получения <font color="#000099">.EXE</font> файлов</a></h4>
<p>Формат <font color="#000099">.EXE</font> является достаточно простым, поэтому 
  построение <font color="#000099">.EXE</font> файлов возможно путем написания 
  чисто бинарной программы с последующим помещением в ее начало 32-битного заголовка. 
  Структура заголовка несложная, поэтому он может быть создан обычными командами 
  <font color="#000099">DB</font> и <font color="#000099">DW</font>. Исходя из 
  вышесказанного, для непосредственного создания <font color="#000099">.EXE</font> 
  файлов может быть использован формат <font color="#000099">bin</font>. 
<p>В архиве NASM имеется подкаталог <font color="#000099">misc</font>, в котором 
  находится файл макросов <font color="#000099">exebin.mac</font>. В этом файле 
  определены три макроса: <font color="#000099">EXE_begin, EXE_stack</font> и 
  <font color="#000099">EXE_end</font>. 
<p>Для создания файла при помощи формата <font color="#000099">bin</font> вы должны 
  включить в свой исходный файл директиву <font color="#000099">%include exebin.mac</font>, 
  загружающую в него пакет требуемых макросов. Затем для генерации заголовка файла 
  вы должны выполнить макрокоманду <font color="#000099">EXE_begin</font> (не 
  имеет аргументов). После этого следует обычный для формата <font color="#000099">bin</font> 
  код программы &#151; вы можете использовать все три стандартные секции <font color="#000099">.text, 
  .data</font> и <font color="#000099">.bss</font>. В конце файла вы должны вызвать 
  макрос <font color="#000099">EXE_end</font> (без аргументов), который для маркировки 
  размеров секции определяет некоторые символы, ссылающиеся на заголовок кода, 
  сгенерированный макросом <font color="#000099">EXE_begin</font>. 
<p>В данной модели написанный вами код стартует с адреса <font color="#000099">0x100</font>, 
  как и обычный <font color="#000099">.COM</font> файл &#151; в действительности, 
  если вы удалите 32-битный заголовок из сгенерированного <font color="#000099">.EXE</font> 
  файла, то получите работающую <font color="#000099">.COM</font> программу. Все 
  базы сегментов в полученном файле одинаковы, поэтому размер программы ограничен 
  64К (опять же, как и <font color="#000099">.COM</font> файл). Имейте в виду, 
  что директива <font color="#000099">ORG</font> используется макросом <font color="#000099">EXE_begin</font>, 
  поэтому вы не должны применять ее самостоятельно. 
<p>Вы не можете прямо ссылаться на значение базы вашего сегмента, к сожалению 
  это потребовало бы перемещений в заголовке, что реализовать гораздо сложнее. 
  Поэтому вы должны получать базу сегмента копированием ее из <font color="#000099">CS</font>. 
<p>При запуске полученного <font color="#000099">.EXE</font> файла пара <font color="#000099">SS:SP</font> 
  настраивается на указание вершины 2Кб стека. Вызвав макрос <font color="#000099">EXE_stack</font>, 
  вы можете изменить размер стека по умолчанию. Например, для изменения размера 
  стека вашей программы до <font color="#000099">64 байт</font> вы должны вызвать 
  <font color="#000099">EXE_stack 64</font>. 
<p>В подкаталоге архива NASM содержится простая программа <font color="#000099">binexe.asm</font>, 
  из которой <font color="#000099">.EXE</font> файл создается вышеописанным способом. 
<h3><a name="section-7.2">7.2 Получение .COM файлов</a></h3>
<p>В то время, как большие DOS-программы должны писаться в виде <font color="#000099">.EXE</font> 
  файлов, небольшие часто лучше и проще написать как <font color="#000099">.COM</font> 
  файлы. <font color="#000099">.COM</font> файлы являются чисто бинарными, поэтому 
  большинство их может быть создано при помощи выходного формата <font color="#000099">bin</font>. 
<h4><a name="section-7.2.1">7.2.1 Использование формата <font color="#000099">bin</font> 
  для получения <font color="#000099">.COM</font> файлов</a></h4>
<p><font color="#000099">.COM</font> файлы загружаются в свой сегмент по смещению 
  <font color="#000099">100h</font> (сегмент может меняться). Выполнение начинается 
  с адреса 100h, т.е. программа по этому адресу стартует. Таким образом, при написании 
  <font color="#000099">.COM</font> программы ваш исходный файл должен выглядеть 
  наподобие следующего: 
<p>
<pre>
          org 100h 
          section .text 
start:    ; сюда поместите код 
          section .data 
          ; сюда поместите данные 
          section .bss 
          ; здесь находятся неинициализированные данные
</pre>
<p>Формат <font color="#000099">bin</font> помещает секцию <font color="#000099">.text</font> 
  в начале файла, поэтому вы можете объявлять данные или BSS перед написанием 
  собственно кода. 
<p>Секция <font color="#000099">BSS</font> (неинициализированные данные) не занимает 
  места в самом <font color="#000099">.COM</font> файле: вместо этого адреса BSS-элементов 
  разрешаются относительно адреса конца файла, т.е. при запуске программы это 
  пространство будет являться свободной памятью, поэтому вы не должны предполагать, 
  что оно будет заполнено нулями или чем-либо еще &#151; там находится просто 
  мусор. 
<p>Для ассемблирования приведенной выше программы вы должны использовать следующую 
  командную строку: 
<p><pre>
nasm myprog.asm -fbin -o myprog.com
</pre>
<p>Если явно не указать имя выходного файла, формат <font color="#000099">bin</font> 
  создаст файл с именем <font color="#000099">myprog</font>; в этом случае вы 
  можете просто переименовать его так, как вам нужно. 
<h4><a name="section-7.2.2">7.2.2 Использование формата <font color="#000099">obj</font> 
  для получения <font color="#000099">.COM</font> файлов</a></h4>
<p>Если вы пишете <font color="#000099">.COM</font> программу с применением более 
  одного модуля, то возможно захотите ассемблировать несколько <font color="#000099">.OBJ</font> 
  файлов и затем собрать их в одну программу. Вы можете это сделать двумя путями: 
  при помощи компоновщика, способного непосредственно создавать <font color="#000099">.COM</font> 
  файлы (TLINK это может) или применив конвертер <font color="#000099">EXE2BIN</font> 
  для преобразования <font color="#000099">.EXE</font> файла, полученного на выходе 
  компоновщика, в <font color="#000099">.COM</font> файл. 
<p>Если вы это делаете, вам нужно позаботиться о нескольких вещах: 
<ul>
  <li>Кодовый сегмент первого объектного файла должен начинаться со строки вида 
    <font color="#000099">RESB 100h</font>. Это гарантирует начало кода по смещению 
    <font color="#000099">100h</font> относительно начала сегмента, так чтобы 
    компоновщик или программа конвертации не корректировали адресные ссылки при 
    генерации <font color="#000099">.COM</font> файла. Другие ассемблеры для данной 
    цели используют директиву <font color="#000099">ORG</font>, однако в NASM 
    <font color="#000099">ORG</font> является дополнительной директивой выходного 
    формата <font color="#000099">bin</font> и не означает то же самое, что в 
    MASM-совместимых ассемблерах. 
  <li>Вам не нужно определять сегмент стека. 
  <li>Все ваши сегменты должны быть в одной и той же группе, чтобы все смещения 
    на символы как в коде, так и в данных были смещениями относительно одной и 
    той же базы сегмента. Это нужно для того, чтобы при загрузке <font color="#000099">.COM</font> 
    файла все сегментные регистры содержали одно и то же значение. 
</ul>
<h3><a name="section-7.3">7.3 Получение .SYS файлов</a></h3>
<p>Драйверы устройств MS-DOS &#151; <font color="#000099">.SYS</font> файлы &#151; 
  это чисто бинарные файлы, во всем похожие на <font color="#000099">.COM</font>, 
  за исключением того, что они запускаются по нулевому смещению, а не по смещению 
  <font color="#000099">100h</font>. Поэтому если вы пишете драйвер при помощи 
  формата <font color="#000099">bin</font>, директива <font color="#000099">ORG</font> 
  вам не нужна, так как по умолчанию смещение для <font color="#000099">bin</font> 
  всегда нулевое. Соответственно вам не требуется указывать в начале кодового 
  сегмента <font color="#000099">RESB 100h</font>, если вы используете формат 
  <font color="#000099">obj</font>. 
<p><font color="#000099">.SYS</font> файлы начинаются с заголовочной структуры, 
  содержащей указатели на различные подпрограммы внутри драйвера. Данная структура 
  должна быть определена в начале сегмента кода, несмотря на то, что в действительности 
  кодом она не является. 
<p>Дополнительную информацию о формате <font color="#000099">.SYS</font> файлов 
  и данных, содержащихся в их заголовочной структуре, вы можете почерпнуть в часто 
  задаваемых вопросах конференции <a href="news:comp.os.msdos.programmer">comp.os.msdos.programmer</a>. 
<h3><a name="section-7.4">7.4 Взаимодействие с 16-битными C-программами</a></h3>
<p>В данном параграфе описываются основы создания ассемблерных подпрограмм, которые 
  вызывают или которые вызываются из программ С. Для осуществления этого обычно 
  нужно написать ассемблерный модуль в виде <font color="#000099">.OBJ</font> 
  файла и скомпоновать его с С-модулями. 
<h4><a name="section-7.4.1">7.4.1 Внешние символьные имена</a></h4>
<p>Компиляторы С имеют соглашения, в соответствии с которыми имена всех глобальных 
  символов (функций или данных) образуются путем префиксирования имени из С-программы 
  символом подчеркивания. Так, например, функция, о которой С-программист думает 
  как о <font color="#000099">printf</font>, для программиста на ассемблере является<font color="#000099"> 
  _printf</font>. Это означает, что в своей ассемблерной программе вы можете определять 
  символы без лидирующего знака подчеркивания, не боясь при этом, что они случайно 
  совпадут с именами С-символов. 
<p>Если вам неудобно использовать знаки подчеркивания, вы можете определить макросы 
  для замены директив <font color="#000099">GLOBAL</font> и <font color="#000099">EXTERN</font> 
  следующим образом: 
<p><pre>
%macro cglobal 1 
          global _%1 
%define %1 _%1 
%endmacro
</pre>
<p><pre>
%macro cextern 1 
          extern _%1 
%define %1 _%1 
%endmacro
</pre>
<p>(Данные формы макросов принимают только один аргумент; если вам требуется больше, 
  используйте конструкцию <font color="#000099">%rep</font>). 
<p>Если вы определите внешний символ как 
<p><pre>
          cextern printf
</pre>
<p>макрос развернет его в следующие строки: 
<p><pre>
          extern _printf 
%define printf _printf
</pre>
<p>Thereafter, you can reference printf as if it
was a symbol, and the preprocessor will put the leading underscore on where
necessary.
<p>После этого вы можете ссылаться на <font color="#000099">printf</font>, а препроцессор, 
  где это нужно, будет помещать ведущий знак подчеркивания. Макрос <font color="#000099">cglobal</font> 
  работает точно также. 
<h4><a name="section-7.4.2">7.4.2 Модели памяти</a></h4>
<p>NASM прямо не поддерживает механизма различных моделей памяти, реализованных 
  в С; вы должны отслеживать это самостоятельно. Это означает, что вы должны учитывать 
  следующее: 
<ul>
  <li>В моделях, имеющих один сегмент кода (tiny, small и compact), функции являются 
    ближними. Это значит, что указатели на функции при сохранении в сегменте данных 
    или помещении в стек являются 16-битными и содержат только поле смещения (регистр 
    <font color="#000099">CS</font> никогда не изменяет свое значение и всегда 
    содержит сегментную часть полного адреса функции) и что такие функции вызываются 
    инструкцией <font color="#000099">near CALL</font> и возврат из них производится 
    при помощи <font color="#000099">RETN</font> (что в NASM является синонимом 
    <font color="#000099">RET</font>). Следовательно, вы должны писать свои подпрограммы 
    с использованием <font color="#000099">RETN</font>, а также вызывать внешние 
    С-подпрограммы при помощи ближней инструкции <font color="#000099">CALL</font>. 
  <li>В моделях, использующих более одного сегмента кода (medium, large и huge), 
    функции являются дальними. Это значит, что длина указателей функций составляет 
    32 бита (16 бит смещение и 16 бит сегмент) и что функции вызываются при помощи 
    <font color="#000099">CALL FAR</font> (или <font color="#000099">CALL seg:offset</font>) 
    и возврат из них производится при помощи <font color="#000099">RETF</font>. 
    При использовании таких моделей вы должны писать свои подпрограммы так, чтобы 
    возврат из них производился по <font color="#000099">RETF</font>, а внешние 
    подпрограммы вызывать при помощи <font color="#000099">CALL FAR</font>. 
  <li>В моделях, использующих единственный сегмент данных (tiny, small и medium), 
    указатели на данные являются 16-битными, содержащими только поле смещения 
    (регистр <font color="#000099">DS</font> не изменяет своего значения и всегда 
    представляет сегментную часть полного адреса). 
  <li>В моделях, использующих более одного сегмента данных (compact, large и huge), 
    длина указателей на данные составляет 32 бит, 16 бит из которых является смещением, 
    а другие 16 бит &#151; сегментом. Вы должны стараться в своих подпрограммах 
    не модифицировать <font color="#000099">DS</font> без необходимости, а после 
    модификации &#151; всегда восстанавливать. В то же время регистр <font color="#000099">ES</font> 
    свободен и вы можете использовать его для доступа к содержимому, на которое 
    ссылается 32-битный указатель. 
  <li>Модель памяти <font color="#000099">huge</font> позволяет одиночным элементам 
    данных превышать размер 64К. В любых других моделях вы можете получить доступ 
    ко всем элементам данных простым арифметическим манипулированием переданного 
    поля смещения (неважно, присутствует поле сегмента или нет). В модели памяти 
    huge к вычислению указателей надо подходить более тщательно. 
  <li>В большинстве моделей памяти имеется сегмент данных <i>по умолчанию</i>, 
    сегментный адрес которого хранится в <font color="#000099">DS</font> на протяжении 
    всего выполнения программы. Этот сегмент данных обычно совпадает с сегментом 
    стека, хранящемся в <font color="#000099">SS</font>, поэтому и локальные переменные 
    функций (хранящиеся в стеке), и глобальные элементы данных могут быть легко 
    доступны без изменения <font color="#000099">DS</font>. Большие элементы данных 
    обычно хранятся в других сегментах. Однако некоторые модели памяти (хотя обычно 
    они нестандартные) используют <font color="#000099">SS</font> и <font color="#000099">DS</font> 
    по другому. Будьте внимательны в этом случае по отношению к локальным переменным 
    функций. 
</ul>
<p>В моделях с единственным сегментом кода этот сегмент называется <font color="#000099">_TEXT</font>, 
  поэтому ваш сегмент должен иметь то же самое имя для компоновки его в то же 
  место, что и основной сегмент кода. В моделях с единственным сегментом данных 
  или с сегментом данных по умолчанию последний именуется как <font color="#000099">_DATA</font>. 
<h4><a name="section-7.4.3">7.4.3 Определения и вызовы функций</a></h4>
<p>Соглашения по вызовам С в 16-битных программах описываются ниже. 
<ul>
  <li>Вызывающая программа помещает параметры функции в стек один за другим в 
    обратном порядке следования (так что первый аргумент функции помещается в 
    стек последним). 
  <li>Вызывающая программа выполняет инструкцию <font color="#000099">CALL</font> 
    для передачи управления подпрограмме. Эта инструкция в зависимости от модели 
    памяти может быть как ближней, так и дальней. 
  <li>Подпрограмма получает управление и обычно (несмотря на то, что это не требуется 
    в функциях, которым не нужен доступ к своим параметрам) начинается с сохранения 
    <font color="#000099">SP</font> в <font color="#000099">BP</font> с целью 
    дальнейшего использования <font color="#000099">BP</font> в качестве базы 
    указателя для нахождения параметров в стеке. Однако частью соглашений о вызовах 
    является сохранение содержимого <font color="#000099">BP</font> любой функцией 
    С. Следовательно подпрограмма, если она использует <font color="#000099">BP</font> 
    как указатель кадра, должна предварительно поместить в стек его содержимое. 
  <li>Подпрограмма может получить свои параметры через <font color="#000099">BP</font>. 
    Слово <font color="#000099">[BP]</font> хранит предыдущее значение <font color="#000099">BP</font>, 
    помещенное в стек; следующее слово, <font color="#000099">[BP+2]</font>, хранит 
    смещение адреса возврата, помещенное в стек инструкцией <font color="#000099">CALL</font>. 
    В ближних функциях после этого (<font color="#000099">[BP+4]</font>) начинаются 
    параметры; в дальных функциях по адресу <font color="#000099">[BP+4]</font> 
    находится сегментная часть адреса возврата и параметры начинаются с <font color="#000099">[BP+6]</font>. 
    Самый левый параметр функции доступен по смещению из <font color="#000099">BP</font>, 
    т.к. в стек он был помещен последним; следующие параметры соответственно доступны 
    по следующим смещениям. Таким образом, в функциях с переменным числом параметров, 
    подобных <font color="#000099">printf</font>, помещение параметров в стек 
    в обратном порядке означает, что функция знает, где находится ее первый параметр, 
    сообщающий число и тип оставшихся параметров. 
  <li>Подпрограмма после этого может увеличить значение <font color="#000099">SP</font>, 
    например для распределения места в стеке для локальных переменных, которые 
    после этого будут доступны по отрицательным смещениям от <font color="#000099">BP</font>. 
  <li>Подпрограмма, если она возвращает значение вызывающей программе, должна 
    передавать это значение в <font color="#000099">AL, AX</font> или <font color="#000099">DX:AX</font> 
    в зависимости от размера последнего. Результаты, являющиеся числами с плавающей 
    точкой иногда (в зависимости от компилятора) возвращаются в регистре сопроцессора 
    <font color="#000099">ST0</font>. 
  <li>Как только подпрограмма завершит свою работу, она восстанавливает значение 
    <font color="#000099">SP</font> из <font color="#000099">BP</font> (если она 
    распределяла локальное пространство стека), затем изымает из стека предыдущее 
    значение <font color="#000099">BP</font> и в зависимости от модели памяти 
    возвращается в вызвавшую программу через <font color="#000099">RETN</font> 
    или <font color="#000099">RETF</font>. 
  <li>Когда вызывающая программа возвратит себе управление, параметры функции 
    остаются в стеке, поэтому для удаления их к <font color="#000099">SP</font> 
    обычно прибавляется непосредственная константа (вместо выполнения серии медленных 
    инструкций <font color="#000099">POP</font>). Поэтому если функция случайно 
    (например, из-за несоответствия прототипов) будет вызвана с неверным числом 
    параметров, стек при возврате останется в осмысленном состоянии, т.к. вызвавшая 
    программа, которая <i>знает</i>, сколько параметров она поместила в стек, 
    удалит их. 
</ul>
<p>Поучительно сравнить данное соглашение о вызовах с программами на Паскале (см. 
  <a href="#section-7.5.1">параграф 7.5.1</a>). Паскаль имеет более простое соглашение, 
  т.к. в нем нет функций с переменным числом параметров и подпрограмма знает, 
  сколько параметров ей передается и способна самостоятельно удалить их из стека 
  путем указания в инструкциях <font color="#000099">RET</font> или <font color="#000099">RETF</font> 
  непосредственного значения. Параметры помещаются в стек слева-направо, а не 
  справа-налево как в С, поэтому компилятор может дать лучшую гарантию последовательности 
  выполнения без снижения производительности. 
<p>Исходя из вышесказанного, вы можете определить С-подобную функцию следующим 
  образом (в примере использована модель памяти <font color="#000099">small</font>): 
<p>
<pre>
          global _myfunc 
_myfunc:  push bp 
          mov bp,sp 
          sub sp,0x40            ; 64 байта локального пространства стека 
          mov bx,[bp+4]          ; первый параметр функции 
          ; некоторый код
          mov sp,bp              ; отмена "sub sp,0x40" выше
          pop bp 
          ret
</pre>
<p>Для больших моделей памяти вы должны заменить <font color="#000099">RET</font> 
  в данной функции на <font color="#000099">RETF</font> и брать первый параметр 
  не из <font color="#000099">[BP+4]</font>, а из <font color="#000099">[BP+6]</font>. 
  Естественно, если один из параметров будет указателем, смещения следующих параметров 
  будут зависеть от модели памяти: дальние указатели занимают в стеке 4 байта, 
  в то время как короткие &#151; два. 
<p>Если посмотреть с другой стороны, то для вызова С-функции из вашего ассемблерного 
  кода вы должны сделать что-то наподобие следующего: 
<p>
<pre>
          extern _printf 
          ; здесь идет супер-пупер-прога... 
          push word [myint]      ; целое значение - параметр 
          push word mystring     ; указатель на мой сегмент данных 
          call _printf 
          add sp,byte 4          ; 'byte' экономит размер 
          ; затем следует сегмент данных... 
          segment _DATA 
myint     dw 1234 
mystring  db 'Это число -> %d <- должно быть 1234, фуфел!',10,0
</pre>
<p>Этот ассемблерный код, использующий модель памяти small, эквивалентен С-коду 
<p>
<pre>
    int myint = 1234; 
    printf("Это число -> %d <- должно быть 1234, фуфел!\n", myint);
</pre>
<p>В больших моделях памяти кодирование функции вызова выглядит похоже, но все-таки 
  несколько отличается. В приведенном ниже примере подразумевается, что регистр 
  <font color="#000099">DS</font> уже содержит базу сегмента<font color="#000099"> 
  _DATA</font>. Если это не так, вы должны его проинициализировать. 
<p>
<pre>
          push word [myint] 
          push word seg mystring ; Теперь сохраняем в стеке сегмент, и... 
          push word mystring     ; ... смещение "mystring" 
          call far _printf 
          add sp,byte 6
</pre>
<p>Целое число по прежнему будет занимать в стеке одно слово, так как большая 
  модель памяти не влияет на размер типа данных <font color="#000099">int</font>. 
  В то же время первый аргумент для <font color="#000099">printf</font> (помещаемый 
  в стек последним), является указателем и поэтому состоит из двух частей &#151; 
  сегмента и смещения. Сегмент должен сохраняться в памяти вторым, поэтому в стек 
  он помещается первым. (Конечно <font color="#000099">PUSH DS</font> будет иметь 
  более короткую инструкцию, чем <font color="#000099">PUSH WORD SEG mystring</font>, 
  если <font color="#000099">DS</font> инициализирован так, как подразумевается 
  в приведенном примере). Затем следует дальний вызов <font color="#000099">call 
  far</font>, как это определено для больших моделей памяти; после возврата из 
  подпрограммы регистр стека увеличивается на 6 (а не на 4) с целью коррекции 
  на размер дополнительного слова, помещенного туда ранее. 
<h4><a name="section-7.4.4">7.4.4 Доступ к элементам данных</a></h4>
<p>Для получения доступа к переменным С или объявления переменных, к которым С 
  в свою очередь может обратиться, вы должны всего лишь объявить имена как <font color="#000099">EXTERN</font> 
  или <font color="#000099">GLOBAL</font> соответственно. (Имена требуют лидирующего 
  знака подчеркивания, см. <a href="#section-7.4.1">параграф 7.4.1</a>.) Таким 
  образом, объявленная в С переменная<font color="#000099"> int i</font> может 
  быть доступна из ассемблера как 
<p><pre>
          extern _i 
          mov ax,[_i]
</pre>
<p>Чтобы объявить собственную целую переменную, к которой С-программа сможет обратиться 
  как <font color="#000099">extern int j</font>, вы должны сделать следующее (убедитесь, 
  что эта переменная находится в сегменте <font color="#000099">_DATA</font>): 
<p><pre>
          global _j 
_j        dw 0
</pre>
<p>Для получения доступа к С-массиву вам нужно знать размер компонетов последнего. 
  Например, переменные типа <font color="#000099">int</font> имеют размер два 
  байта (слово), поэтому если С-программа объявляет массив как <font color="#000099">int 
  a[10]</font>, вы можете обратиться к элементу <font color="#000099">a[3]</font> 
  при помощи инструкции <font color="#000099">mov ax,[_a+6]</font>. (Байтовое 
  смещение 6 получено путем умножения индекса 3 требуемого элемента на размер 
  элементов массива 2). Размеры базовых типов С для 16-битных компиляторов: 1 
  для <font color="#000099">char</font>, 2 для <font color="#000099">short</font> 
  и <font color="#000099">int</font>, 4 для <font color="#000099">long</font> 
  и <font color="#000099">float</font>, 8 для <font color="#000099">double</font>. 
<p>Чтобы получить доступ к структуре данных С, вам необходимо знать смещение интересующего 
  вас поля от базы этой структуры. Вы можете сделать это либо преобразовав определение 
  С-структуры в определение NASM-структуры (при помощи <font color="#000099">STRUC</font>), 
  либо рассчитать это смещение и использовать его "как есть". 
<p>Чтобы правильно использовать структуры С, вы должны изучить руководство по 
  вашему С-компилятору, чтобы знать, как он организует структуры данных. NASM 
  не делает специального выравнивания для членов его собственных структур <font color="#000099">STRUC</font>, 
  поэтому если С-компилятор делает это, вы можете задать такое смещение самостоятельно. 
  Обычно вы можете предположить, что структура наподобие 
<p><pre>
struct { 
    char c; 
    int i; 
} foo;
</pre>
<p>будет иметь длину 4 байта, а не 3, так как поле <font color="#000099">int</font> 
  выравнивается по двухбайтной границе. Однако такие особенности имеют тенденцию 
  конфигурироваться компилятором С при помощи ключей командной строки, либо директив 
  <font color="#000099">#pragma</font>, поэтому вы должны выяснить, как именно 
  это делает ваш компилятор. 
<h4><a name="section-7.4.5">7.4.5 c16.mac: Макросы для 16-битного C-интерфейса</a></h4>
<p>В подкаталоге <font color="#000099">misc</font> архива NASM имеется файл макросов 
  <font color="#000099">c16.mac</font>. В нем определены три макроса: <font color="#000099">proc, 
  arg</font> и <font color="#000099">endproc</font>. Они предназначены для использования 
  в определениях С-подобных процедур и автоматизируют большинство работ по слежению 
  за соблюдением соглашения о вызовах. 
<p>Ниже приведен пример ассемблерной функции, использующей этот набор макросов: 
<p><pre>
          proc _nearproc 
%$i       arg 
%$j       arg 
          mov ax,[bp + %$i] 
          mov bx,[bp + %$j] 
          add ax,[bx] 
          endproc
</pre>
<p>Здесь определяется процедура <font color="#000099">_nearproc</font>, принимающая 
  два аргумента, первый (<font color="#000099">i</font>) &#151; это целое и второй 
  (<font color="#000099">j</font>) &#151; указатель на целое. Процедура возвращает 
  <font color="#000099">i + *j</font>. 
<p>Заметьте, что макрос <font color="#000099">arg</font> при его разворачивании 
  содержит в первой строке <font color="#000099">EQU</font>, которая в результате 
  определяет <font color="#000099">%$i</font> как смещение от <font color="#000099">BP</font>. 
  При этом используются контекстно-локальные переменные (локальные к контексту, 
  сохраняемому в контекстном стеке макросом <font color="#000099">proc</font> 
  и удаляемому оттуда макросом <font color="#000099">endproc</font>), поэтому 
  в других процедурах может быть использовано то же самое имя аргумента. Конечно, 
  вы можете этого <i>не делать</i>. 
<p>По умолчанию представленный набор макросов создает код для ближних функций 
  (модели памяти tiny, small и compact). Чтобы генерировать код для дальних функций 
  (модели medium, large и huge), вы должны определить <font color="#000099">%define 
  FARCODE</font>. Данное определение изменяет тип возвращаемой <font color="#000099">endproc</font> 
  инструкции, а также начальную точку смещения аргументов. Набор макросов совершенно 
  не зависит от того, являются ли указатели данных дальними или нет. 
<p>Макрос <font color="#000099">arg</font> может принимать дополнительный параметр, 
  представляющий собой размер аргумента. Если размер не задан, по умолчанию принимается 
  2, т.к. большинство параметров функций вероятно будут иметь тип <font color="#000099">int</font>. 
<p>Эквивалент представленной выше функции для модели памяти large будет таким: 
<p><pre>
%define FARCODE 
          proc _farproc 
%$i       arg 
%$j       arg 4 
          mov ax,[bp + %$i] 
          mov bx,[bp + %$j] 
          mov es,[bp + %$j + 2] 
          add ax,[bx] 
          endproc
</pre>
<p>Так как<font color="#000099"> j</font> теперь будет дальним указателем, в этом 
  примере используется аргумент макроса <font color="#000099">arg</font>, определяющий 
  параметр размером 4. Когда мы читаем значение по адресу <font color="#000099">j</font>, 
  мы должны загрузить как смещение, так и сегмент. 
<h3><a name="section-7.5">7.5 </a>Взаимодействие с программами Borland Pascal</h3>
<p>Взаимодействие с программами на Паскале в концепции схоже по взаимодействию 
  с 16-битными С-программами, однако имеются следующие различия: 
<ul>
  <li>Требуемые для взаимодействия с С-программами ведущие символы подчеркивания 
    в Паскале не нужны. 
  <li>Модель памяти всегда большая: функции и указатели данных являются дальними, 
    но длина отдельного элемента данных не должна превышать 64К. (На самом деле 
    некоторые функции остаются ближними, но эти функции локализованы в модуле 
    Паскаля и <i>никогда</i> не вызываются извне. Все функции ассемблера, осуществляющие 
    Паскаль-вызовы, а также все функции Паскаля, обращающиеся к ассемблерному 
    коду, <i>должны быть дальними</i>). В то же время все объявленные в Паскаль-программе 
    статические данные помещаются в сегменте данных по умолчанию, т.е. его сегментный 
    адрес при передаче управления вашему ассемблерному коду будет содержаться 
    в DS. В сегменте данных не располагаются только локальные переменные (они 
    находятся в сегменте стека) и переменные, память для которых выделяется динамически. 
    Однако все <i>указатели</i> данных являются дальними. 
  <li>Соглашение о вызовах функций отличается от С &#151; описание приведено далее. 
  <li>Некоторые типы данных, такие как строки, хранятся по другому. 
  <li>Имеются ограничения на имена сегментов, которые вам разрешено использовать 
    &#151; Borland Pascal будет игнорировать код или данные, объявленные в сегменте 
    с неподходящим именем. Эти ограничения также описаны ниже. 
</ul>
<h4><a name="section-7.5.1">7.5.1 Соглашение о вызовах в Pascal</a></h4>
<p>Ниже описываются соглашения о вызовах в 16-битных Паскаль-программах. 
<ul>
  <li>Вызывающая программа помещает параметры функции в стек один за другим в 
    обычном порядке (слева-направо, так что первый аргумент функции помещается 
    также первым). 
  <li>Вызывающая программа для передачи управления подпрограмме выполняет дальнюю 
    инструкцию <font color="#000099">CALL</font>. 
  <li>Подпрограмма получает управление и обычно (несмотря на то, что это не требуется 
    в функциях, которым не нужен доступ к своим параметрам) начинается с сохранения 
    <font color="#000099">SP</font> в <font color="#000099">BP</font> с целью 
    дальнейшего использования <font color="#000099">BP</font> в качестве базы 
    указателя для нахождения параметров в стеке. Однако частью соглашений о вызовах 
    является сохранение содержимого <font color="#000099">BP</font> любой функцией. 
    Следовательно подпрограмма, если она использует <font color="#000099">BP</font> 
    как указатель кадра, должна предварительно поместить в стек его содержимое. 
  <li>Подпрограмма может получить доступ к своим параметрам относительно <font color="#000099">BP</font>. 
    Слово <font color="#000099">[BP]</font> адресует в стеке предыдущее значение 
    <font color="#000099">BP</font>. Следующее слово, <font color="#000099">[BP+2]</font>, 
    адресует смещение адреса возврата, а <font color="#000099">[BP+4]</font> &#151; 
    сегмент адреса возврата. Параметры начинаются со смещения <font color="#000099">[BP+6]</font>. 
    По этому смещению от <font color="#000099">BP</font> доступен самый "правый" 
    параметр функции, так как в стек он был помещен последним; следующие параметры 
    идут соответственно по более большим смещениям. 
  <li>В процессе выполнения подпрограмма может увеличить значение <font color="#000099">SP</font> 
    с целью выделения в стеке места под свои локальные переменные. Эти переменные 
    будут доступны по отрицательным от <font color="#000099">BP</font> смещениям. 
  <li>Подпрограмма должна передавать результат выполнения назад в вызвавшую программу 
    через <font color="#000099">AL, AX</font> или <font color="#000099">DX:AX</font>, 
    в зависимости от размера значения. Результаты в виде чисел с плавающей точкой 
    возвращаются через регистр <font color="#000099">ST0</font>. Результаты типа 
    <font color="#000099">Real</font> (собственные типы Борланда &#151; числа 
    с плавающей точкой, прямо не обрабатываемые в <font color="#000099">FPU</font>) 
    возвращаются в группе <font color="#000099">DX:BX:AX</font>. Чтобы возвратить 
    результат типа <font color="#000099">String</font>, вызывающая программа перед 
    помещением в стек параметров помещает туда указатель на временную строку, 
    а подпрограмма по этому адресу возвращает строковое значение. Указатель не 
    является параметром и не должен удаляться из стека инструкцией <font color="#000099">RETF</font>. 
  <li>Когда подпрограмма заканчивает свою работу, она восстанавливает содержимое 
    <font color="#000099">SP</font> из <font color="#000099">BP</font>, достает 
    из стека предыдущее значение <font color="#000099">BP</font> и возвращается 
    через <font color="#000099">RETF</font>. Здесь используется форма <font color="#000099">RETF</font> 
    с непосредственным операндом, представляющим собой число байт, снимаемых с 
    вершины стека в качестве параметров. Снятие параметров со стека &#151; это 
    побочный эффект инструкции возврата. 
  <li>Дополнительных действий от вызвавшей программы не требуется, так как параметры 
    функции при получении ей управления уже удалены из стека. 
</ul>
<p>Исходя из вышесказанного, вы должны определить функцию в стиле Паскаль, принимающую 
  два аргумента типа <font color="#000099">Integer</font>, следующим образом: 
<p>
<pre>
          global myfunc 
myfunc:   push bp 
          mov bp,sp 
          sub sp,0x40            ; резервируется 64 байта в стеке 
          mov bx,[bp+8]          ; первый аргумент функции 
          mov bx,[bp+6]          ; второй аргумент функции 
          ; код, который наверное что-то делает
          mov sp,bp              ; отмена "sub sp,0x40" выше 
          pop bp 
          retf 4                 ; общий размер аргументов 4
</pre>
<p>С другой стороны, для вызова Паскаль-функции из вашего ассемблерного кода, 
  вы должны сделать что-то вроде следующего: 
<p>
<pre>
          extern SomeFunc 
          ; тут идет какой-то код...
          push word seg mystring ; Теперь в стек помещается сегмент и...
          push word mystring     ; ... смещение строки "mystring"
          push word [myint]      ; одна из переменных 
          call far SomeFunc
</pre>
<p>Этот код эквивалентен следующим строкам на Паскале: 
<p><pre>
procedure SomeFunc(String: PChar; Int: Integer); 
    SomeFunc(@mystring, myint);
</pre>
<h4><a name="section-7.5.2">7.5.2 Ограничение имен сегментов в Borland Pascal</a></h4>
<p>Так как внутренний формат модуля Borland Pascal полностью отличается от <font color="#000099">OBJ</font>, 
  при компоновке модуля с реальным <font color="#000099">OBJ</font> файлом выполняется 
  очень поверхностная работа по чтению и пониманию различной информации из последнего. 
  Вследствие этого объектные файлы, предназначенные для компоновки с Паскаль-программами, 
  должны удовлетворять нескольким ограничениям: 
<ul>
  <li>Процедуры и функции должны находиться в сегменте с именем <font color="#000099">CODE, 
    CSEG</font>, или заканчивающимся на <font color="#000099">_TEXT</font>. 
  <li>Инициализированные данные должны находиться в сегменте с именем <font color="#000099">CONST</font> 
    или заканчивающимся на <font color="#000099">_DATA</font>. 
  <li>Неинициализированные данные должны находиться в сегменте с именем <font color="#000099">DATA, 
    DSEG</font>, или заканчивающимся на <font color="#000099">_BSS</font>. 
  <li>Любые другие сегменты, имеющиеся в объектном файле, полностью игнорируются. 
    Директивы <font color="#000099">GROUP</font> и атрибуты сегментов также игнорируются. 
</ul>
<h4><a name="section-7.5.3">7.5.3 Использование <font color="#000099">c16.mac</font> 
  с Pascal-программами</a></h4>
<p>Пакет макросов c16.mac, описанный в <a href="#section-7.4.5">параграфе 7.4.5</a>, 
  может быть также использован для облегчения написания функций, вызываемых из 
  программ на Паскале. Для этого вам нужно определить <font color="#000099">%define 
  PASCAL</font>. Данное определение делает все функции дальними (это подразумевает 
  <font color="#000099">FARCODE</font>), а также генерирует инструкции возврата 
  из подпрограммы в форме, имеющей операнд. 
<p>Определение <font color="#000099">PASCAL</font> не изменяет код, рассчитывающий 
  смещения аргументов; вы должны объявлять аргументы вашей функции в обратном 
  порядке. Например: 
<p><pre>
%define PASCAL 
          proc _pascalproc 
%$j       arg 4 
%$i       arg 
          mov ax,[bp + %$i] 
          mov bx,[bp + %$j] 
          mov es,[bp + %$j + 2] 
          add ax,[bx] 
          endproc
</pre>
<p>Концептуально здесь определяется та же самая подпрограмма, что и в <a href="#section-7.4.5">параграфе 
  7.4.5</a>: функция принимает два аргумента, целое число и указатель на целое 
  и возвращает сумму целого и содержимого, на которое ссылается указатель. Отличие 
  между этим кодом и версией С для большой модели памяти состоит в том, что вместо 
  <font color="#000099">FARCODE</font> определяется <font color="#000099">PASCAL</font>, 
  а аргументы объявляются в обратном порядке. 
<p align=center><a href="nasm_ru8.html">Следующая глава</a> | <a href="nasm_ru6.html">Предыдущая 
  глава </a> | <a href="contents.html">Содержание</a> | Указатель
<hr noshade size=1>
<b><a href="http://www.opennet.ru/docs/">Архив документации на OpenNet.ru</a>
</body></html>
