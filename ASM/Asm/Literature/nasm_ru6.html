<html><head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r"><title>Руководство по NASM</title>

<META NAME="GENERATOR" CONTENT="Super-Puper-Mega-Proga"></head>
<body bgcolor="#DDE1C2"><b><a href="http://www.opennet.ru/docs/">Архив документации OpenNet.ru</a> / 
Раздел "<a href="http://www.opennet.ru/docs/124.shtml">Программирование, языки</a>" /
<a href="index.html">Индекс</a>
</b>
<hr noshade size=1>

<h1 align=center>Расширенный ассемблер: NASM</h1>

<p align=center><a href="nasm_ru7.html">Следующая глава</a> | <a href="nasm_ru5.html">Предыдущая 
  глава </a> | <a href="contents.html">Содержание</a> | Указатель</p>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr> 
    <td width="60%"> 
      <h2><a name="chapter-6">Глава 6: Выходные форматы</a></h2>
    </td>
    <td> 
      <div align="right"><font size="-1" color="#666666">Перевод: <a href="http://asmdev.narod.ru/asmos.html">AsmOS 
        group</a>, &copy; 2001</font></div>
    </td>
  </tr>
</table>
NASM &#151; портируемый ассемблер, разработанный для компиляции на любых платформах, 
  поддерживающих ANSI C и создающий исполнимые файлы различных Intel <font color="#000099">x86</font>-совместимых 
  операционных систем. Для обеспечения этого он поддерживает большое число выходных 
  форматов, выбираемых при помощи ключа <font color="#000099">-f</font> командной 
  строки. В данной главе описываются все эти форматы вместе с их специфичным синтаксисом. 

<p>Как упоминалось в <a href="nasm_ru2.html#section-2.1.1">параграфе 2.1.1</a>, 
  NASM выбирает имя по умолчанию для выходного файла на основе имени входного 
  файла и указанного выходного формата. При этом расширение входного файла (<font color="#000099">.asm, 
  .s</font> или др.) удаляется и вместо него подставляется расширение соответствующего 
  выходного формата. Расширения файлов приводятся ниже в описаниях каждого формата. 
<h3><a name="section-6.1">6.1 <font color="#000099">bin</font>: Плоский бинарный 
  формат</a></h3>
<p>Формат <font color="#000099">bin</font> не создает объектных файлов: в выходной 
  файл не генерируется ничего, кроме написанного вами кода. Такие "чисто бинарные" 
  файлы используются в MS-DOS: как исполнимые файлы <font color="#000099">.COM</font> 
  и драйвера устройств <font color="#000099">.SYS</font>. Бинарный формат полезен 
  также при разработке операционных систем и загрузчиков. 
<p>Формат <font color="#000099">bin</font> поддерживает только три стандартные 
  секции с именами <font color="#000099">.text, .data</font> и <font color="#000099">.bss</font>. 
  В файле, сгенерированном NASM, сначала будет идти содержимое секции <font color="#000099">.text</font>, 
  а затем содержимое секции <font color="#000099">.data</font>, выровненное по 
  4-байтной границе. Секция <font color="#000099">.bss</font> не хранится в выходном 
  файле, но предполагается, что она будет расположена сразу после секции <font color="#000099">.data</font>, 
  опять же выровненная по 4-байтной границе. 
<p>Если вы явно не указываете директиву <font color="#000099">SECTION</font>, 
  написанный вами код будет направлен по умолчанию в секцию <font color="#000099">.text</font>. 
<p>Использование формата bin переводит NASM по умолчанию в 16-битный режим (см. 
  <a href="nasm_ru5.html#section-5.1">параграф 5.1</a>). Чтобы использовать его 
  для написания 32-битного кода (например, ядра ОС), вам необходимо явно указать 
  директиву <font color="#000099">BITS 32</font>. 
<p>По умолчанию <font color="#000099">bin</font> не создает расширение файла: 
  он просто оставляет исходное имя файла, удалив предварительно его расширение. 
  Таким образом, NASM по умолчанию будет ассемблировать <font color="#000099">binprog.asm</font> 
  в бинарный файл <font color="#000099">binprog</font>. 
<h4><a name="section-6.1.1">6.1.1 <font color="#000099">ORG</font>: Начало бинарного 
  файла</a></h4>
<p>Формат <font color="#000099">bin</font> предусматривает дополнительную к списку 
  <a href="nasm_ru5.html">главы 5</a> директиву <font color="#000099">ORG</font>. 
  Функция этой директивы &#151; задавать начальный адрес программы, с которого 
  она располагается при загрузке в память. 
<p>Например, следующий код будет генерировать двойное слово <font color="#000099">0x00000104</font>: 
<p><pre>
          org 0x100 
          dd label 
label:
</pre>
<p>В отличие от директивы <font color="#000099">ORG</font>, применяемой MASM-совместимыми 
  ассемблерами, которые позволяют перемещаться в объектном файле и переписывать 
  уже сгенерированный код, NASM-овская <font color="#000099">ORG</font> означает 
  только то, что и соответствующее слово: <i>origin (начало)</i>. Ее единственная 
  функция &#151; задавать смещение, которое будет прибавляться ко всем ссылкам 
  на адреса внутри файла; она не допускает такого жульничества, как MASM. Дополнительные 
  комментарии содержатся в <a href="../nasmdo10.html#section-10.1.3">параграфе 
  10.1.3</a>. 
<h4><a name="section-6.1.2">6.1.2 bin-расширение директивы <font color="#000099">SECTION</font> 
  </a></h4>
<p>Выходной формат bin расширяет директиву <font color="#000099">SECTION</font> 
  (или <font color="#000099">SEGMENT</font>), позволяя вам указывать требования 
  к выравниванию сегментов. Это делается путем добавления в конец строки определения 
  секции спецификатора <font color="#000099">ALIGN</font>. Например, строка 
<p><pre>
          section .data align=16
</pre>
<p>переключается на секцию <font color="#000099">.data</font> и также указывает, 
  что эта секция должна быть выровнена в памяти по границе параграфа. 
<p>Спецификатор <font color="#000099">ALIGN</font> указывает, сколько младших 
  бит в начальном адресе секции должны быть установлены в ноль. Указываемое значение 
  выравнивания может быть любой степенью двойки. 
<h3><a name="section-6.2">6.2 <font color="#000099">obj</font>: Объектные файлы 
  OMF Microsoft</a></h3>
<p>Файлы формата <font color="#000099">obj</font> (исторически в NASM они называются 
  <font color="#000099">obj</font>, а не <font color="#000099">omf</font>), создаваемые 
  MASMом и TASMом, обычно "скармливаются" 16-битным DOS-компоновщикам, на выходе 
  которых получаются <font color="#000099">.EXE</font> файлы. Этот формат используется 
  также в OS/2. 
<p>Формат <font color="#000099">obj</font> предполагает расширение выходного файла 
  по умолчанию <font color="#000099">.obj</font>. 
<p><font color="#000099">obj</font> не является исключительно 16-битным форматом: 
  NASM полностью поддерживает 32-битные расширения этого формата. В частности, 
  32-битный <font color="#000099">obj</font> формат используется Win32-компиляторами 
  Borland, которые не применяют новый объектный формат <font color="#000099">win32</font> 
  от Майкрософт. 
<p>Формат <font color="#000099">obj</font> не определяет специальных имен сегментов: 
  вы можете называть ваши сегменты как угодно. Типичными именами сегментов <font color="#000099">obj</font> 
  формата обычно являются <font color="#000099">CODE, DATA</font> и <font color="#000099">BSS</font>. 
<p>Если в вашем исходном файле до явного указания директивы <font color="#000099">SEGMENT</font> 
  содержится код, NASM будет помещать его в собственный сегмент с именем <font color="#000099">__NASMDEFSEG</font>. 
<p>Когда вы определяете сегменты в <font color="#000099">obj</font> файле, NASM 
  воспринимает их имена как символы, поэтому вы можете легко получить адрес любого 
  определенного сегмента, например: 
<p>
<pre>
          segment data 
dvar:     dw 1234 
          segment code 
function: mov ax,data            ; получение сегментного адреса данных 
          mov ds,ax              ; и помещение его в DS 
          inc word [dvar]        ; теперь эта ссылка работает 
          ret
</pre>
<p>Формат <font color="#000099">obj</font> разрешает также использование операторов 
  <font color="#000099">SEG</font> и <font color="#000099">WRT</font>, поэтому 
  вы можете писать код, делающий что-то вроде 
<p>
<pre>
          extern foo 
          mov ax,seg foo         ; получение сегмента foo 
          mov ds,ax 
          mov ax,data            ; получение другого сегмента 
          mov es,ax 
          mov ax,[ds:foo]        ; это доступ к 'foo' 
          mov [es:foo wrt data],bx  ; так это делается
</pre>
<h4><a name="section-6.2.1">6.2.1 <font color="#000099">obj</font>-расширения 
  директивы <font color="#000099">SEGMENT</font> </a></h4>
<p>Выходной формат <font color="#000099">obj</font> расширяет директиву <font color="#000099">SEGMENT</font> 
  (или <font color="#000099">SECTION</font>), позволяя задавать различные характеристики 
  определяемого сегмента. Это делается путем добавления в конец строки определения 
  сегмента дополнительных спецификаторов. Например, 
<p><pre>
          segment code private align=16
</pre>
<p>определяет сегмент <font color="#000099">code</font>, объявляя его при этом 
  закрытым и требуя, чтобы код этого модуля был выровнен по границе параграфа. 
<p>Имеются следующие спецификаторы: 
<ul>
  <li><font color="#000099">PRIVATE, PUBLIC, COMMON</font> и <font color="#000099">STACK</font> 
    задают комбинацию характеристик сегмента. Сегменты <font color="#000099">PRIVATE</font> 
    не могут быть связаны компоновщиком с любыми другими; сегменты <font color="#000099">PUBLIC</font> 
    и <font color="#000099">STACK</font> на стадии компоновки объединяются; сегменты 
    <font color="#000099">COMMON</font> накладываются друг на друга, вместо того, 
    чтобы следовать друг за другом. 
  <li><font color="#000099">ALIGN</font> используется, как уже упоминалось, для 
    указания того, сколько младших бит в стартовом адресе сегмента должно быть 
    установлено в 0. Значение выравнивания может быть любой степенью двойки от 
    1 до 4096; реально поддерживаются только значения 1, 2, 4, 16, 256 и 4096, 
    поэтому если указать 8, оно будет округлено до 16, а 32, 64 и 128 будут округлены 
    до 256 и т.д. Имейте в виду, что выравнивание по 4096-битной границе является 
    PharLap-расширением формата и может не поддерживаться некоторыми компоновщиками. 
  <li><font color="#000099">CLASS</font> используется для указания класса сегмента; 
    этот спецификатор указывает компоновщику, что сегменты одного и того же класса 
    должны быть расположены в выходном файле рядом друг с другом. Имя класса может 
    быть любым словом, например <font color="#000099">CLASS=CODE</font>. 
  <li><font color="#000099">OVERLAY</font>, как и <font color="#000099">CLASS</font>, 
    имеет аргумент в виде произвольного слова и предоставляет компоновщику (способному 
    на это) оверлейную информацию. 
  <li>Сегменты могут быть объявлены как <font color="#000099">USE16</font> или 
    <font color="#000099">USE32</font>, что непосредственным образом влияет на 
    объектный файл, а также заставляет NASM при ассемблировании такого сегмента 
    переключаться на 16- или 32-битный режим соответственно. 
  <li>При создании объектных файлов OS/2 вы должны объявлять 32-битные сегменты 
    как <font color="#000099">FLAT</font>, при этом базовый сегмент по умолчанию 
    приписывается к специальной группе <font color="#000099">FLAT</font>, а также 
    определяет эту группу, если она еще не существует. 
  <li>Формат <font color="#000099">obj</font> позволяет также объявлять сегменты 
    с предопределенными абсолютными адресами, несмотря на то, что компоновщики 
    на данный момент не могут гибко использовать данную возможность; NASM все 
    же позволяет вам объявить сегмент наподобие <font color="#000099">SEGMENT 
    SCREEN ABSOLUTE=0xB800</font>, если он вам нужен. Ключевые слова <font color="#000099">ABSOLUTE</font> 
    и <font color="#000099">ALIGN</font> являются взаимоисключающими. 
</ul>
<p>Атрибуты сегмента по умолчанию в NASM &#151; это <i><font color="#000099">PUBLIC, 
  ALIGN=1, без класса, без оверлея и USE16</font></i>. 
<h4><a name="section-6.2.2">6.2.2 <font color="#000099">GROUP</font>: Определение 
  групп сегментов</a></h4>
<p>Формат <font color="#000099">obj</font> позволяет группировать сегменты, благодаря 
  чему для ссылки на все сегменты группы может использоваться один сегментный 
  регистр. NASM для этого поддерживает директиву <font color="#000099">GROUP</font>. 
  Вы можете написать: 
<p>
<pre>
          segment data 
               ; некоторые данные 
          segment bss 
               ; некоторые неинициализированные данные 
          group dgroup data bss
</pre>
<p>При ассемблировании этого кода будет создана группа <font color="#000099">dgroup</font>, 
  содержащая сегменты <font color="#000099">data</font> и <font color="#000099">bss</font>. 
  Как и в случае <font color="#000099">SEGMENT</font>, имя директивы <font color="#000099">GROUP</font> 
  определяется как символ, поэтому вы можете ссылаться на переменную <font color="#000099">var</font> 
  в сегменте <font color="#000099">data</font> как <font color="#000099">var wrt 
  data</font> или как <font color="#000099">var wrt dgroup</font>, в зависимости 
  от того, какое значение в данный момент находится в сегментном регистре. 
<p>Однако если вы ссылаетесь на var, объявленную в сегменте группы, NASM по умолчанию 
  предоставляет смещение относительно начала <i>группы</i>, а не <i>сегмента</i>. 
  Вследствие этого <font color="#000099">SEG var</font> также будет возвращать 
  базу группы, а не базу сегмента. 
<p>NASM позволяет сегменту являться частью более одной группы, однако при этом 
  он будет выдавать предупреждение. Переменные, объявленные в таком сегменте, 
  по умолчанию будут относиться к первой включающей данный сегмент группе. 
<p>Группа может не иметь ни одного сегмента; однако при этом вы можете делать 
  <font color="#000099">WRT</font> ссылки на группу, которая не содержит нужную 
  переменную. OS/2, например, определяет специальную группу <font color="#000099">FLAT</font> 
  без всяких сегментов. 
<h4><a name="section-6.2.3">6.2.3 <font color="#000099">UPPERCASE</font>: </a>Отключение 
  чувствительности к регистру</h4>
<p>В отличие от NASM, некоторые OMF компоновщики нечувствительны к регистру символов; 
  вследствие этого иногда полезно заставлять NASM генерировать объектные файлы 
  в одном регистре. Директива формата <font color="#000099">UPPERCASE</font> перед 
  записью в объектный файл переводит имена всех сегментов, групп и символов в 
  верхний регистр. В пределах исходного файла NASM остается регистро-чувствительным; 
  однако объектные файлы, если это необходимо, могут быть составлены целиком в 
  верхнем регистре. 
<p><font color="#000099">UPPERCASE</font> должна оставаться единственной в строке; 
  она не требует никаких параметров. 
<h4><a name="section-6.2.4">6.2.4 <font color="#000099">IMPORT</font>: Импортирование 
  символов из DLL</a></h4>
<p>Директива <font color="#000099">IMPORT</font> определяет символ, импортируемый 
  из DLL и используемый например для написания в NASM библиотеки импорта. При 
  использовании директивы <font color="#000099">IMPORT</font> вы должны объявить 
  символ как <font color="#000099">EXTERN</font>. 
<p>Директива <font color="#000099">IMPORT</font> требует указания двух параметров, 
  разделенных пробелом и являющихся соответственно именем импортируемого символа 
  и именем библиотеки, из которой он импортируется. Например: 
<p><pre>
          import WSAStartup wsock32.dll
</pre>
<p>Третьим (необязательным) параметром является имя, под которым импортируемый 
  символ известен в соответствующей библиотеке. Этот параметр применяется в том 
  случае, если вы хотите, чтобы имя символа, используемое внутри вашего кода, 
  не совпадало с именем того же символа в библиотеке. Например: 
<p><pre>
          import asyncsel wsock32.dll WSAAsyncSelect
</pre>
<h4><a name="section-6.2.5">6.2.5 <font color="#000099">EXPORT</font>: </a>Экспортирование 
  символов в DLL</h4>
<p>Директива <font color="#000099">EXPORT</font> определяет глобальный символ, 
  экспортируемый как DLL-символ в создаваемую DLL (если вы пишете DLL в NASM). 
  Чтобы использовать директиву <font color="#000099">EXPORT</font>, вы должны 
  объявить символ как <font color="#000099">GLOBAL</font>. 
<p><font color="#000099">EXPORT</font> требует один параметр, являющийся именем 
  экспортируемого символа (в том виде, в каком он определен в вашем исходном файле). 
  Необязательный второй параметр (отделенный пробелом от первого) представляет 
  собой <i>внешнее</i> имя символа: это имя, под которым данный символ будет известен 
  использующим эту DLL программам. Если это имя то же самое, что и внутреннее, 
  можете оставить второй параметр пустым. 
<p>Для определения атрибутов экспортируемого символа могут быть заданы дополнительные 
  параметры. Эти параметры, как и второй, отделяются друг от друга пробелами. 
  Если дополнительные параметры задаются, внешнее имя также должно указываться, 
  неважно, совпадает ли оно с внутренним или нет. Имеются следующие дополнительные 
  атрибуты: 
<ul>
  <li><font color="#000099">resident</font> указывает, что экспортируемое имя 
    должно быть оставлено системным загрузчиком резидентным. Это делается для 
    оптимизации часто используемых символом, импортируемых по имени. 
  <li><font color="#000099">nodata</font> указывает, что экспортируемый символ 
    является функцией, не использующей никаких неинициализированных данных. 
  <li><font color="#000099">parm=NNN</font>, где <font color="#000099">NNN</font> 
    целое, устанавливает число параметров-слов в случае, если символ является 
    вызовом-переходом между 32- и 16-битными сегментами. 
  <li>Атрибуты в виде числа указывают, что символ должен экспортироваться с идентификационным 
    номером (ординалом) и представляют собой собственно этот номер. 
</ul>
<p>Например: 
<p>
<pre>
          export myfunc 
          export myfunc TheRealMoreFormalLookingFunctionName 
          export myfunc myfunc 1234  ; экспортирование по ординалу 
          export myfunc myfunc resident parm=23 nodata
</pre>
<h4><a name="section-6.2.6">6.2.6 <font color="#000099">..start</font>: Определение 
  точки входа в программу</a></h4>
<p>OMF-компоновщики требуют, чтобы один из компонуемых объектных файлов определял 
  точку входа в программу (место, откуда начнется выполнение программы после загрузки). 
  Если этот файл ассемблируется при помощи NASM, вы можете указать точку входа 
  путем объявления в этом месте специального символа <font color="#000099">..start</font>. 
<h4><a name="section-6.2.7">6.2.7 <font color="#000099">obj</font>-расширения 
  директивы <font color="#000099">EXTERN</font> </a></h4>
<p>Если вы объявляете внешний символ директивой 
<p><pre>
          extern foo
</pre>
<p>то ссылки наподобие <font color="#000099">mov ax,foo</font> будут давать вам 
  смещение <font color="#000099">foo</font> относительно базы его предопределенного 
  сегмента (как задано в модуле, где определен <font color="#000099">foo</font>). 
  Таким образом, доступ к содержимому <font color="#000099">foo</font> вы будете 
  обычно осуществлять следующим образом 
<p>
<pre>          mov ax,seg foo         ; получение базы сегмента 
          mov es,ax              ; перемещение ее в ES 
          mov ax,[es:foo]        ; и использование смещения 'foo' от нее
</pre>
<p>Это получается немного громоздко, особенно если вы знаете, что внешний символ 
  будет доступен из данного сегмента или группы (например, <font color="#000099">dgroup</font>). 
  Так, если <font color="#000099">DS</font> уже содержит <font color="#000099">dgroup</font>, 
  вы можете написать 
<p><pre>
          mov ax,[foo wrt dgroup]
</pre>
<p>Однако необходимость каждый раз это печатать для получения доступа к <font color="#000099">foo</font> 
  очень утомительна; NASM позволяет вам объявить <font color="#000099">foo</font> 
  в альтернативной форме 
<p><pre>
          extern foo:wrt dgroup
</pre>
<p>Эта форма заставляет NASM делать вид, что базовым сегментом <font color="#000099">foo</font> 
  на самом деле является <font color="#000099">dgroup</font>; так, выражение <font color="#000099">seg 
  foo</font> теперь будет возвращать <font color="#000099">dgroup</font>, а выражение 
  <font color="#000099">foo</font> будет эквивалентно <font color="#000099">foo 
  wrt dgroup</font>. 
<p>Описанный WRT-механизм может быть использован для "проявления" внешних символов 
  по отношению к любой группе или сегменту в программе. Он также может быть применен 
  к общим переменным (см. <a href="#section-6.2.8">параграф 6.2.8</a> ниже).
<h4><a name="section-6.2.8">6.2.8 <font color="#000099">obj</font>-расширения 
  директивы <font color="#000099">COMMON</font> </a></h4>
<p>Формат <font color="#000099">obj</font> позволяет общим переменным быть как 
  ближними, так и дальними; NASM обеспечивает этот механизм при помощи следующего 
  синтаксиса: 
<p>
<pre>          common nearvar 2:near  ; 'nearvar' - ближняя переменная 
          common farvar 10:far   ; 'farvar' - дальняя переменная
</pre>
<p>Дальние общие переменные могут иметь размер больше 64 Кб, поэтому спецификация 
  OMF говорит, что они объявляются как число <i>элементов</i> данного размера. 
  Так, 10-байтная дальняя переменная должна быть объявлена как 10 однобайтных 
  элементов, 5 двухбайтных, 2 пятибайтных или 1 десятибайтный элемент. 
<p>Некоторые OMF-компоновщики при разрешении общих переменных, объявленных более 
  чем в одном модуле, требуют совпадения размеров элемента и переменной. Поэтому 
  NASM должен позволять задавать размер элемента дальних переменных. Он делает 
  это при помощи следующего синтаксиса: 
<p>
<pre>          common c_5by2 10:far 5 ; два пятибайтных элемента 
          common c_2by5 10:far 2 ; пять двухбайтных элементов
</pre>
<p>Если размер элемента не задан, он предполагается по умолчанию равным 1. Не 
  требуется также и явное указание ключевого слова <font color="#000099">FAR</font>, 
  так как только дальние общие переменные могут иметь размер элемента. Исходя 
  из этого, приведенные выше объявления будут эквивалентны следующим:
<p>
<pre>          common c_5by2 10:5     ; два пятибайтных элемента 
          common c_2by5 10:2     ; пять двухбайтных элементов
</pre>
<p>В дополнение ко всему вышесказанному, директива <font color="#000099">COMMON</font> 
  в <font color="#000099">obj</font> поддерживает также и спецификацию <font color="#000099">WRT</font>-умолчаний 
  наподобие тому, как это работает для <font color="#000099">EXTERN</font> (см. 
  <a href="#section-6.2.7">параграф 6.2.7</a>). Поэтому вы можете объявлять такие, 
  например, вещи: 
<p><pre>
          common foo 10:wrt dgroup 
          common bar 16:far 2:wrt data 
          common baz 24:wrt data:6
</pre>
<h3><a name="section-6.3">6.3 <font color="#000099">win32</font>: Объектные файлы 
  Win32 Microsoft</a></h3>
<p>Выходной формат <font color="#000099">win32</font> генерирует объектные файлы 
  Microsoft Win32, передаваемые обычно компоновщикам Microsoft. Заметьте, что 
  компиляторы Borland Win32 не используют этот формат, вместо него они используют 
  <font color="#000099">obj</font> (см. <a href="#section-6.2">параграф 6.2</a>). 
<p><font color="#000099">win32</font> подразумевает по умолчанию расширение выходного 
  объектного файла <font color="#000099">.obj</font>. 
<p>Имейте в виду, что хотя Майкрософт и утверждает, что объектные файлы Win32 
  следуют стандарту <font color="#000099">COFF</font>, объектные файлы, созданные 
  компиляторами Microsoft Win32, не совместимы с COFF-компоновщиками (например, 
  DJGPP) и наоборот. Это происходит из-за разницы во взглядах на семантику таблицы 
  перемещений. Для создания COFF-совместимых выходных файлов для <font color="#000099">DJGPP</font> 
  используйте выходной формат <font color="#000099">coff</font> NASMа; обратное 
  также справедливо &#151; файлы, полученные в объектном формате <font color="#000099">coff</font>, 
  не обрабатываются корректно компоновщиками Win32. 
<h4><a name="section-6.3.1">6.3.1 <font color="#000099">win32</font>-расширения 
  директивы <font color="#000099">SECTION</font> </a></h4>
<p>Как и формат <font color="#000099">obj</font>, <font color="#000099">win32</font> 
  позволяет вам указывать в строке с директивой <font color="#000099">SECTION</font> 
  дополнительную информацию, предназначенную для управления типом и свойствами 
  определяемой секции. Обычно тип секции и ее свойства для стандартных имен <font color="#000099">.text, 
  .data</font> и <font color="#000099">.bss</font> генерируются NASM автоматически, 
  но при помощи приведенных спецификаторов могут быть и переопределены. 
<p>Имеются следующие спецификаторы: 
<ul>
  <li><font color="#000099">code</font> или <font color="#000099">text</font> 
    (что эквивалентно) описывает секцию как секцию кода. При этом секция маркируется 
    как читаемая и выполняемая, но не записываемая; компоновщику указывается также, 
    что тип секции &#151; код. 
  <li><font color="#000099">data</font> и <font color="#000099">bss</font>, по 
    аналогии с <font color="#000099">code</font>, определяют секцию данных. Секция 
    данных маркируется как читаемая и записываемая, но не выполняемая. Спецификатор 
    <font color="#000099">data</font> объявляет секцию инициализированных данных, 
    в то время как спецификатор <font color="#000099">bss</font> &#151; неинициализированных. 
  <li><font color="#000099">info</font> описывает секцию как информационную, не 
    включаемую компоновщиком в исполнимый файл, но способную (например) передать 
    компоновщику информацию. Например, объявление info-секции с именем <font color="#000099">.drectve</font> 
    побуждает компоновщик интерпретировать ее содержание как опции командной строки. 
  <li><font color="#000099">align=</font> с последующим числом описывает требования 
    к выравниванию секции. Максимум, что вы можете задать &#151; 64: объектный 
    формат Win32 не имеет способа запросить выравнивание большее, чем это. Если 
    выравнивание явно не указано, для секций кода используется выравнивание по 
    параграфам, а для секций данных &#151; по двойным словам. Информационные секции 
    получают по умолчанию выравнивание в 1 байт (т.е. нет его), даже если значение 
    указано явно. 
</ul>
<p>Если вы не укажете ни одного описанного выше спецификатора, NASM принимает 
  следующие значения по умолчанию: 
<p><pre>
          section .text code align=16 
          section .data data align=4 
          section .bss bss align=4
</pre>
<p>Любые другие имена секций обрабатываются так же, как и <font color="#000099">.text</font>. 
<h3><a name="section-6.4">6.4 <font color="#000099">coff</font>: Общий формат 
  объектных файлов</a></h3>
<p>Выходной формат <font color="#000099">coff</font> создает COFF-объектные файлы, 
  обрабатываемые компоновщиком DJGPP. Этот формат предусматривает по умолчанию 
  расширение выходных файлов <font color="#000099">.o</font>. 
<p>Формат <font color="#000099">coff</font> поддерживает те же самые расширения 
  директивы <font color="#000099">SECTION</font>, что и <font color="#000099">win32</font>, 
  однако спецификатор <font color="#000099">align</font> и секция типа <font color="#000099">info</font> 
  не поддерживаются. 
<h3><a name="section-6.5">6.5 <font color="#000099">elf</font>: Объектные файлы 
  ELF Линукс</a></h3>
<p>Выходной формат elf генерирует объектные файлы <font color="#000099">ELF32</font> 
  (Executable and Linkable Format), используемые в Линукс. Этот формат использует 
  по умолчанию расширение <font color="#000099">.o</font> выходных файлов. 
<h4><a name="section-6.5.1">6.5.1 <font color="#000099">elf</font>-расширения 
  директивы <font color="#000099">SECTION</font> </a></h4>
<p>Как и формат <font color="#000099">obj</font>, <font color="#000099">elf</font> 
  позволяет вам указывать в строке с директивой <font color="#000099">SECTION</font> 
  дополнительную информацию, предназначенную для управления типом и свойствами 
  определяемой секции. Обычно тип секции и ее свойства для стандартных имен <font color="#000099">.text, 
  .data</font> и <font color="#000099">.bss</font> генерируются NASM автоматически, 
  но при помощи приведенных спецификаторов могут быть и переопределены. 
<p>Имеются следующие спецификаторы: 
<ul>
  <li><font color="#000099">alloc</font> описывает секцию, которая при запуске 
    программы загружается в память. <font color="#000099">noalloc</font> описывает 
    незагружаемые секции, такие как информационные или секции комментариев. 
  <li><font color="#000099">exec</font> описывает секцию, которая при запуске 
    программы может выполняться (разрешено ее выполнение). Секции <font color="#000099">noexec</font> 
    выполняться не могут. 
  <li><font color="#000099">write</font> описывает секцию, в которую после запуска 
    программы разрешается запись. В секции <font color="#000099">nowrite</font> 
    запись запрещена. 
  <li><font color="#000099">progbits</font> описывает секцию, явно сохраняемую 
    в объектном файле: обычно это секции кода и инициализированных данных. <font color="#000099">nobits</font> 
    описывает секции, не присутствующие в файле, такие как BSS (неинициализированных 
    данных). 
  <li><font color="#000099">align=</font> с последующим числом, как и <font color="#000099">obj</font>, 
    задает параметр выравнивания секции. 
</ul>
<p>Если вы не укажете ни одного описанного выше спецификатора, NASM принимает 
  следующие значения по умолчанию: 
<p><pre>
          section .text progbits alloc   exec nowrite align=16 
          section .data progbits alloc noexec   write align=4 
          section .bss    nobits alloc noexec   write align=4 
          section other progbits alloc noexec nowrite align=1
</pre>
<p>(Любые секции, не являющиеся <font color="#000099">.text, .data</font> или 
  <font color="#000099">.bss</font> обрабатываются так же, как и секция <font color="#000099">other</font>). 
<h4><a name="section-6.5.2">6.5.2 Позиционно-независимый код: Специальные символы 
  формата <font color="#000099">elf</font> и <font color="#000099">WRT</font></a></h4>
<p>Спецификация ELF содержит достаточное число возможностей написания позиционно-независимого 
  кода (PIC), благодаря которым разделяемые библиотеки ELF весьма гибкие. Однако 
  это также означает, что NASM должен быть способен генерировать разнообразные 
  замысловатые типы релокейшнов объектных ELF-файлов. 
<p>Так как ELF не поддерживает сегментные ссылки, оператор <font color="#000099">WRT</font> 
  для своей обычной цели не используется; вместо этого формат <font color="#000099">elf</font> 
  использует <font color="#000099">WRT</font> для других целей, а именно для специальных 
  PIC-типов перемещений. 
<p><font color="#000099">elf</font> определяет пять специальных символов, которые 
  вы можете использовать с правой стороны оператора <font color="#000099">WRT</font> 
  для получения PIC-типов перемещений. Это <font color="#000099">..gotpc, ..gotoff, 
  ..got, ..plt</font> и <font color="#000099">..sym</font>. Их функции описаны 
  ниже: 
<ul>
  <li>Ссылка на символ, помеченный как база глобальной таблицы смещений (GOT) 
    при помощи <font color="#000099">wrt ..gotpc</font>, будет в результате давать 
    расстояние от начала текущей секции до глобальной таблицы смещений. (Для ссылки 
    на <font color="#000099">GOT</font> используется обычно стандартный символ 
    <font color="#000099">_GLOBAL_OFFSET_TABLE_</font>). Таким образом, для получения 
    реального адреса GOT, вам необходимо прибавить к результату конструкцию <font color="#000099">$$</font>. 
  <li>Ссылка на определенную позицию в одной из ваших собственных секций при помощи 
    <font color="#000099">wrt ..gotoff</font> будет давать расстояние от начала 
    GOT до заданной позиции, поэтому прибавив это расстояние к адресу GOT, вы 
    получите реальный адрес нужной вам позиции. 
  <li>Ссылка на внешний или глобальный символ при помощи <font color="#000099">wrt 
    ..got</font> заставляет компоновщик построить элемент GOT, содержащий адрес 
    символа, поэтому ссылка дает расстояние от начала GOT до этого элемента. Таким 
    образом, прибавляя к полученной ссылке адрес GOT, вы получите адрес, по которому 
    содержится адрес символа. 
  <li>Ссылка на имя процедуры при помощи <font color="#000099">wrt ..plt</font> 
    заставляет компоновщик построить элемент таблицы компоновки процедуры (PLT) 
    и ссылка в результате дает адрес элемента PLT. Вы можете использовать это 
    обычно только в контексте создания относительных перемещений (т.е. цели для 
    <font color="#000099">CALL</font> или <font color="#000099">JMP</font>), так 
    как ELF абсолютно не имеет перемещаемых типов для ссылки на элементы PLT. 
  <li>Ссылка на имя символа при помощи <font color="#000099">wrt ..sym</font> 
    заставляет NASM записать обычное перемещение, однако вместо того, чтобы сделать 
    перемещение относительным к началу секции и затем добавить смещение символа, 
    он создаст запись смещения непосредственно к запрашиваемому символу. Различие 
    необходимо из-за особенностей динамического компоновщика. 
</ul>
<p>Более полное объяснение использования типов перемещений для написания в NASM 
  разделяемых библиотек дано в <a href="nasm_ru8.html#section-8.2">параграфе 8.2</a>. 
<h4><a name="section-6.5.3">6.5.3 <font color="#000099">elf</font>-расширения 
  директивы <font color="#000099">GLOBAL</font> </a></h4>
<p>Объектные файлы ELF могут содержать больше информации о глобальном символе, 
  чем просто его адрес: они могут содержать размер символа, а также его тип. Это 
  сделано не только для удобства при отладке, это просто необходимо, если программа 
  пишется в виде разделяемой библиотеки. Для задания дополнительной информации 
  NASM поддерживает некоторые расширения директивы <font color="#000099">GLOBAL</font>. 
<p>Поставив после имени глобальной переменной двоеточие и написав <font color="#000099">function</font> 
  или <font color="#000099">data</font> (<font color="#000099">object</font> является 
  синонимом <font color="#000099">data</font>), вы можете указать, чем является 
  глобальная переменная &#151; функцией или объектом данных. Например, строка 
<p><pre>
          global hashlookup:function, hashtable:data
</pre>
<p>экспортирует глобальный символ <font color="#000099">hashlookup</font> как 
  функцию, а <font color="#000099">hashtable</font> &#151; как объект данных. 
<p>После ввода спецификатора вы можете также указать в виде числового выражения 
  (которое может включать метки и даже опережающие ссылки) размер ассоциированных 
  с символом данных, например: 
<p>
<pre>
          global hashtable:data (hashtable.end - hashtable) 
hashtable: 
          db this,that,theother  ; здесь некоторые данные 
.end:
</pre>
<p>Это заставит NASM автоматически подсчитать длину таблицы и поместить эту информацию 
  в символьную таблицу ELF. 
<p>Объявление типа и размера глобальных символов требуется при написании разделяемых 
  библиотек. Дополнительную информацию вы можете найти в <a href="nasm_ru8.html#section-8.2.4">параграфе 
  8.2.4</a>. 
<h4><a name="section-6.5.4">6.5.4 <font color="#000099">elf</font>-расширение 
  директивы <font color="#000099">COMMON</font> </a></h4>
<p>ELF позволяет задавать требования к выравниванию общих переменных. Это делается 
  путем помещения числа (которое должно быть степенью двойки) после имени и размера 
  общей переменной и отделения этого числа (как обычно) двоеточием. Например, 
  массив двойных слов, который должен быть выровнен по двойным словам: 
<p><pre>
          common dwordarray 128:4
</pre>
<p>Эта строка объявляет массив размером 128 байт и требует, чтобы он был выровнен 
  по 4-байтной границе. 
<h3><a name="section-6.6">6.6 <font color="#000099">aout</font>: Объектные файлы 
  <font color="#000099">a.out</font> Линукс</a></h3>
<p>Формат <font color="#000099">aout</font> генерирует объектные файлы <font color="#000099">a.out</font> 
  в форме, используемой устаревшими Линукс системами. (Он отличается от других 
  объектных файлов <font color="#000099">a.out</font> магическим числом в первых 
  четырех байтах файла. Также некоторые реализации <font color="#000099">a.out</font>, 
  например NetBSD, поддерживают позиционно-независимый код, который реализация 
  Линукс не знает). 
<p>Формат <font color="#000099">a.out</font> подразумевает расширение выходных 
  файлов по умолчанию <font color="#000099">.o</font>. 
<p>Этот формат очень простой. Он не поддерживает специальных директив и символов, 
  не использует <font color="#000099">SEG</font> или <font color="#000099">WRT</font> 
  и в нем нет расширений никаких стандартных директив. Он поддерживает только 
  три стандартных секции с именами <font color="#000099">.text, .data</font> и 
  <font color="#000099">.bss</font>. 
<h3><a name="section-6.7">6.7 <font color="#000099">aoutb</font>: Объектные файлы 
  <font color="#000099">a.out</font> NetBSD/FreeBSD/OpenBSD </a></h3>
<p>Формат <font color="#000099">aoutb</font> генерирует объектные файлы <font color="#000099">a.out</font> 
  в форме, используемой различными BSD-клонами UNIX: NetBSD, FreeBSD и OpenBSD. 
  Для большинства объектных файлов этот формат не отличается от <font color="#000099">aout</font> 
  за исключением магического числа в первых четырех байтах файла. Однако формат 
  поддерживает (как и формат <font color="#000099">elf</font>) позиционно-независимый 
  код, поэтому вы можете использовать его для написания разделяемых библиотек 
  BSD. 
<p>Расширение объектных файлов формата <font color="#000099">aoutb</font> по умолчанию 
  <font color="#000099">.o</font>. 
<p>Формат не поддерживает специальных директив и символов и имеет только три стандартных 
  секции с именами <font color="#000099">.text, .data</font> и <font color="#000099">.bss</font>. 
  Несмотря на это, для обеспечения типов перемещений в позиционно-независимом 
  коде он поддерживает использование <font color="#000099">WRT</font> так же, 
  как это делает <font color="#000099">elf</font>. Более подробно это описано 
  в <a href="#section-6.5.2">параграфе 6.5.2</a>. 
<p><font color="#000099">aoutb</font>, как и <font color="#000099">elf</font> 
  поддерживает также расширение директивы <font color="#000099">GLOBAL</font>: 
  см. <a href="#section-6.5.3">параграф 6.5.3</a>. 
<h3><a name="section-6.8">6.8 <font color="#000099">as86</font>: Объектные файлы 
  as86 Линукс</a></h3>
<p>16-битный ассемблер Линукс <font color="#000099">as86</font> имеет свой собственный 
  нестандартный формат объектных файлов. Хотя его компаньон компоновщик <font color="#000099">ld86</font> 
  выдает что-то близкое к обычным бинарникам <font color="#000099">a.out</font>, 
  объектный формат, используемый для взаимодействия между <font color="#000099">as86</font> 
  и <font color="#000099">ld86</font>, все же не является <font color="#000099">a.out</font>. 
<p>NASM на всякий случай поддерживает данный формат как <font color="#000099">as86</font>. 
  Расширение выходного файла по умолчанию для данного формата <font color="#000099">.o</font>. 
<p>Формат <font color="#000099">as86</font> &#151; это очень простой объектный 
  формат (с точки зрения NASM). Он не поддерживает специальных директив и символов, 
  не использует <font color="#000099">SEG</font> и <font color="#000099">WRT</font>, 
  и в нем нет никаких расширений стандартных директив. Он поддерживает только 
  три стандартных секции с именами <font color="#000099">.text, .data</font> и 
  <font color="#000099">.bss</font>. 
<h3><a name="section-6.9">6.9 <font color="#000099">rdf</font>: Перемещаемые динамические 
  объектные файлы</a></h3>
<p>Выходной формат <font color="#000099">rdf</font> создает объектные файлы RDOFF. 
  RDOFF &#151; это "доморощенный" формат объектных файлов, разработанный вместе 
  с NASM и отражающий в себе внутреннюю структуру ассемблера. 
<p>RDOFF не используется никакими широко известными операционными системами. Однако 
  тот, кто пишет собственную систему, возможно захочет использовать его в качестве 
  собственного объектного формата, так как разработан он прежде всего для упрощения 
  и содержит очень мало бюрократии в заголовках файлов. 
<p>Архив Unix NASM и архив DOS с исходниками имеют подкаталог <font color="#000099">rdoff</font>, 
  содержащий набор RDOFF-утилит: RDF-компоновщик, менеджер статических библиотек, 
  утилита, делающая дамп RDF-файла, и программа, загружающая и выполняющая RDF-исполнимый 
  файл под Линукс. 
<p>Формат <font color="#000099">rdf</font> поддерживает только стандартные секции 
  с именами <font color="#000099">.text, .data</font> и <font color="#000099">.bss</font>. 
<h4><a name="section-6.9.1">6.9.1 Требование библиотеки: Директива <font color="#000099">LIBRARY</font> 
  </a></h4>
<p>RDOFF содержит механизм "требования библиотеки", которая будет связана с модулем 
  как во время загрузки, так и при выполнении. Это осуществляется директивой <font color="#000099">LIBRARY</font>, 
  которая принимает один аргумент, являющийся именем модуля: 
<p><pre>
          library mylib.rdl
</pre>
<h3><a name="section-6.10">6.10 <font color="#000099">dbg</font>: Формат для отладки</a></h3>
<p>Выходной <font color="#000099">dbg</font> формат в конфигурации NASM по умолчанию 
  отсутствует. Если вы строите собственный исполнимый файл NASM из исходников, 
  то можете для включения этого формата определить символ <font color="#000099">OF_DBG</font> 
  в файле <font color="#000099">outform.h</font> или командной строке компилятора. 
<p>Формат <font color="#000099">dbg</font> не создает объектных файлов как таковых; 
  вместо этого он создает текстовый файл, содержащий полный список всех транзакций 
  между ядром NASM и модулем выходных форматов. Это обычно нужно людям, намеревающимся 
  написать собственные выходные драйвера и которые благодаря этому формату могут 
  получить картину различных запросов основной программы к выходному драйверу 
  и увидеть, в каком порядке они осуществляются. 
<p>Для простых файлов можно использовать <font color="#000099">dbg</font> формат 
  так: 
<p><pre>
nasm -f dbg filename.asm
</pre>
<p>в результате чего генерируется диагностический файл <font color="#000099">filename.dbg</font>. 
  Однако это не будет работать на файлах, разработанных под различные объектные 
  форматы, так как каждый формат определяет собственные макросы (обычно пользовательские 
  формы директив), не определенные в формате <font color="#000099">dbg</font>. 
  Поэтому здесь необходимо запускать NASM дважды, с препроцессированием выбранного 
  объектного формата: 
<p><pre>
nasm -e -f rdf -o rdfprog.i rdfprog.asm 
nasm -a -f dbg rdfprog.i
</pre>
<p>Здесь <font color="#000099">rdfprog.asm</font> препроцессируется в <font color="#000099">rdfprog.i</font>, 
  оставляя при этом выбранным объектный формат <font color="#000099">rdf</font>. 
  Это нужно, чтобы специальные директивы RDF правильно конвертировались в примитивную 
  форму. Затем препроцессированный исходный файл обрабатывается в формате <font color="#000099">dbg</font> 
  и при этом генерируется окончательный диагностический файл. 
<p>Такой обходной путь обычно не будет работать с программами, предназначенными 
  для формата <font color="#000099">obj</font>, так как директивы <font color="#000099">SEGMENT</font> 
  и <font color="#000099">GROUP</font> последнего имеют побочные эффекты определения 
  имен сегментов и групп как символов; <font color="#000099">dbg</font> этого 
  не делает, поэтому программа ассемблироваться не будет. Если вам позарез нужно 
  получить dbg-трассировку исходников, написанных для <font color="#000099">obj</font>, 
  вы можете обойти это, определив символы самостоятельно (например, при помощи 
  <font color="#000099">EXTERN</font>). 
<p>Формат <font color="#000099">dbg</font> принимает любые имена секций и любые 
  директивы, протоколируя все их в свой выходной файл. 
<p align=center><a href="nasm_ru7.html">Следующая глава</a> | <a href="nasm_ru5.html">Предыдущая 
  глава </a> | <a href="contents.html">Содержание</a> | Указатель
<hr noshade size=1>
<b><a href="http://www.opennet.ru/docs/">Архив документации на OpenNet.ru</a>
</body></html>
