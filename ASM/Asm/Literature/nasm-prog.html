<html><head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r"><title>Руководство по ассемблеру NASM</title>

<META NAME="GENERATOR" CONTENT="Super-Puper-Mega-Proga">
</head>
<body bgcolor="#DDE1C2">
<!--#include virtual="/header.raw"-->
<h3>Версия для печати</h3>
<b><a href="http://www.opennet.ru/docs/">Архив документации на OpenNet.ru</a> / 
Раздел "<a href="http://www.opennet.ru/docs/124.shtml">Программирование, языки</a>"
</b>
 <small>(<a href="./">Многостраничная версия</a>)</small>
<hr noshade size=1>

<a name="index_html"></a>
<h1 align=center>Расширенный ассемблер: NASM</h1>

<p><font face="Verdana, Arial, Helvetica" size="-1" color="#666666">Перевод: 
<a href="http://asmdev.narod.ru/asmos.html">AsmOs 
  group</a>, &copy; 2001 </font> 
<br>Оригинал: <a href="http://asmdev.narod.ru/asmos/our_files/docs/nasm.koi.rar">asmdev.narod.ru</a>
<p>Данное руководство 
  описывает NASM, расширенный ассемблер, предназначенный для написания программ 
  процессоров серии Intel x86, способный в то же время работать на разных платформах. 
  </p>
<h3><a href="#nasm_ru1_html">Глава 1. Введение</a></h3>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td> 
      <p>&nbsp;</p>
    </td>
    <td width="96%"><a href="#nasm_ru1_html_section_1_1">1.1. 
      Что такое NASM?</a> </td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr>
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_ru1_html_section_1_1_1">1.1.1. 
      Зачем еще один ассемблер?</a><br>
      <a href="#nasm_ru1_html_section_1_1_2">1.1.2. Условия лицензирования</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr>
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru1_html_section_1_2">1.2. 
      Контакты</a><br>
      <a href="#nasm_ru1_html_section_1_3">1.3. Инсталляция</a> </td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_ru1_html_section_1_3_1">1.3.1. 
      Инсталляция NASM под MS-DOS или Windows</a><br>
      <a href="#nasm_ru1_html_section_1_3_2">1.3.2. Инсталляция NASM под Unix</a></td>
  </tr>
</table>
<h3><a href="#nasm_ru2_html">Глава 2. Запуск NASM</a> </h3>
<table width="95%" border="0" cellpadding="2" cellspacing="0">
  <tr> 
    <td> 
      <p>&nbsp;</p>
    </td>
    <td width="96%"><a href="#nasm_ru2_html_section_2_1">2.1. 
      Синтаксис командной строки NASM</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr>
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_ru2_html_section_2_1_1">2.1.1. 
      Ключ -o. Указание имени выходного файла</a><br>
      <a href="#nasm_ru2_html_section_2_1_2"> 2.1.2. Ключ -f. Указание формата выходного 
      файла</a><br>
      <a href="#nasm_ru2_html_section_2_1_3"> 2.1.3. Ключ -l. Генерация файла-листинга</a><br>
      <a href="#nasm_ru2_html_section_2_1_4"> 2.1.4. Ключ -E. Перенаправление ошибок 
      в файл</a><br>
      <a href="#nasm_ru2_html_section_2_1_5"> 2.1.5. Ключ -s. Перенаправление ошибок 
      в stdout</a><br>
      <a href="#nasm_ru2_html_section_2_1_6"> 2.1.6. Ключ -i. Каталоги поиска включаемых 
      файлов</a><br>
      <a href="#nasm_ru2_html_section_2_1_7"> 2.1.7. Ключ -p. Предварительно включаемые 
      файлы</a><br>
      <a href="#nasm_ru2_html_section_2_1_8"> 2.1.8. Ключ -d. Предопределенные макросы</a><br>
      <a href="#nasm_ru2_html_section_2_1_9"> 2.1.9. Ключ -u. Отмена определения 
      макроса</a><br>
      <a href="#nasm_ru2_html_section_2_1_10"> 2.1.10. Ключ -e. Только препроцессирование</a><br>
      <a href="#nasm_ru2_html_section_2_1_11"> 2.1.11. Ключ -a. Отключение препроцессора</a><br>
      <a href="#nasm_ru2_html_section_2_1_12"> 2.1.12. Ключ -w. Разрешение/Запрещение 
      предупреждений при ассемблировании</a><br>
      <a href="#nasm_ru2_html_section_2_1_13"> 2.1.13. Переменная окружения NASM</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr>
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru2_html_section_2_2">2.2. 
      Пользователям MASM: Отличия</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr>
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_ru2_html_section_2_2_1">2.2.1. 
      NASM чувствителен к регистру символов</a><br>
      <a href="#nasm_ru2_html_section_2_2_2"> 2.2.2. NASM требует квадратные скобки 
      для ссылок на память</a><br>
      <a href="#nasm_ru2_html_section_2_2_3"> 2.2.3. NASM не хранит типы переменных</a><br>
      <a href="#nasm_ru2_html_section_2_2_4"> 2.2.4. NASM не поддерживает ASSUME</a> 
      <br>
      <a href="#nasm_ru2_html_section_2_2_5">2.2.5. NASM не поддерживает модели 
      памяти</a><br>
      <a href="#nasm_ru2_html_section_2_2_6"> 2.2.6. Различия в обработке чисел 
      с плавающей точкой</a><br>
      <a href="#nasm_ru2_html_section_2_2_7"> 2.2.7. Прочие различия</a></td>
  </tr>
</table>
<h3><a href="#nasm_ru3_html">Глава 3. Язык NASM</a></h3>
<table width="95%" border="0" cellpadding="2" cellspacing="0">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru3_html_section_3_1">3.1. 
      Обзор ассемблерной строки NASM</a><br>
      <a href="#nasm_ru3_html_section_3_2"> 3.2. Псевдо-инструкции</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr>
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_ru3_html_section_3_2_1">3.2.1. 
      DB и его друзья: Объявление инициализированных данных</a><br>
      <a href="#nasm_ru3_html_section_3_2_2"> 3.2.2. RESB и его друзья: Объявление 
      не инициализированных данных</a><br>
      <a href="#nasm_ru3_html_section_3_2_3"> 3.2.3. INCBIN: Включение внешних бинарных 
      файлов</a><br>
      <a href="#nasm_ru3_html_section_3_2_4"> 3.2.4. EQU: Определение констант</a><br>
      <a href="#nasm_ru3_html_section_3_2_5"> 3.2.5. TIMES: Повторение инструкций 
      или данных</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr>
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru3_html_section_3_3">3.3. 
      Эффективные адреса</a><br>
      <a href="#nasm_ru3_html_section_3_4"> 3.4. Константы</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr>
    <td >&nbsp;</td>
    <td width="92%"><a href="#nasm_ru3_html_section_3_4_1">3.4.1. 
      Числовые константы</a><br>
      <a href="#nasm_ru3_html_section_3_4_2"> 3.4.2. Символьные константы</a><br>
      <a href="#nasm_ru3_html_section_3_4_3"> 3.4.3. Строковые константы</a><br>
      <a href="#nasm_ru3_html_section_3_4_4"> 3.4.4. Константы с плавающей точкой</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr>
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru3_html_section_3_5">3.5. 
      Выражения</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr>
    <td >&nbsp;</td>
    <td width="92%"><a href="#nasm_ru3_html_section_3_5_1">3.5.1. 
      |: Побитовый оператор ИЛИ</a><br>
      <a href="#nasm_ru3_html_section_3_5_2"> 3.5.2. ^: Побитовый оператор ИСКЛЮЧАЮЩЕЕ 
      ИЛИ</a><br>
      <a href="#nasm_ru3_html_section_3_5_3"> 3.5.3. &amp;: Побитовый оператор И</a><br>
      <a href="#nasm_ru3_html_section_3_5_4"> 3.5.4. &lt;&lt; и &gt;&gt;: Операторы 
      сдвига бит</a><br>
      <a href="#nasm_ru3_html_section_3_5_5"> 3.5.5. + и -: Операторы сложения и 
      вычитания</a><br>
      <a href="#nasm_ru3_html_section_3_5_6"> 3.5.6. *, /, //, % и %%: Умножение 
      и деление</a><br>
      <a href="#nasm_ru3_html_section_3_5_7"> 3.5.7. Унарные операторы: +, -, ~ 
      и SEG</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr>
    <td >&nbsp;</td>
    <td width="96%"><a href="#nasm_ru3_html_section_3_6">3.6. 
      SEG и WRT</a><br>
      <a href="#nasm_ru3_html_section_3_7"> 3.7. Критические выражения</a><br>
      <a href="#nasm_ru3_html_section_3_8"> 3.8. Локальные метки</a> </td>
  </tr>
</table>
<h3><a href="#nasm_ru4_html">Глава 4. Препроцессор NASM</a> </h3>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru4_html_section_4_1">4.1. 
      Однострочные макросы</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_ru4_html_section_4_1_1">4.1.1. 
      Обычный способ: %define</a><br>
      <a href="#nasm_ru4_html_section_4_1_2"> 4.1.2. Однострочные макросы раннего 
      связывания: %xdefine</a><br>
      <a href="#nasm_ru4_html_section_4_1_3"> 4.1.3. Отмена определения макроса: 
      %undef</a><br>
      <a href="#nasm_ru4_html_section_4_1_4"> 4.1.4. Переменные препроцессора: %assign</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru4_html_section_4_2">4.2. 
      Многострочные макросы: %macro</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_ru4_html_section_4_2_1">4.2.1. 
      Перегрузка многострочных макросов</a><br>
      <a href="#nasm_ru4_html_section_4_2_2"> 4.2.2. Локальные метки в макросах</a><br>
      <a href="#nasm_ru4_html_section_4_2_3"> 4.2.3. Поглощающие параметры макросов</a><br>
      <a href="#nasm_ru4_html_section_4_2_4"> 4.2.4. Параметры макросов по умолчанию</a><br>
      <a href="#nasm_ru4_html_section_4_2_5"> 4.2.5. %0: Счетчик параметров</a><br>
      <a href="#nasm_ru4_html_section_4_2_6"> 4.2.6. %rotate: "Вращение" параметров 
      макросов</a><br>
      <a href="#nasm_ru4_html_section_4_2_7"> 4.2.7. Объединение параметров макросов</a><br>
      <a href="#nasm_ru4_html_section_4_2_8"> 4.2.8. Коды условий в качестве параметров 
      макросов</a><br>
      <a href="#nasm_ru4_html_section_4_2_9"> 4.2.9. Подавление развертывания макросов 
      в листинге</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru4_html_section_4_3">4.3. 
      Условное ассемблирование</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_ru4_html_section_4_3_1">4.3.1. 
      %ifdef: Проверка присутствия однострочного макроса</a><br>
      <a href="#nasm_ru4_html_section_4_3_2"> 4.3.2. %ifctx: Проверка контекстного 
      стека</a><br>
      <a href="#nasm_ru4_html_section_4_3_3"> 4.3.3. %if: Проверка произвольных 
      числовых выражений</a><br>
      <a href="#nasm_ru4_html_section_4_3_4"> 4.3.4. %ifidn и %ifidni: Проверка 
      на идентичность текста</a><br>
      <a href="#nasm_ru4_html_section_4_3_5"> 4.3.5. %ifid, %ifnum, %ifstr: Проверка 
      типов символов</a><br>
      <a href="#nasm_ru4_html_section_4_3_6"> 4.3.6. %error: Сообщения об ошибках, 
      определяемые пользователем</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru4_html_section_4_4">4.4. 
      Циклы препроцессора: %rep</a><br>
      <a href="#nasm_ru4_html_section_4_5"> 4.5. Подключение других файлов</a><br>
      <a href="#nasm_ru4_html_section_4_6"> 4.6. Контекстный стек</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_ru4_html_section_4_6_1">4.6.1. 
      %push и %pop: Создание и удаление контекста</a><br>
      <a href="#nasm_ru4_html_section_4_6_2"> 4.6.2. Контектно-локальные метки</a><br>
      <a href="#nasm_ru4_html_section_4_6_3"> 4.6.3. Контекстно-локальные однострочные 
      макросы</a><br>
      <a href="#nasm_ru4_html_section_4_6_4"> 4.6.4. %repl: Переименование контекста</a><br>
      <a href="#nasm_ru4_html_section_4_6_5"> 4.6.5. Пример использования контекстного 
      стека: Блок IF</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru4_html_section_4_7">4.7. 
      Стандартные макросы</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_ru4_html_section_4_7_1">4.7.1. 
      __NASM_MAJOR__ и __NASM_MINOR__: Версия NASM</a><br>
      <a href="#nasm_ru4_html_section_4_7_2"> 4.7.2. __FILE__ и __LINE__: Имя файла 
      и номер строки</a><br>
      <a href="#nasm_ru4_html_section_4_7_3"> 4.7.3. STRUC и ENDSTRUC: Объявление 
      структурных типов данных</a><br>
      <a href="#nasm_ru4_html_section_4_7_4"> 4.7.4. ISTRUC, AT и IEND: Объявление 
      экземпляров структур</a><br>
      <a href="#nasm_ru4_html_section_4_7_5"> 4.7.5. ALIGN и ALIGNB: Выравнивание 
      данных</a> </td>
  </tr>
</table>
<h3><a href="#nasm_ru4_html_section_4_1_4"></a> <a href="#nasm_ru5_html">Глава 5. 
  Директивы ассемблера</a> </h3>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru5_html_section_5_1">5.1. 
      BITS: Указание разрядности выполняемого кода</a><br>
      <a href="#nasm_ru5_html_section_5_2"> 5.2. SECTION или SEGMENT: Изменение 
      и описание секций</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_ru5_html_section_5_2_1">5.2.1. 
      Макрос __SECT__</a> </td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru5_html_section_5_3">5.3. 
      ABSOLUTE: Определение абсолютных меток</a><br>
      <a href="#nasm_ru5_html_section_5_4"> 5.4. EXTERN: Импорт символов из других 
      модулей</a><br>
      <a href="#nasm_ru5_html_section_5_5"> 5.5. GLOBAL: Экспорт символов в другие 
      модули</a><br>
      <a href="#nasm_ru5_html_section_5_6"> 5.6. COMMON: Определение общих данных</a> 
      </td>
  </tr>
</table>
<h3><a href="#nasm_ru6_html">Глава 6. Выходные форматы</a> </h3>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru6_html_section_6_1">6.1. 
      bin: Плоский бинарный формат</a> </td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_ru6_html_section_6_1_1">6.1.1. 
      ORG: Начало бинарного файла</a><br>
      <a href="#nasm_ru6_html_section_6_1_2"> 6.1.2. bin-расширение директивы SECTION 
      </a> </td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru6_html_section_6_2">6.2. 
      obj: Объектные файлы OMF Microsoft</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_ru6_html_section_6_2_1">6.2.1. 
      obj-расширения директивы SEGMENT </a><br>
      <a href="#nasm_ru6_html_section_6_2_2"> 6.2.2. GROUP: Определение групп сегментов</a><br>
      <a href="#nasm_ru6_html_section_6_2_3"> 6.2.3. UPPERCASE: Отключение чувствительности 
      к регистру</a><br>
      <a href="#nasm_ru6_html_section_6_2_4"> 6.2.4. IMPORT: Импортирование символов 
      из DLL</a><br>
      <a href="#nasm_ru6_html_section_6_2_5"> 6.2.5. EXPORT: Экспортирование символов 
      в DLL</a><br>
      <a href="#nasm_ru6_html_section_6_2_6"> 6.2.6. ..start: Определение точки 
      входа в программу</a><br>
      <a href="#nasm_ru6_html_section_6_2_7"> 6.2.7. obj-расширения директивы EXTERN 
      </a><br>
      <a href="#nasm_ru6_html_section_6_2_8"> 6.2.8. obj-расширения директивы COMMON 
      </a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru6_html_section_6_3">6.3. 
      win32: Объектные файлы Win32 Майкрософт</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_ru6_html_section_6_3_1">6.3.1. 
      win32-расширения директивы SECTION </a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru6_html_section_6_4">6.4. 
      coff: Общий формат объектных файлов</a><br>
      <a href="#nasm_ru6_html_section_6_5"> 6.5. elf: Объектные файлы ELF Линукс</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_ru6_html_section_6_5_1">6.5.1. 
      elf-расширения директивы SECTION </a><br>
      <a href="#nasm_ru6_html_section_6_5_2"> 6.5.2. Позиционно-независимый код: 
      Специальные символы формата elf и WRT</a><br>
      <a href="#nasm_ru6_html_section_6_5_3"> 6.5.3. elf-расширения директивы GLOBAL 
      </a><br>
      <a href="#nasm_ru6_html_section_6_5_4"> 6.5.4. elf-расширение директивы COMMON</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru6_html_section_6_6">6.6. 
      aout: Объектные файлы a.out Линукс</a><br>
      <a href="#nasm_ru6_html_section_6_7"> 6.7. aoutb: Объектные файлы a.out NetBSD/FreeBSD/OpenBSD</a><br>
      <a href="#nasm_ru6_html_section_6_8"> 6.8. as86: Объектные файлы as86 Линукс</a><br>
      <a href="#nasm_ru6_html_section_6_9"> 6.9. rdf: Перемещаемые динамические 
      объектные файлы</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_ru6_html_section_6_9_1">6.9.1. 
      Требование библиотеки: Директива LIBRARY</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru6_html_section_6_10">6.10. 
      dbg: Формат для отладки</a></td>
  </tr>
</table>
<h3><a href="#nasm_ru7_html">Глава 7. Написание 16-битного кода (DOS, Windows 3/3.1)</a> 
</h3>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru7_html_section_7_1">7.1. 
      Получение .EXE файлов</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_ru7_html_section_7_1_1">7.1.1. 
      Использование формата obj для получения .EXE файлов</a><br>
      <a href="#nasm_ru7_html_section_7_1_2"> 7.1.2. Использование формата bin для 
      получения .EXE файлов</a> </td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru7_html_section_7_2">7.2. 
      Получение .COM файлов</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_ru7_html_section_7_2_1">7.2.1. 
      Использование формата bin для получения .COM файлов</a><br>
      <a href="#nasm_ru7_html_section_7_2_2"> 7.2.2. Использование формата obj для 
      получения .COM файлов</a> </td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru7_html_section_7_3">7.3. 
      Получение .SYS файлов</a><br>
      <a href="#nasm_ru7_html_section_7_4"> 7.4. Взаимодействие с 16-битными C-программами</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_ru7_html_section_7_4_1">7.4.1. 
      Внешние символьные имена</a><br>
      <a href="#nasm_ru7_html_section_7_4_2"> 7.4.2. Модели памяти</a><br>
      <a href="#nasm_ru7_html_section_7_4_3"> 7.4.3. Определения и вызовы функций</a><br>
      <a href="#nasm_ru7_html_section_7_4_4"> 7.4.4. Доступ к элементам данных</a><br>
      <a href="#nasm_ru7_html_section_7_4_5"> 7.4.5. c16.mac: Макросы для 16-битного 
      C-интерфейса</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru7_html_section_7_5">7.5. 
      Взаимодействие с программами Borland Pascal</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_ru7_html_section_7_5_1">7.5.1. 
      Соглашение о вызовах в Pascal</a><br>
      <a href="#nasm_ru7_html_section_7_5_2"> 7.5.2. Ограничение имен сегментов 
      в Borland Pascal</a><br>
      <a href="#nasm_ru7_html_section_7_5_3"> 7.5.3. Использование c16.mac с Pascal-программами</a></td>
  </tr>
</table>
<h3><a href="#nasm_ru8_html">Глава 8. Написание 32-битного кода (Unix, Win32, DJGPP)</a> 
</h3>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru8_html_section_8_1">8.1. Интерфейс с 32-ух 
      битными программами на Си</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_ru8_html_section_8_1_1">8.1.1. 
      </a><a href="#nasm_ru7_html_section_7_4_1">Внешние 
      символьные имена</a><br>
      <a href="#nasm_ru8_html_section_8_1_2"> 8.1.2. </a><a href="#nasm_ru7_html_section_7_4_3">Определение 
      и вызов функций</a><br>
      <a href="#nasm_ru8_html_section_8_1_3"> 8.1.3. </a><a href="#nasm_ru7_html_section_7_4_4">Доступ 
      к переменным</a><br>
      <a href="#nasm_ru8_html_section_8_1_4"> 8.1.4. c32.mac: </a><a href="#nasm_ru7_html_section_7_4_5">Вспомогательные 
      макросы для 32-ух битного интерфейса с Си</a> </td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru8_html_section_8_2">8.2. Написание разделяемых 
      библиотек для NetBSD/FreeBSD/OpenBSD и Linux/ELF</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_ru8_html_section_8_2_1">8.2.1. Получение адреса 
      ГТС</a><br>
      <a href="#nasm_ru8_html_section_8_2_2"> 8.2.2. Нахождение ваших локальных 
      переменных </a><br>
      <a href="#nasm_ru8_html_section_8_2_3"> 8.2.3. Нахождение внешних и общих 
      переменных </a><br>
      <a href="#nasm_ru8_html_section_8_2_4"> 8.2.4. Экспортирование имен в библиотеку 
      пользователя </a><br>
      <a href="#nasm_ru8_html_section_8_2_5"> 8.2.5. Вызов процедур вне библиотеки</a><br>
      <a href="#nasm_ru8_html_section_8_2_6"> 8.2.6. Создание библиотечного файла</a></td>
  </tr>
</table>
<h3><a href="#nasm_ru9_html">Глава 9. Смешивание16- и 32-битного кода</a> </h3>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru9_html_section_9_1">9.1. Переходы между сегментами 
      смешанной разрядности</a><br>
      <a href="#nasm_ru9_html_section_9_2"> 9.2. Адресация между сегментами различной 
      разрядности </a><br>
      <a href="#nasm_ru9_html_section_9_3"> 9.3. Другие инструкции смешанного размера</a> 
    </td>
  </tr>
</table>
<h3><a href="#nasm_r1010_html">Глава 10. Разрешение проблем</a> </h3>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_r1010_html_section_10_1">10.1. 
      Общие проблемы</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_r1010_html_section_10_1_1">10.1.1. Генерация NASM 
      неэффективного кода</a><br>
      <a href="#nasm_r1010_html_section_10_1_2"> 10.1.2. Мои &quot;JUMPы&quot; вне 
      диапазона </a><br>
      <a href="#nasm_r1010_html_section_10_1_3"> 10.1.3. ORG не работает</a><br>
      <a href="#nasm_r1010_html_section_10_1_4"> 10.1.4. TIMES не работает</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_r1010_html_section_10_2">10.2. Дефекты (Ошибки)</a></td>
  </tr>
</table>
<h3> Указатель </h3>
<hr>

<a name="nasm_r10_html"></a>
<h1 align=center>Расширенный ассемблер: NASM</h1>

<p align=center>Приложение | <a href="#nasm_ru9_html">Предыдущая 
  глава</a> | <a href="#contents_html">Содержание</a> | Указатель
</p>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr> 
    <td width="69%"> 
      <h2><a name="nasm_r10_html_chapter-10">Глава 10: Разрешение проблем</a></h2>
    </td>
    <td width="31%"> 
      <div align="right"><font size="-1" color="#666666">Перевод: <a href="http://asmdev.narod.ru/asmos.html">
AsmOS group</a>, &copy; 2001</font></div>
    </td>
  </tr>
</table>
<p>Эта глава описывает некоторые из проблем, с которыми, насколько известно, обычно 
  сталкиваются пользователи NASM, и методы их преодоления. Также здесь описан 
  способ сообщения об ошибках NASM команде его разработчиков, в случае, если вы 
  столкнетесь с трудностями, не описанными в данной главе. 
<h3><a name="nasm_r10_html_section-10.1">10.1 Общие проблемы</a></h3>
<h4><a name="nasm_r10_html_section-10.1.1">10.1.1 Генерация NASM неэффективного кода</a></h4>
<p>Я получаю много сообщений об ошибках, в которых говорится, что NASM генерирует 
  неэффективный или неверный (при использовании инструкций типа <font color="#000099">ADD 
  ESP, 8</font>) код. Это преднамеренная особенность дизайна, связанная с предсказуемостью 
  вывода: видя инструкцию типа "<font color="#000099">ADD ESP, 8</font>", NASM 
  генерирует команду, оставляющую место для 32-битного смещения. Если вы хотите 
  использовать оптимизированную по размеру инструкцию, то должны использовать 
  "<font color="#000099">ADD ESP, BYTE 8</font>". Это не ошибка, это просто моя 
  точка зрения. 
<h4><a name="nasm_r10_html_section-10.1.2">10.1.2 Мои "JUMPы" вне диапазона</a></h4>
      <p>Также люди жалуются, что когда они используют переходы по условию (которые 
        являются типа <font color="#000099">SHORT</font> по умолчанию), которые 
        пытаются перейти слишком далеко, то NASM сообщает "<font color="#000099">SHORT 
        JUMP OUT OF RANGE</font>", вместо использования более длинного перехода. 
      <p>Это снова частичная проблема предсказуемости, имеющая также практическую 
        причину. NASM не имеет возможности узнать, для какого типа процессора 
        будет использоваться этот код, так что он не может решить сам использовать 
        переход типа NEAR, потому что не знает, что программа предназначается 
        для процессора 386 и выше. Аналогично, NASM может заменить инструкцию 
        <font color="#000099">JNE</font> типа <font color="#000099">SHORT</font>, 
        которая пыталась бы выйти за диапазон, на более короткую команду <font color="#000099">JE</font>, 
        использующей <font color="#000099">JUMP NEAR</font> &#151; это разумное 
        решение для процессоров ниже 386, но не эффективное для процессоров, имеющих 
        хорошее предсказание перехода и в состоянии осуществить <font color="#000099">JMP 
        NEAR</font>. Так что, повторяю &#151; это пользователю, а не ассемблеру 
        решать, какие команды должны быть сгенерированы. 
      <p>Люди, пишущие загрузочный сектор в двоичном формате, часто жалуются, 
        что <font color="#000099">ORG</font> работает не так, как им хотелось 
        бы: чтобы поместить сигнатуру <font color="#000099">0xAA55</font> в конец 
        512-ти байтного загрузочного сектора, те, кто привык к MASM, имеют тенденцию 
        делать следующее 
     <p> 
      <pre><font color="#666666">          ORG 0 
          ; код загрузчика 
          ORG 510 
          DW 0xAA55</font>
</pre>
     <p>В NASM <font color="#000099">ORG</font> не предназначена для этого. Правильный 
        способ заключается в использовании директивы <font color="#000099">TIMES</font>: 
     <pre><font color="#666666">          ORG 0 
          ; код загрузчика 
          TIMES 510-($-$$) DB 0 
          DW 0xAA55</font>
</pre>
     <p>Директива <font color="#000099">TIMES</font> вставит необходимое количество 
        нулей в код вплоть до 510-го байта. Еще одно преимущество этого метода 
        в том, что если вы выйдете за допустимые размеры загрузочного сектора, 
        то NASM перехватит эту ошибку еще во время ассемблирования и сообщит об 
        этом, так что вам не придется "доводить" программу дизассемблированием 
        и поиском ошибки. 
<h4><a name="nasm_r10_html_section-10.1.4">10.1.4 <font color="#000099">TIMES</font> не работает</a></h4>
      <p>Другая обычная проблема с вышеупомянутым кодом бывает у тех, кто пишет 
      <p> 
      <pre><font color="#666666">          TIMES 510-$ DB 0</font></pre>
      <p>полагая, что <font color="#000099">$</font> - это просто число (как и 
        510), и что разница тоже будет числом и эту разницу можно спокойно преподнести 
        <font color="#000099">TIMES</font>. 
     <p>NASM &#151; <i>модульный</i> ассемблер: различные составляющие части 
        разработаны так, чтобы их было легко повторно использовать по отдельности, 
        так что они не обмениваются информацией без необходимости. В последствии, 
        даже зная, что выходной двоичный формат имеет <font color="#000099">ORG 
        0</font> (и секция <font color="#000099">.text</font> будет начинаться 
        с <font color="#000099">0</font>), эта информация не поступит назад к 
        оценщику выражений. Так что, с точки зрения оценщика, <font color="#000099">$</font> 
        &#151; не просто число, а адрес, включающий смещение от базы (основы) 
        сегмента. Поэтому разница между <font color="#000099">$</font> и <font color="#000099">510</font> 
        тоже будет включать значение смещения от базы сегмента (<font color="#000099">0х1234:0х5678</font> 
        вместо <font color="#000099">0х5678</font>, например). Значение, включающее 
        смещение, нельзя передавать в качестве параметра директиве <font color="#000099">TIMES</font>. 
     <p>Решение можно увидеть в предыдущем примере: 
      <p> 
      <pre><font color="#666666">          TIMES 510-($-$$) DB 0</font></pre>
      <p>Здесь <font color="#000099">$</font> и <font color="#000099">$$</font> 
        содержат смещения относительно одного и того же сегмента, так что их разница 
        &#151; простое число. Это решит проблему и будет сгенерирован правильный 
        код. 

<h3><a name="nasm_r10_html_section-10.2">10.2 Дефекты (ошибки)</a></h3>
      <p>Мы пока еще не выпускали ни одной версии NASM с дефектами, о которых 
        мы <i>знаем</i>. Хотя это и не исключает наличия множества таких дефектов, 
        о которых мы просто не знаем. О любом, найденном вами, вы должны сообщить 
        по адресу <a href="mailto:hpa@zytor.com">hpa@zytor.com</a>. 
      <p>Прежде чем сообщать о дефекте, пожалуйста, внимательно прочитайте <a href="#nasm_ru2_html_section_2_2">параграф 
        2.2</a>, там перечислены преднамеренно созданные особенности, которые 
        можно принять за ошибки в NASM. (Если же что-то не описано там и кажется 
        вам ошибкой, то будем рады получить ваши подробные комментарии, а не просто 
        письмо типа "Это - ошибка"). После этого прочитайте <a href="#nasm_r10_html_section_10_1">параграф 
        10.1</a>, и не сообщайте об ошибке, если она уже там описана. 
      <p>Если вы создаете отчет об ошибке, <i>пожалуйста</i>, сообщите нам всю 
        нижеследующую информацию: 
      <ul>
        <li>Под какой ОС вы запускаете NASM: DOS, Linux, NetBSD, Win16, Win32, 
          VMS (я бы удивился :) ), какая-то еще. 
        <li>Если вы запустили NASM из-под DOS или Win32, то сообщите, какой из 
          компиляторов вы используете &#151; стандартный из дистрибутива или откомпилированный 
          вами. Если это "ваш" компилятор, то попробуйте воссоздать ошибку на 
          "родном" из дистрибутива. Эта информация поможет нам быстрее исправить 
          ошибку. 
        <li>Какую версию NASM вы используете и подробности того, как вы вызвали 
          сбой. Сообщите нам полностью командную строку и переменные окружения 
          NASM (если есть). 
        <li>Какие версии других программ вы используете и как вы их вызываете. 
          Если сбой возникает во время линковки, то сообщите версию и название 
          компоновщика, его командную строку. Если возникает проблема при линковке 
          с объектным файлом, созданным другим компилятором, то сообщите нам, 
          что за компилятор, версию и командную строку или опции, использованные 
          вами. (Если вы использовали IDE, то попробуйте воспользоваться версией 
          компилятора для командной строки). 
        <li>Если это возможно, то вышлите нам исходный файл, вызывающий ошибку. 
          Если же могут возникнуть проблемы связанные с авторским правом (например, 
          вы можете воспроизвести ошибку в отдельном файле проекта), тогда имейте 
          в виду следующее: во-первых, весь исходный код, высланный к нам, будет 
          использоваться <i>только</i> для обнаружения и исправления ошибки NASM, 
          и мы удалим все копии у себя; во-вторых, мы предпочли бы <i>не</i> получать 
          большие куски кода. Чем меньше файл &#151; тем лучше. Гораздо легче 
          работать с файлом из трех строчек кода, <i>показывающего</i> ошибку, 
          чем с полнофункциональной программой из десятков тысяч строк кода. (Конечно 
          же, некоторые ошибки могут возникнуть в <i>только</i> большем файле, 
          мы это понимаем). 
        <li>Точное описание смысла проблемы. Просто "Это не работает" <i>не</i> 
          сможет помочь! Пожалуйста, объясните точно - что вы хотели получить 
          и не получили (или наоборот - получили то, чего не должно было быть). 
          Например: "NASM показывает ошибку в 3-ей строке, а она в 5-ой"; "NASM 
          сообщает об ошибке, а я <i>уверен</i>, что ее нет"; "NASM не сообщил 
          об ошибке, которая точно есть"; "Объектный файл, созданный из этого 
          кода, не подходит моему компоновщику"; "Девятый байт выходного файла 
          равен 66, а я думаю, что должно быть 77". 
        <li>Если вы уверены, что выходной файл не верен, то пошлите его нам. Это 
          поможет нам определить, создаст ли наша собственная копия NASM такой 
          же файл или проблема в переносимости между нашей платформой разработки 
          и вашей. Мы можем принимать двоичные файлы в виде <font color="#000099">MIME</font>-прикреплений, 
          формате <font color="#000099">uuencode</font> и даже <font color="#000099">BinHex</font>. 
          Так же мы можем предоставить вам ftp-сайт, на который вы сможете загрузить 
          данный файл, но получить его по почте для нас было бы удобней. 
        <li>Любую другую информацию или файлы, которые могут быть полезны. Если, 
          например, проблема в том, что NASM не может сгенерировать объектный 
          файл, в то время, как TASM создает его без проблем, то пошлите нам <i>оба</i> 
          объектных файла, чтобы мы могли увидеть, что делает TASM в отличие от 
          NASM. 
      </ul>
<ul>
  <div align="center">Приложение | <a href="#nasm_ru9_html">Предыдущая 
    глава</a> | <a href="#contents_html">Содержание</a> | Указатель
  </div>
</ul>
<hr>

<a name="nasm_ru1_html"></a>
<h1 align=center>Расширенный ассемблер: NASM</h1>

<p align=center><a href="#nasm_ru2_html">Следующая глава</a> | <a href="#contents_html">Содержание</a> 
  | Указатель </p>
<table width="98%" border="0" cellspacing="0" cellpadding="0">
  <tr>
    <td width="60%"> 
      <h2><a name="nasm_ru1_html_chapter-1">Глава 1. Введение</a></h2>
    </td>
    <td>
      <div align="right"> <font size="-1" color="#666666">Перевод: <a href="http://asmdev.narod.ru/asmos.html">AsmOS 
        group</a>, &copy; 2001</font></div>
    </td>
  </tr>
</table>
<h3><a name="nasm_ru1_html_section-1.1">1.1 Что такое NASM?</a></h3>
<p>Расширенный ассемблер 
  NASM √ это 80x86 ассемблер, разработанный исходя из принципов переносимости 
  и модульности. Он поддерживает широкий диапазон форматов объектных файлов, включая 
  форматы Linux <font color="#000099">a.out</font> и <font color="#000099">ELF</font>, 
  NetBSD/FreeBSD, <font color="#000099">COFF</font>, Microsoft 16-bit <font color="#000099">OBJ</font> 
  и <font color="#000099">Win32</font>. Он способен также создавать простые бинарные 
  файлы. Синтакс NASM максимально упрощен для понимания и похож на синакс Intel, 
  но слегка посложнее. Он поддерживает инструкции Pentium, P6 и MMX, а также имеет 
  макро-расширения.  
<h4><a name="nasm_ru1_html_section-1.1.1">1.1.1 Зачем еще один ассемблер?</a></h4>
<p>Расширенный ассемблер 
  вырос из идеи, поданной на comp.lang.asm.x86 (или 
  возможно на alt.lang.asm - я забыл уже, где), когда 
  по существу не было хорошего свободно доступного ассемблера серии x86 и нужно 
  было, чтобы кто-то написал его. 
<ul>
  <li><font face="Verdana, Arial, Helvetica" size="2" color="#000099">a86</font> 
    &#151; хороший ассемблер, но не бесплатный, и если вы не заплатите, то 32-битный 
    код писать не сможете &#151; только DOS.  
  <li><font face="Verdana, Arial, Helvetica" size="2" color="#000099">gas</font> 
    свободно доступен и портирован под DOS и Unix, но разработан для обратной 
    совместимости с <font color="#000099">gcc</font>. Поэтому проверка ошибок 
    минимальна, к тому-же, с точки зрения любого, кто попробовал что-либо <em>написать</em> 
    в нем &#151; синтаксис ужасен. Плюс ко всему вы не можете в нем написать 16-разрядный 
    код (по крайней мере, правильно).  
  <li><font face="Verdana, Arial, Helvetica" size="2" color="#000099">as86</font> 
    &#151; только под Linux и (по крайней мере моя версия) кажется не имеет практически 
    никакой документации. 
  <li><font face="Verdana, Arial, Helvetica" size="2" color="#000099">MASM</font> 
    очень хорош, очень дорог и работает только под DOS.  
  <li><font face="Verdana, Arial, Helvetica" size="2" color="#000099">TASM</font> 
    лучше, но все еще борется с MASM за совместимость, что означает миллионы директив 
    и куча волокиты. Его синтаксис &#151; по существу MASM-овский, но с противоречиями 
    и причудами (в некоторой степени удаляемыми посредством режима <font color="#000099">Ideal</font>). 
    Он также дорогой и тоже &#151; только ДОС.  
</ul>
<p>Таким образом, 
  представляем на ваше рассмотрение NASM. В сегодняшнем виде он все еще находится 
  в стадии прототипа &#151; мы не обещаем, что он будет превосходить по быстродействию 
  любой из упомянутых выше ассемблеров. Но пожалуйста, <em>пожалуйста</em> шлите 
  нам замечания о замеченных ошибках, исправления, полезную информацию, да все, 
  что угодно, что вы можете передать нам (и спасибо огромное многим людям, кто 
  уже сделал это!), и мы будем улучшать его (в смысле, NASM) снова и снова.  
<h4><a name="nasm_ru1_html_section-1.1.2">1.1.2 Условия лицензирования</a></h4>
<p>Чтобы ознакомиться 
  с условиями лицензирования, при которых вы можете пользоваться NASM, пожалуйста, 
  прочитайте файл Licence, являющийся неотъемлимой частью 
  любого дистрибутивного архива NASM. 
<h3><a name="nasm_ru1_html_section-1.2">1.2 Контакты</a></h3>
<p>Текущая версия NASM (0.98) поддерживается H. Peter Anvin, <a href="mailto:hpa@zytor.com">hpa@zytor.com</a>. 
  Если вы захотите сообщить об обнаруженных ошибках, прочитайте сначала <a href="#nasm_r10_html_section_10_2">параграф 
  10.2</a>. </p>
<p>Страничка NASM в интернете WWW √ <a href="http://www.cryogen.com/Nasm">http://www.cryogen.com/Nasm</a>. 
</p>
<p>Связаться с авторами можно по следующим адресам: <a href="mailto:jules@earthcorp.com">jules@earthcorp.com</a> 
  и <a href="mailto:anakin@pobox.com">anakin@pobox.com</a>. </p>
<p>Новые релизы NASM доступны на <a href="ftp://ftp.kernel.org/pub/software/devel/nasm/">ftp.kernel.org</a>, 
  <a href="ftp://sunsite.unc.edu/pub/Linux/devel/lang/assemblers/">sunsite.unc.edu</a>, 
  <a href="ftp://ftp.simtel.net/pub/simtelnet/msdos/asmutl/">ftp.simtel.net</a> 
  и <a href="ftp://ftp.coast.net/coast/msdos/asmutil/">ftp.coast.net</a>. Уведомления 
  и объявления смотрите на <a href="news:comp.lang.asm.x86">comp.lang.asm.x86</a>, 
  <a href="news:alt.lang.asm">alt.lang.asm</a>, <a href="news:comp.os.linux.announce">comp.os.linux.announce</a> 
  и <a href="news:comp.archives.msdos.announce">comp.archives.msdos.announce</a> 
  (последнее из уведомлений автоматически закачивается на <a href="ftp://ftp.simtel.net/pub/simtelnet/msdos/asmutl/">ftp.simtel.net</a>). 
</p>
<p>Если вы не имеете доступ к <font color="#000099">Usenet</font> или предпочитаете 
  получать информацию о выпусках новых версий по электронной почте, вы можете 
  подписаться на лист рассылки<font color="#000099"> nasm-announce</font>, послав 
  email по адресу <a href="mailto:majordomo@linux.kernel.org">majordomo@linux.kernel.org</a>, 
  содержащий строку <font color="#000099">subscribe nasm-announce</font>. </p>
<p>Если вы хотите также получать информацию о выходе бета-релизов NASM, пошлите 
  по тому-же адресу (см.выше) письмо, содержащее строку <font color="#000099">nasm-beta</font>.</p>
<h3><a name="nasm_ru1_html_section-1.3">1.3 Инсталляция</a></h3>
<h4><a name="nasm_ru1_html_section-1.3.1">1.3.1 Инсталляция NASM под MS-DOS или Windows</a></h4>
<p>При получении DOS-архива NASM, <font color="#000099">nasmXXX.zip</font> (где 
  <font color="#000099">XXX</font> означает номер версии NASM, содержащегося в 
  архиве), распакуйте его в отдельный каталог (например,<font color="#000099"> 
  c:\nasm</font>). </p>
<p>Архив содержит четыре исполняемых файла: NASM-исполняемые файлы <font color="#000099">nasm.exe</font> 
  и <font color="#000099">nasmw.exe</font>, и NDISASM-исполняемые файлы <font color="#000099">ndisasm.exe</font> 
  и <font color="#000099">ndisasmw.exe</font>. Файлы, имеющие в окончании имени 
  <font color="#000099">w</font>, работают под Win9x/ME/NT, а те, которые <font color="#000099">без</font> 
  <font color="#000099">w</font> &#151; работают под DOS-ом. </p>
<p>Для запуска NASM требуются только эти файлы, так что скопируйте их в каталог, 
  указанный в вашей переменной <font color="#000099">PATH</font> , либо отредактируйте 
  <font color="#000099">autoexec.bat</font> для добавления пути к каталогу с исполнимыми 
  файлами NASM в переменную <font color="#0000CC">PATH</font>. (если вы устанавливаете 
  только версию под Win32, можете смело переименовать <font color="#000099">nasmw.exe</font> 
  в <font color="#000099">nasm.exe</font>.) </p>
<p>И это все!!! NASM установлен! Для запуска NASM не обязательно иметь отдельный 
  каталог (если, конечно вы не добавили его к переменной <font color="#000099">PATH</font>), 
  поэтому можете удалить его (каталог), если у вас мало места на диске. </p>
<p>Если вы загрузили DOS-архив с исходниками <font color="#000099">nasmXXXs.zip</font>, 
  он будет также содержать полный исходный текст NASM и набор Make-файлов, которые 
  вы можете (будем надеяться) использовать для перестроения вашей копии NASM "с 
  нуля". В файле <font color="#000099">Readme</font> перечислены все Make-файлы 
  и указано, с какими компиляторами они работают. </p>
<p>Обратите внимание, что исходники <font color="#000099">insnsa.c, insnsd.c, 
  insnsi.h</font> и <font color="#000099">insnsn.c</font> автоматически генерируются 
  из главной таблицы инструкций <font color="#000099">insns.dat</font> Perl-скриптом; 
  файл <font color="#000099">macros.c</font> генерируется из <font color="#000099">standard.mac</font> 
  другим Perl-скриптом. Хотя дистрибутив NASM 0.98 и включает эти автогенерируемые 
  файлы, вам может потребоваться перестроить их (и следовательно, вам будет необходим 
  интерпретатор Perl), если вы захотите изменить <font color="#000099">insns.dat, 
  standard.mac</font> или документацию. Возможно в будущем в исходниках не будет 
  этих файлов вовсе. Версии Perl для ряда платформ, включая DOS и Windows, доступны 
  на <a href="http://www.cpan.org/ports/">www.cpan.org</a>. </p>
<h4><a name="nasm_ru1_html_section-1.3.2">1.3.2 Инсталляция NASM под Unix</a></h4>
<p>При получении Unix-архива исходников NASM, <font color="#000099">nasm-X.XX.tar.gz</font> 
  (где <font color="#000099">X.XX</font> означает номер версии NASM в архиве) 
  распакуйте его в каталог типа <font color="#000099">/usr/local/src</font>. Архив 
  при распаковке создаст собственный подкаталог <font color="#000099">nasm-X.XX</font>. 
</p>
<p>NASM &#151; автоконфигурируемый пакет: как только вы распакуете его, перейдите 
  к каталогу, куда он был распакован и введитеe <font color="#000099">./configure</font>. 
  Данный шелл-скрипт найдет самый подходящий компилятор C для сборки NASM и, соответственно, 
  настройки Make-файлов. </p>
<p>Как только NASM сконфигурируется, вы можете ввести <font color="#000099">make</font> 
  для сборки бинарных файлов <font color="#000099">nasm</font> и <font color="#000099">ndisasm</font>, 
  а затем ввести <font color="#000099">make install</font> для установки их в<font color="#000099"> 
  /usr/local/bin</font> и установки man-страниц <font color="#000099">nasm.1</font> 
  и <font color="#000099">ndisasm.1</font> в <font color="#000099">/usr/local/man/man1</font>. 
  В качестве альтернативы вы можете указать опции типа <font color="#000099">--prefix</font> 
  к команде <font color="#000099">configure</font> скрипта (подробности см. в 
  файле <font color="#000099">INSTALL</font>) или установить программы самостоятельно. 
</p>
<p>NASM также имеет набор утилит для обработки заказного формата объектных файлов 
  <font color="#000099">RDOFF</font>, находящихся в подкаталоге <font color="#000099">rdoff</font> 
  архива NASM. Вы можете собрать их при помощи <font color="#000099">make rdf</font> 
  и установить при помощи <font color="#000099">make rdf_install</font>, если 
  конечно они вам нужны. </p>
<p>Если NASM будет не в состоянии автоматически выбрать конфигурацию, вы все-же 
  сможете скомпилировать его при помощи make-файла <font color="#000099">Makefile.unx</font>. 
  Cкопируйте или переименуйте этот файл в <font color="#000099">Makefile</font> 
  и попробуйте ввести <font color="#000099">make</font>. Имеется также файл <font color="#000099">Makefile.unx</font> 
  в подкаталоге <font color="#000099">rdoff</font>. </p>
<p align="center"><a href="#nasm_ru2_html">Следующая глава</a> | <a href="#contents_html">Содержание</a>
<hr>

<a name="nasm_ru2_html"></a>
<h1 align=center>Расширенный ассемблер: NASM</h1>

<p align=center><a href="#nasm_ru3_html">Следующая глава</a> | <a href="#nasm_ru1_html">Предыдущая 
  глава</a> | <a href="#contents_html">Содержание</a> | Указатель
</p>
<p align=center>&nbsp;</p>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr>
    <td width="60%"> 
      <h2><a name="nasm_ru2_html_chapter-2">Глава 2: Запуск NASM</a></h2>
    </td>
    <td>
      <div align="right"><font size="-1" color="#666666">Перевод: <a href="http://asmdev.narod.ru/asmos.html">AsmOS 
        group</a>, &copy; 2001</font></div>
    </td>
  </tr>
</table>
<h3><a name="nasm_ru2_html_section-2.1">2.1 Синтаксис командной строки NASM</a></h3>
<p>Для ассемблирования файла вы должны ввести следующую команду: </p>
<pre><font color="#666666">     nasm -f &lt;format&gt; &lt;filename&gt; [-o    &lt;output&gt;]</font></pre>
<p>Например, </p>
<pre><font color="#666666">     nasm -f elf myfile.asm</font></pre>
<p>будет ассемблировать <font color="#000099">myfile.asm</font> в ELF-объектный 
  файл <font color="#000099">myfile.o</font>. А строка </p>
<pre>     <font color="#666666">nasm -f bin myfile.asm -o myfile.com</font></pre>
<p>будет ассемблировать <font color="#000099">myfile.asm</font> в обычный бинарный 
  файл <font color="#000099">myfile.com</font>. <br>
  Для получения файла-листинга, содержащего слева от оригинального исходного текста 
  шестнадцатиричные коды, генерируемые NASM, используйте ключ <font color="#000099">-l</font>, 
  обозначающий имя файла-листинга, например: </p>
<pre><font color="#666666" size="2"> </font><font color="#666666">    nasm -f coff myfile.asm -l myfile.lst </font></pre>
<p>Для получения справки по командной строке NASM, укажите следующий ключ: </p>
<pre><font color="#666666" size="2">     </font><font color="#666666">nasm -h</font> </pre>
<p>При этом вы получите также список доступных форматов выходных файлов и что 
  они означают. Если вы используете Linux, но не уверены, какая ваша система &#151; 
  <font color="#000099">a.out</font> или <font color="#000099">ELF</font>, введите 
</p>
<pre><font color="#666666" size="2">     </font><font color="#666666">file nasm</font></pre>
<p>в каталоге, где находятся бинарные файлы NASM. В ответ вы получите что-то вроде</p>
<pre><font color="#666666">     nasm: ELF 32-bit LSB executable i386 (386 and up) Version    1</font></pre>
<p>Это означает, что ваша система &#151; ELF и вы должны при ассемблировании использовать 
  ключ <font color="#000099">-f elf</font>. Если же вы увидите</p>
<pre><font color="#666666" size="2"> </font><font color="#666666">    nasm: Linux/i386 demand-paged executable (QMAGIC)</font></pre>
<p>или что-то наподобие этого, ваша система &#151; <font color="#000099">a.out</font>, 
  и при ассемблировании нужно будет указать ключ <font color="#000099">-f aout</font>. 
  (Linux системы <font color="#000099">a.out</font> считаются устаревшими и на 
  сегодняшний день встречаются редко). <br>
  Подобно Unix компиляторам и ассемблерам, NASM "бесшумен": вы не будете видеть 
  никаких сообщений вообще, если только это не сообщения об ошибках. </p>
<h4><a name="nasm_ru2_html_section-2.1.1">2.1.1 Ключ<font color="#000099"> -o</font>: Указание 
  имени выходного файла</a></h4>
<p>Обычно NASM выбирает имя выходного файла самостоятельно; так как это зависит 
  от формата объектного файла. Если формат объектного файла &#151; Microsoft (<font color="#000099">obj</font> 
  и <font color="#000099">win32</font>), он удалит расширение <font color="#000099">.asm</font> 
  (или любое другое, какое вам нравится использовать &#151; NASMу все равно) из 
  имени исходного файла и заменит его на <font color="#000099">.obj</font>. У 
  объектных файлов Unix-формата (<font color="#000099">aout, coff, elf</font> 
  и <font color="#000099">as86</font>) он будет заменять расширение на <font color="#000099">.o</font>. 
  Для формата <font color="#000099">rdf</font> он будет использовать расширение 
  <font color="#000099">.rdf</font>, а в случае формата <font color="#000099">bin</font> 
  он просто удалит расширение, например из <font color="#000099">myfile.asm</font> 
  получится файл <font color="#000099">myfile</font>. </p>
<p>Если выходной файл уже существует, NASM перезапишет его, если только его имя 
  не совпадает с именем входного файла &#151; в этом случае появится предупреждение 
  и в качестве выходного файла будет использовано имя <font color="#000099">nasm.out</font>.</p>
<p>В случаях, когда имя по умолчанию недопустимо, используйте ключ <font color="#000099">-o</font> 
  командной строки, позволяющий определить необходимое вам имя выходного файла. 
  Имя выходного файла должно следовать за ключем <font color="#000099">-o</font>, 
  неважно с пробелом между ними или без. Например:</p>
<blockquote> 
  <pre><font color="#666666">nasm -f bin program.asm -o program.com <br>nasm -f bin driver.asm    -odriver.sys</font> </pre>
</blockquote>
<h4><a name="nasm_ru2_html_section-2.1.2">2.1.2 Ключ <font color="#000099">-f</font>: Указание 
  формата выходного файла</a></h4>
<p>Если ключ <font color="#000099">-f</font> в командной строке отсутствует, NASM 
  будет выбирать формат выходного файла самостоятельно. В распространяемой версии 
  NASM формат по умолчанию всегда <font color="#000099">bin</font>; если вы создаете 
  собственную копию NASM, то при компиляции можете переопределить значение <font color="#000099">OF_DEFAULT</font> 
  на то, которое вам нужно по умолчанию. </p>
<p>Как и для ключа <font color="#000099">-o</font>, разделительный пробел между 
  <font color="#000099">-f</font> и форматом выходного файла необязателен: <font color="#000099">-f 
  elf</font> и <font color="#000099">-felf</font> для NASM идентичны.</p>
<p><font size="2" face="Verdana, Arial, Helvetica">Полный список доступных выходных 
  форматов может быть получен при помощи команды <font color="#000099">nasm -h</font>. 
  </font></p>
<h4><a name="nasm_ru2_html_section-2.1.3">2.1.3 Ключ <font color="#000099">-l</font>: Генерация 
  файла-листинга</a></h4>
<p>Если в командной строке вы укажете ключ <font color="#000099">-l</font> и имя 
  файла (как обычно, пробел необязателен), NASM будет генерировать из исходника 
  файл-листинг, где адреса и генерируемый код будут расположены слева, а исходный 
  код с развернутыми многострочными макросами (за исключением тех, которые специально 
  требуют обратное: см. <a href="#nasm_ru4_html_section_4_2_9">параграф 4.2.9</a>) 
  &#151; справа. Например: 
<blockquote> 
  <pre><font color="#666666">nasm -f elf myfile.asm -l myfile.lst </font></pre>
</blockquote>
<h4><a name="nasm_ru2_html_section-2.1.4">2.1.4 Ключ <font color="#000099">-E</font>: </a>Перенаправление 
  ошибок в файл</h4>
<p>Под MS-DOS перенаправление стандартного потока ошибок в файл может быть сопряжено 
  с трудностями (хотя способы имеются). Так как NASM обычно направляет предупреждения 
  и сообщения об ошибках в поток <font color="#000099">stderr</font>, перехват 
  этих сообщений ( например для последующего просмотра в редакторе) может вызвать 
  сложности. </p>
<p><font size="2" face="Verdana, Arial, Helvetica">В связи с этим имеется специальный 
  ключ <font color="#000099">-E</font>, после которого указывается имя файла (пробел 
  необязателен). Данный ключ перенаправляет стандартный поток ошибок в указанный 
  файл. Таким образом, вы можете запустить NASM, например следующим образом:</font></p>
<blockquote> 
  <pre><font color="#666666">nasm -E myfile.err -f obj myfile.asm </font></pre>
</blockquote>
<h4><a name="nasm_ru2_html_section-2.1.5">2.1.5 Ключ <font color="#000099">-s</font>: Перенаправление 
  ошибок в <font color="#000099">stdout</font></a></h4>
<p>Ключ <font color="#000099">-s</font> перенаправляет стандартный поток ошибок 
  <font color="#000099">stderr</font> в выходной поток <font color="#000099">stdout</font> 
  (естественно, в MS-DOS). Например, для ассемблирования файла <font color="#000099">myfile.asm</font> 
  и передачи ошибок программе <font color="#000099">more</font>, вы можете ввести 
  следующее: 
<p> 
<blockquote> 
  <pre><font color="#666666">nasm -s -f obj myfile.asm | more</font></pre>
</blockquote>
<p>См. также ключ <font color="#000099">-E</font>, <a href="#nasm_ru2_html_section_2_1_4">параграф 
  2.1.4</a>. 
<h4><a name="nasm_ru2_html_section-2.1.6">2.1.6 Ключ <font color="#000099">-i</font>: </a>Каталоги 
  поиска включаемых файлов</h4>
<p>Когда NASM встречает в исходнике директиву <font color="#000099">%include</font> 
  (см. <a href="#nasm_ru4_html_section_4_5">параграф 4.5</a>), он будет искать указанный 
  в ней файл не только в текущем каталоге, но и во всех каталогах, указанных в 
  командной строке при помощи ключа <font color="#000099">-i</font>. Следовательно, 
  вы можете включить файлы из, например, библиотеки макросов, введя следующую 
  команду: 
<blockquote><pre>
<font color="#666666">nasm -ic:\macrolib\ -f obj myfile.asm</font>
</pre></blockquote>
  
<p>(Как обычно, пробел между <font color="#000099">-i</font> и строкой поиска 
  допустим, но не обязателен) </p>
<p>С целью переносимости кода в NASMе не "зашито" соглашение об именовании файлов 
  той или иной ОС, под которой он запущен; строка, которую вы укажете как аргумент 
  ключа, будет обработана в точности так, как есть. Заключительный обратный слэш 
  в приведенном выше примере под Unix необходим, т.к. в этой ОС заключительные 
  слэши обычно требуются.</p>
<p>(Вы можете извлечь из этого обстоятельства выгоду, использовав данный ключ 
  "не по назначению" &#151; например ключ <font color="#000099">-ifoo</font> будет 
  заставлять директиву <font color="#000099">%include "bar.i"</font> искать файл 
  <font color="#000099">foobar.i...</font>) </p>
<p>Если вы хотите описать <i>стандартный</i> путь поиска включаемых файлов, такой 
  как <font color="#000099">/usr/include</font> в системе Unix, вы должны поместить 
  одну или более директив <font color="#000099">-i</font> в переменную окружения 
  <font color="#000099">NASM</font> (см. <a href="#nasm_ru2_html_section_2_1_13">параграф 2.1.13</a>). 
</p>
<p>Для совместимости с make-файлами большинства С компиляторов, данный ключ может 
  быть также задан как <font color="#000099">-I</font>. </p>

  <h4><a name="nasm_ru2_html_section-2.1.7">2.1.7 Ключ <font color="#000099">-p</font>: Предварительно 
  включаемые файлы</a></h4>
<p>При помощи ключа <font color="#000099">-p</font> NASM позволяет вам <i>предварительно</i> 
  включить некоторые файлы в ваш исходник. Так, строка запуска 
<p>
<blockquote>
  <pre><font color="#666666">nasm myfile.asm -p myinc.inc</font></pre>
</blockquote>
<p>эквивалентна строке <font color="#000099">nasm myfile.asm</font> и помещением 
  в начало файла директивы <font color="#000099">%include "myinc.inc"</font>. 
  В целях симметричности с ключами <font color="#000099">I, -D</font> и <font color="#000099">-U</font> 
  данный ключ может быть также задан как <font color="#000099">-P</font>. 
<h4><a name="nasm_ru2_html_section-2.1.8">2.1.8 Ключ <font color="#000099">-d</font>: Предопределение 
  макроса</a></h4>
<p>Аналогично тому, как ключ <font color="#000099">-p</font> дает альтернативу 
  помещения в начало исходного файла директивы <font color="#000099">%include</font>, 
  ключ <font color="#000099">-d</font> дает альтернативу директиве <font color="#000099">%define</font>. 
  Таким образом, команда 
<blockquote>
  <pre><font color="#666666">nasm myfile.asm -dFOO=100</font></pre>
  </blockquote>
<p>альтернативна помещению в начало файла директивы 
<blockquote>
  <pre><font color="#666666">%define FOO 100</font></pre>
  </blockquote>
<p>Вы можете также опустить значение константы: ключ <font color="#000099">-dFOO</font> 
  эквивалентен строке <font color="#000099">%define FOO</font>. Данная возможность 
  может быть полезна при ассемблировании для включения/выключения опций, проверяемых 
  при помощи директивы <font color="#000099">%ifdef</font>, например <font color="#000099">-dDEBUG</font>. 
  Для совместимости с make-файлами большинства С компиляторов, данный ключ может 
  быть также задан как <font color="#000099">-D</font>. 
<h4><a name="nasm_ru2_html_section-2.1.9">2.1.9 Ключ <font color="#000099">-u</font>: </a>Отмена 
  определения макроса</h4>
<p> Ключ <font color="#000099">-u</font> отменяет определение ранее определенного 
  макроса. Например, в результате выполнения следующей командной строки: 
<p>
<blockquote>
  <pre><font color="#666666">nasm myfile.asm -dFOO=100 -uFOO</font></pre>
</blockquote>
<p>FOO <i>не будет</i> предопределенным макросом для программы. Это полезно для 
  временного отключения опций, заданных в make-файлах. Для совместимости с make-файлами 
  большинства С компиляторов, данный ключ может быть также задан как <font color="#000099">-U</font>. 
<h4><a name="nasm_ru2_html_section-2.1.10">2.1.10 Ключ <font color="#000099">-e</font>: Только 
  препроцессирование</a></h4>
<p>NASM допускает выполнение только препроцессирования входного файла. Использование 
  ключа <font color="#000099">-e</font> (не требующего параметров) заставит NASM 
  препроцессировать входной файл, развернуть все макро ссылки, удалить все комментарии 
  и директивы препроцессора и вывести результирующий файл в стандартный выходной 
  поток (или сохранить его как отдельный файл, если используется также опция <font color="#000099">-о</font>). 
<p>Данный ключ неприменим для программ, где препроцессор должен вычислить выражения, 
  зависящие от значений адресов: такой код как 
<p>
<blockquote>
  <pre><font color="#666666">%assign tablesize ($-tablestart)</font></pre>
</blockquote>
<p>будет вызывать ошибку в режиме "только препроцессирование". 
<h4><a name="nasm_ru2_html_section-2.1.11">2.1.11 Ключ -a: </a>Отключение препроцессора</h4>
<p>Если NASM используется в качестве выходной части компилятора, то для увеличения 
  скорости компиляции желательно полностью подавить препроцессирование в случае, 
  если компилятор уже делает его. Ключ <font color="#000099">-a</font>, не требующий 
  никаких параметров, заставляет NASM заменить свой препроцессор ничего не делающей 
  "заглушкой". 
<h4><a name="nasm_ru2_html_section-2.1.12">2.1.12 Ключ -w: </a>Разрешение/Запрещение предупреждений 
  при ассемблировании</h4>
<p>В процессе ассемблирования NASM может замечать множество вещей, заслуживающих 
  внимания пользователя, но не представляющих собой таких серьезных ошибок, чтобы 
  NASM не смог сгенерировать выходной файл. Эти предупреждения выдаются так же, 
  как и ошибки, но перед собственно сообщением добавляется слово "warning". Предупреждения 
  не являются причиной прерывания процесса генерации выходного файла. 
<p>Некоторые события менее серьезны, чем другие: они только иногда заслуживают 
  внимания пользователя. В связи с вышесказанным, NASM поддерживает ключ командной 
  строки <font color="#000099">-w</font>, включающий или выключающий определенные 
  классы предупреждений. Эти классы предупреждений описываются по имени, например 
  <font color="#000099">orphan-labels</font>; вы можете разрешить предупреждения 
  данного класса при помощи ключа <font color="#000099">-w+orphan-labels</font> 
  и запретить их ключом <font color="#000099">-w-orphan-labels</font>. 
<p>Ниже перечислены классы подавляемых предупреждений: 
<ul>
  <li><font  color="#000099">macro-params</font> 
    включает предупреждения о многострочных макросах, которым передается неверное 
    число параметров. Данный класс предупреждений по умолчанию разрешен; см. <a href="#nasm_ru4_html_section_4_2_1">параграф 
    4.2.1</a>, где приведен пример отключения этого класса. 
  <li><font  color="#000099">orphan-labels</font> 
    включает предупреждения о строках исходника, не содержащих инструкций, но 
    в которых описываются метки без завершающего двоеточия. NASM по умолчанию 
    не предупреждает об этих вещах; см. пример в <a href="#nasm_ru3_html_section_3_1">параграфе 
    3.1</a>, где показано, как можно включить их. 
  <li><font face="Verdana, Arial, Helvetica" size="2" color="#000099">number-overflow</font> 
    включает предупреждения о числовых константах, не вписывающихся в диапазон 
    32 бита (0x7fffffff). Данный класс предупреждений по умолчанию разрешен. 
</ul>
<h4><a name="nasm_ru2_html_section-2.1.13">2.1.13 Переменная окружения <font color="#000099">NASM</font></a></h4>
<p>Если вы определите переменную окружения NASM, программа будет интерпретировать 
  ее как список дополнительных ключей командной строки, обрабатывающихся <i>раньше</i> 
  "настоящих" параметров командной строки. Вы можете использовать эту возможность, 
  например для описания стандартных каталогов поиска включаемых файлов, поместив 
  в пременную <font color="#000099">NASM</font> ключ <font color="#000099">-i</font>. 
</p>
<p>Значение пременной разделяется пробелами, поэтому значение <font color="#000099">-s 
  -ic:\nasmlib</font> будет обработано как два отдельных ключа. В то же время 
  значение <font color="#000099">-dNAME="my name"</font> не будет воспринято так, 
  как вы хотите (внутри есть пробел) и командный процессор NASMа соответственно 
  не поймет двух бессмысленных параметров <font color="#000099">-dNAME="my</font> 
  и <font color="#000099">name"</font>.</p>
<p>Для разрешения этого введено следующее правило: если вы начинаете переменную 
  <font color="#000099">NASM</font> некоторым символом, не являющимся знаком "минус", 
  NASM будет воспринимать этот символ как разделитель опций. Таким образом, значение<br>
  <font color="#000099">!-s!-ic:\nasmlib</font> переменной <font color="#000066">NASM</font> 
  эквивалентно <font color="#000099">-s -ic:\nasmlib</font>, но зато теперь <font color="#000066">!-dNAME="my 
  name"</font> будет работать правильно. </p>
<h3><a name="nasm_ru2_html_section-2.2">2.2 Пользователям MASM: Отличия</a></h3>
<p>Если вы использовали для написания программ <font color="#000099">MASM</font>, 
  или <font color="#000099">TASM</font> в режиме совместимости с MASM, или <font color="#000099">a86</font>, 
  прочитайте данный раздел, в котором приводятся основные отличия синтаксиса MASM 
  и NASM. Если же вы вообще не использовали раньше MASM, просто пропустите этот 
  раздел и читайте дальше. 
<h4><a name="nasm_ru2_html_section-2.2.1">2.2.1 NASM чувствителен к регистру символов</a></h4>
<p>Самым "простым" отличием является регистро-чувствительность NASM &#151; он 
  различает обращения к таким меткам, как <font color="#000099">foo, Foo</font> 
  или <font color="#000099">FOO</font>. Если вы ассемблируете <font color="#000099">.obj</font>-файлы 
  для DOS или OS/2, то для перевода всех экспортируемых в другие модули символов 
  в верхний регистр можете активизировать директиву <font color="#000099">UPPERCASE</font> 
  (описана в <a href="#nasm_ru6_html_section_6_2">параграфе 6.2</a>). Однако <i>в 
  пределах</i> одного модуля NASM различает метки, отличающиеся друг от друга 
  только регистром. 
<h4><a name="nasm_ru2_html_section-2.2.2">2.2.2 NASM требует квадратные скобки для ссылок на 
  память</a></h4>
<p>NASM был разработан, кроме всего прочего, для упрощения запоминания синтаксиса. 
  Одна из целей проекта NASM состоит в том, чтобы везде, где это возможно, было 
  взаимно однозначное соответствие между отдельной строкой кода NASM и генерируемой 
  из нее инструкцией. В MASM вы этого сделать не можете: если определите, например, 
<p> 
<pre><font color="#666666">          foo       equ 1 
          bar       dw 2</font></pre>
<p>затем напишете две строки кода 
<p> 
<pre><font color="#666666">          mov ax,foo 
          mov ax,bar</font></pre>
<p>то будут сгенерированы две совершенно различных инструкции, несмотря на то, 
  что синтаксис на вид совершенно идентичен. 
<p>NASM уходит от этой нежелательной ситуации путем упрощения синтаксиса для ссылок 
  на память. Правило элементарно &#151; <i>любой</i> доступ к содержимому памяти 
  требует постановки квадратных скобок вокруг адреса, а при любом доступе к <i>адресу</i> 
  переменной квадратные скобки не ставятся. Таким образом, инструкция вида <font color="#000099">mov 
  ax,foo</font> будет <i>всегда</i> ссылаться на константу времени компиляции, 
  неважно <font color="#000099">EQU</font> ли это или адрес переменной, в то же 
  время для получения доступа к <i>содержимому</i> переменной <font color="#000099">bar</font> 
  вы должны использовать код <font color="#000099">mov ax,[bar]</font>. </p>
<p>Из этого также следует, что NASM не нуждается в ключевом слове MASMа <font color="#000099">OFFSET</font>, 
  т.к. MASMовский код <font color="#000099">mov ax,offset bar</font> означает 
  то же самое, что и <font color="#000099">mov ax,bar</font> для NASM. Если вы 
  накопили достаточно много кода, написанного под MASM и хотите использовать его 
  в NASMе, вы всегда можете вставить строчку вида <font color="#000099">%idefine 
  offset</font>, указывающую препроцессору, что ключевое слово <font color="#000099">OFFSET</font> 
  является ничего не делающей инструкцией.</p>
<p>Данное несоответствие еще в большей степени присутствует в <font color="#000099">a86</font>, 
  где объявление метки с завершающим двоеточием описывает собственно метку, а 
  без двоеточия &#151; переменную. Так, в <font color="#000099">a86</font> инструкция 
  <font color="#000099">mov ax,var</font> будет вести себя по разному, в зависимости 
  от объявления метки <font color="#000099">var</font>: как <font color="#000099">var: 
  dw 0</font> (это метка) или как <font color="#000099">var dw 0</font> (а это 
  уже переменная размером в слово). NASM по сравнению с этим очень прост: <i>все</i> 
  является метками.</p>
<p>NASM, в целях упрощения, не поддерживает гибридный синтаксис MASMа и его клонов, 
  такой, как например <font color="#000099">mov ax,table[bx]</font>, где ссылка 
  на память обозначена частью внутри квадратных скобок, а частью &#151; вне их. 
  Правильный синтаксис в NASM для указанной выше инструкции будет <font color="#000099">mov 
  ax,[table+bx]</font>. Соответственно, инструкция вида <font color="#000099">mov 
  ax,es:[di]</font> не поддерживается, правильная инструкция &#151; <font color="#000099">mov 
  ax,[es:di]</font>.</p>
<h4><a name="nasm_ru2_html_section-2.2.3">2.2.3 NASM не хранит типы переменных</a></h4>
<p>NASM не запоминает определямые вами типы переменных. Поскольку MASM эти вещи 
  запоминает, то при встрече <font color="#000099">var dw 0</font> он запомнит, 
  что вы определили <font color="#000099">var</font> как пременную размером в 
  слово и затем будет способен разрешить неопределенность при появлении инструкции 
  <font color="#000099">mov var,2</font>. NASM же преднамеренно не будет помнить 
  ничто относительно символа <font color="#000099">var</font> за исключением того, 
  где он начинается, поэтому вы должны явно указывать <font color="#000099">mov 
  word [var],2</font>. </p>
<p>В соответствии с этим, NASM не поддерживает инструкции <font color="#000099">LODS, 
  MOVS, STOS, SCAS, CMPS, INS</font> или <font color="#000099">OUTS</font>, поддерживаются 
  только их формы вида <font color="#000099">LODSB, MOVSW</font> и <font color="#000099">SCASD</font>, 
  где явно задается размер компонентов обрабатываемой строки. </p>
<h4><a name="nasm_ru2_html_section-2.2.4">2.2.4 NASM не поддерживает <font color="#000066">ASSUME</font></a></h4>
<p>Как часть общей идеологии упрощения, NASM не поддерживает директиву <font color="#000099">ASSUME</font>. 
  NASM не будет следить за тем, какие значения вы помещаете в сегментные регистры 
  и поэтому никогда <i>автоматически не будет</i> генерировать префикс замены 
  сегмента. 
<h4><a name="nasm_ru2_html_section-2.2.5">2.2.5 NASM не поддерживает модели памяти</a></h4>
<p>NASM не имеет никаких директив для поддержки различных 16-битных моделей памяти. 
  Программист должен самостоятельно следить, какие функции предполагается вызывать 
  "дальним вызовом", а какие &#151; ближним, и соответственно помещать правильную 
  форму инструкции <font color="#000099">RET</font> (<font color="#000099">RETN</font> 
  или <font color="#000099">RETF</font>; NASM допускает применение <font color="#000099">RET</font> 
  в качестве альтернативной формы <font color="#000099">RETN</font>); кроме того, 
  программист ответственен за кодирование инструкций <font color="#000099">CALL 
  FAR</font>, где это необходимо при вызове внешних функций, и должен также следить, 
  какие описания внешних переменных являются дальними, а какие &#151; ближними. 
<h4><a name="nasm_ru2_html_section-2.2.6">2.2.6 Различия в обработке чисел с плавающей точкой</a></h4>
<p>NASM, в отличие от MASM, использует другие имена для ссылок на регистры сопроцессора: 
  MASM ссылается на эти регистры как <font color="#000099">ST(0), ST(1)</font> 
  и т.д., в NASMе для этой цели используются имена <font color="#000099">st0, 
  st1</font> и т.д. </p>
<p>Начиная с версии 0.96, NASM обрабатывает инструкции форм "nowait" так же, как 
  и MASM-совместимые ассемблеры. Особая обработка, использованная в версиях 0.95 
  и младше была основана на неправильном понимании авторами. </p>
<h4><a name="nasm_ru2_html_section-2.2.7">2.2.7 Прочие различия</a></h4>
<p>По историческим причинам NASM использует ключевое слово <font color="#000099">TWORD</font> 
  там, где MASM и совместимые с ним ассемблеры используют <font color="#000099">TBYTE</font>. 
</p>
<p>NASM объявляет резервируемое пространство (неиницализированные данные) не так, 
  как MASM: там, где MASM-программист может написать <font color="#000099">stack 
  db 64 dup (?)</font>, NASM требует следующее &#151; <font color="#000099">stack 
  resb 64</font>, что интерпретируется как "резервирование 64 байт". Так как NASM 
  обрабатывает <font color="#000099">?</font> как обычный символ, вы можете написать 
  что-то вроде <font color="#000099">? equ 0</font>, а затем использовать <font color="#000099">dw 
  ?</font>, что будет возможно полезно для каких-то целей. <font color="#000099">DUP</font> 
  однако остается неподдерживаемым синтаксисом. </p>
<p>И, наконец, в дополнение ко всему вышесказанному, макросы и директивы NASM 
  работают совершенно отлично от MASM. Подробности приведены в <a href="#nasm_ru4_html">главе 
  4</a> и <a href="#nasm_ru5_html">главе 5</a>. </p>
<p align="center"><a href="#nasm_ru3_html">Следующая глава</a> | <a href="#nasm_ru1_html">Предыдущая 
  глава</a> | <a href="#contents_html">Содержание</a>
<hr>

<a name="nasm_ru3_html"></a>
<h1 align=center>Расширенный ассемблер: NASM</h1>
<p align=center><a href="#nasm_ru4_html">Следующая глава</a> | <a href="#nasm_ru2_html">Предыдущая 
  глава </a> | <a href="#contents_html">Содержание</a> | Указатель
</p>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr> 
    <td width="60%"> 
      <h2><a name="nasm_ru3_html_chapter-3">Глава 3: Язык NASM</a></h2>
    </td>
    <td> 
      <div align="right"><font size="-1" color="#666666">Перевод: <a href="http://asmdev.narod.ru/asmos.html">AsmOS 
        group</a>, &copy; 2001</font></div>
    </td>
  </tr>
</table>
<h3><a name="nasm_ru3_html_section-3.1">3.1 Обзор ассемблерной строки NASM</a></h3>
<p>Как и в большинстве ассемблеров, каждая строка NASM содержит (если это не макрос, 
  препроцессорная или ассемблерная директива √ см. <a href="#nasm_ru4_html">главу 
  4</a> и <a href="#nasm_ru5_html">главу 5</a>) комбинацию четырех полей: </p>
<pre><font color="#666666">     метка: инструкция операнды ; комментарий</font></pre>
<p>Как обычно, большинство этих полей необязательны; допускается присутствие или 
  отсутствие любой комбинации метки, инструкции и комментария. Конечно, необходимость 
  поля операндов определяется инструкцией процессора. </p>
<p>NASM не накладывает ограничений на количество пробелов в строке: метки могут 
  иметь пробелы вначале, а инструкции могут не иметь никаких пробелов и т.п. Двоеточие 
  после метки также необязательно. (Это означает, что если вы хотите поместить 
  в строку инструкцию <font color="#000099">lodsb</font>, а введете <font color="#000099">lodab</font>, 
  строка останется корректной, но вместо инструкции будет объявлена метка. Выявить 
  данные опечатки отчасти можно, введя в строке запуска NASM ключ <font color="#000099">-w+orphan-labels</font> 
  &#151; в этом случае при обнаружении метки без заключительного двоеточия будет 
  выдаваться предупреждение). </p>
<p>Допустимыми символами в метках являются буквы, цифры, знаки <font color="#000099">_, 
  $, #, @, ~, .</font> и <font color="#000099">?</font>. Допустимые символы в 
  начале метки (первый символ метки) &#151; только буквы, точка (<font color="#000099">.</font>) 
  (со специальным значением, см. <a href="#nasm_ru3_html_section_3_8">параграф 3.8</a>), знак 
  подчеркивания (<font color="#000099">_</font>) и вопросительный знак (<font color="#000099">?</font>). 
  В идентификаторе может также присутствовать префикс <font color="#000099">$</font> 
  для указания того, что это действительно идентификатор, а не зарезервированное 
  слово; таким образом, если некоторый компонуемый вами модуль описывает символ 
  <font color="#000099">eax</font>, вы можете в коде NASM (для указания того, 
  что это не регистр) сослаться на него так: <font color="#000099">$eax</font>. 
</p>
<p>Поле инструкций может содержать любые процессорные инструкции: поддерживаются 
  инструкции Pentium и P6, FPU, MMX, а также некоторые недокументированные инструкции. 
  Перед инструкциями могут присутствовать префиксы <font color="#000099">LOCK, 
  REP, REPE/REPZ</font> или <font color="#000099">REPNE/REPNZ</font>, используемые 
  по их обычному предназначению. Поддерживаются префиксы размера адреса и операнда 
  <font color="#000099">A16, A32, O16</font> и <font color="#000099">O32</font> 
  &#151; пример их использования приведен в <a href="#nasm_ru9_html">главе 9</a>. 
  В качестве префикса инструкции вы можете использовать также обозначение сегментного 
  регистра: код <font color="#000099">mov [bx],ax</font> эквивалентен коду <font color="#000099">mov 
  [es:bx],ax</font>. Мы рекомендуем использовать последний синтаксис, т.к. он 
  согласуется с другими синтаксическими особенностями языка, однако для инструкций, 
  не имеющих операндов (например, <font color="#000099">LODSB</font>) и требующих 
  в некоторых случаях замены сегмента, на данный момент не существует никакого 
  синтаксического способа обойти конструкцию <font color="#000099">es lodsb</font>. 
</p>
<p>Префиксы, такие как <font color="#000099">CS, A32, LOCK</font> или <font color="#000099">REPE</font> 
  могут присутствовать в строке самостоятельно и при этом NASM будет генерировать 
  соответствующие префикс-байты. </p>
<p>В дополнение к инструкциям процессора, NASM поддерживает также несколько псевдо-инструкций, 
  описанных в <a href="#nasm_ru3_html_section_3_2">параграфе 3.2</a>. </p>
<p>Операнды инструкций могут принимать несколько форм: они могут быть регистрами 
  (например ax, bp, ebx, cr0: NASM не использует синтаксис стиля а-ля-gas, где 
  имена регистров должны предваряться знаком %), эффективными адресами (см. <a href="#nasm_ru3_html_section_3_3">параграф 
  3.3</a>), константами (<a href="#nasm_ru3_html_section_3_4">параграф 3.4</a>) или выражениями 
  (<a href="#nasm_ru3_html_section_3_5">параграф 3.5</a>). </p>
<p>Для инструкций сопроцессора NASM допускает различные формы синтаксиса: вы можете 
  использовать двух-операндную форму, поддерживаемую MASMом, а также чисто NASMовскую 
  одно-операндную форму. Подробности о форме каждой поддерживаемой инструкции 
  приведены в <a href="#nasm_rua_html">приложении A</a>. Например, вы можете написать: 
</p>

<pre><font color="#666666">     fadd st1               ; это значит st0 := st0 + st1 
     fadd st0,st1           ; это то же самое 

     fadd st1,st0           ; это значит st1 := st1 + st0 
     fadd to st1            ; это то же самое</font></pre>
<p>Почти любая инструкция сопроцессора, ссылающаяся на содержимое памяти, должна 
  использовать один из префиксов <font color="#000099">DWORD, QWORD</font> или 
  <font color="#000099">TWORD</font> для указания на то, операнд какого размера 
  должен участвовать в команде. </p>

<h3><a name="nasm_ru3_html_section-3.2">3.2 Псевдо-инструкции</a></h3>
<p>Псевдо-инструкции не являются реальными инструкциями х86 процессора, но все 
  равно помещаются в поле инструкций, т.к. это наиболее подходящее место для них. 
  Текущими псевдо-инструкциями являются <font color="#000099">DB, DW, DD, DQ</font> 
  и <font color="#000099">DT</font>, их копии для работы с неинициализированной 
  памятью <font color="#000099">RESB, RESW, RESD, RESQ</font> и <font color="#000099">REST</font>, 
  команды <font color="#000099">INCBIN, EQU</font> и префикс <font color="#000099">TIMES</font>. 
<h4><a name="nasm_ru3_html_section-3.2.1">3.2.1 <font color="#000099">DB</font> </a>и ее друзья: 
  Объявление инициализированных данных</h4>
<p>Как и в MASM, <font color="#000099">DB, DW, DD, DQ</font> и <font color="#000099">DT</font> 
  используются для объявления инициализированных данных в выходном файле. Они 
  могут использоваться достаточно многими способами: </p>
<pre><font color="#666666">     db 0x55                ; просто байт 0x55 
     db 0x55,0x56,0x57      ; последовательно 3 байта 
     db 'a',0x55            ; символьная константа 
     db 'hello',13,10,'$'   ; это строковая константа 
     dw 0x1234              ; 0x34 0x12 
     dw 'a'                 ; 0x41 0x00 (это просто число)
     dw 'ab'                ; 0x41 0x42 (символьная константа) 
     dw 'abc'               ; 0x41 0x42 0x43 0x00 (строка) 
     dd 0x12345678          ; 0x78 0x56 0x34 0x12 
     dd 1.234567e20         ; константа с плавающей точкой 
     dq 1.234567e20         ; двойной точности 
     dt 1.234567e20         ; расширенной точности</font></pre>

<p><font   color="#000099">DQ</font> и <font color="#000099">DT</font> не допускают 
  в качестве операндов числовые или строковые константы. </p>
<p>
<h4><a name="nasm_ru3_html_section-3.2.2">3.2.2 <font color="#000099">RESB</font> и ее друзья: 
  Объявление неинициализированных данных</a></h4>
<p><font   color="#000099">RESB, RESW, RESD, RESQ</font> и <font color="#000099">REST</font> 
  разработаны для использования в BSS-секции модуля: они объявляют <i>не инициализированное</i> 
  пространство для хранения данных. Каждая принимает один операнд, являющийся 
  числом резервируемых байт, слов, двойных слов и т.д. Как было указано в <a href="#nasm_ru2_html_section_2_2_7">параграфе 
  2.2.7</a>, NASM не поддерживает синтаксис резервирования неинициализированного 
  пространства, реализованный в MASM/TASM, где можно делать <font color="#000099">DW 
  ?</font> или подобные вещи: это заменено полностью. Операнд псевдо-инструкций 
  класса <font color="#000099">RESB</font> является <i>критическим выражением</i>: 
  см. <a href="#nasm_ru3_html_section_3_7">параграф 3.7</a>. </p>
<p>Например: </p>
<pre><font color="#666666">     buffer:   resb 64                ; резервирование 64 байт 
     wordvar:  resw 1                 ; резервирование слова 
     realarray resq 10                ; массив из 10 чисел с плавающей точкой</font></pre>
<p>
<h4><a name="nasm_ru3_html_section-3.2.3">3.2.3 <font color="#000099">INCBIN</font>: Включение 
  внешних бинарных файлов</a></h4>
<p>INCBIN заимствована из старого ассемблера DevPac, работавшего на Amigе: она 
  включает бинарный файл в выходной файл, оставляя его (бинарный файл) неизменным. 
  Это может быть полезно (например) для включения картинок и музыки непосредственно 
  исполняемый файл игрушки. Эта псевдо-инструкция может быть вызвана тремя разными 
  способами: </p>
<pre><font color="#666666">     incbin "file.dat"      ; включение файла целиком 
     incbin "file.dat",1024 ; пропуск первых 1024 байт 
     incbin "file.dat",1024,512 ; пропуск первых 1024 и
                            ; включение следующих 512 байт</font></pre>
<p>
<h4><a name="nasm_ru3_html_section-3.2.4">3.2.4 <font color="#000099">EQU</font>: Определение 
  констант</a></h4>
<p><font   color="#000099">EQU</font> вводит символ для указанного константного 
  значения: если используется <font color="#000099">EQU</font>, в этой строке 
  кода должна присутствовать метка. Смысл <font color="#000099">EQU</font> &#151; 
  связать имя метки со значением ее (только) операнда. Данное определение абсолютно 
  и не может быть позднее изменено. Например, </p>
<pre><font color="#666666">     message   db 'Привет, фуфел!' 
     msglen    equ $-message</font></pre>

<p>определяет <font color="#000099">msglen</font> как константу 12. <font color="#000099">msglen</font> 
  не может быть позднее переопределено. Это не определение препроцессора: значение 
  <font color="#000099">msglen</font> обрабатывается здесь только <i>один раз</i> 
  при помощи значения <font color="#000099">$</font> (что такое <font color="#000099">$</font> 
  √ см. <a href="#nasm_ru3_html_section_3_5">параграф 3.5</a>) в месте определения. Имейте в 
  виду, что операнд <font color="#000099">EQU</font> также является критическим 
  выражением (<a href="#nasm_ru3_html_section_3_7">параграф 3.7</a>). </p>
<h4><a name="nasm_ru3_html_section-3.2.5">3.2.5 <font color="#000099">TIMES</font>: Повторение 
  инструкций или данных</a></h4>
<p>Префикс <font color="#000099">TIMES</font> заставляет инструкцию ассемблироваться 
  несколько раз. Данная псевдо-инструкция отчасти представляет NASM-эквивалент 
  синтаксиса <font color="#000099">DUP</font>, поддерживающегося MASM-совместимыми 
  ассемблерами. Вы можете написать, например </p>
<pre><font color="#666666">     zerobuf: times 64 db 0</font></pre>
<p>или что-то подобное; однако <font color="#000099">TIMES</font> более разносторонняя 
  инструкция. Аргумент <font color="#000099">TIMES</font> &#151; не просто числовая 
  константа, а <i>числовое выражение</i>, поэтому вы можете писать следующие вещи: 
</p>
<pre><font color="#666666">buffer:   db 'Привет, фуфел!' 
     times 64-$+buffer db ' '</font></pre>
<p>При этом будет резервироваться строго определенное пространство, начиная от 
  метки <font color="#000099">buffer</font> и длиной 64 байта. Наконец, <font color="#000099">TIMES</font> 
  может использоваться в обычных инструкциях, так что вы можете писать тривиальные 
  развернутые циклы: </p>
<pre><font color="#666666">     times 100 movsb</font></pre>
<p>Заметим, что нет никакой принципиальной разницы между <font color="#000099">times 
  100 resb 1</font> и <font color="#000099">resb 100</font> за исключением того, 
  что последняя инструкция будет обрабатываться примерно в 100 раз быстрее из-за 
  внутренней структуры ассемблера. </p>
<p>Операнд псевдо-инструкции <font color="#000099">TIMES</font>, подобно <font color="#000099">EQU</font> 
  и <font color="#000099">RESB</font>, является критическим выражением (<a href="#nasm_ru3_html_section_3_7">параграф 
  3.7</a>). </p>
<p>Имейте также в виду, что <font color="#000099">TIMES</font> не применима в 
  макросах: причиной служит то, что <font color="#000099">TIMES</font> обрабатывается 
  после макро-фазы, позволяющей аргументу <font color="#000099">TIMES</font> содержать 
  выражение, подобное <font color="#000099">64-$+buffer</font>. Для повторения 
  более одной строки кода или в сложных макросах используйте директиву препроцессора 
  <font color="#000099">%rep</font>. </p>
<h3><a name="nasm_ru3_html_section-3.3">3.3 Эффективные адреса</a></h3>
<p>Эффективный адрес &#151; это любой операнд инструкции со ссылкой на память. 
  Эффективные адреса в NASM имеют очень простой синтаксис: они содержат выражение 
  (в результате вычислений которого получается нужный адрес), обрамленное квадратными 
  скобками. Например: </p>
<pre><font color="#666666">wordvar   dw 123 
     mov ax,[wordvar] 
     mov ax,[wordvar+1] 
     mov ax,[es:wordvar+bx]</font></pre>
<p>Любая другая ссылка, не соответствующая этой простой системе, для NASM недействительна, 
  например<font color="#000099"> es:wordvar[bx]</font>. </p>
<p>Более сложные эффективные адреса, когда вовлечено более одного регистра, работают 
  точно также: </p>
<pre><font color="#666666">     mov eax,[ebx*2+ecx+offset] 
     mov ax,[bp+di+8]</font></pre>
<p>NASM способен воспринимать алгебру таких выражений, поэтому он правильно транслирует 
  вещи, выглядящие <i>на первый взгляд</i> недопустимыми: </p>
<pre><font color="#666666">     mov eax,[ebx*5]        ; ассемблируется как [ebx*4+ebx] 
     mov eax,[label1*2-label2] ; то есть [label1+(label1-label2)]</font></pre>
<p>Некоторые варианты эффективных адресов имеют более одной ассемблерной формы; 
  в большинстве таких ситуаций NASM будет генерировать самую короткую из них. 
  Например, у нас имеются простые ассемблерные инструкции <font color="#000099">[eax*2+0]</font> 
  и <font color="#000099">[eax+eax]</font>. NASM будет генерировать последнюю 
  из них, т.к. первый вариант требует дополнительно 4 байта для хранения нулевого 
  смещения. </p>
<p>NASM имеет механизм подсказок, позволяющий создавать из <font color="#000099">[eax+ebx]</font> 
  и <font color="#000099">[ebx+eax]</font> разные инструкции; это порой полезно, 
  т.к. например <font color="#000099">[esi+ebp]</font> и <font color="#000099">[ebp+esi]</font> 
  по умолчанию имеют разные сегментные регистры. </p>
<p>Несмотря на это, вы можете заставить NASM генерировать требуемые формы эффективных 
  адресов при помощи ключевых слов <font color="#000099">BYTE, WORD, DWORD</font> 
  и <font color="#000099">NOSPLIT</font>. Если вам нужно, чтобы <font color="#000099">[eax+3]</font> 
  ассемблировалась со смещением в двойное слово, вместо одного байта по умолчанию, 
  вы можете написать <font color="#000099">[dword eax+3]</font>. Точно также при 
  помощи <font color="#000099">[byte eax+offset]</font> вы можете заставить NASM 
  использовать байтовые смещения для небольших значений, не определяемых при первом 
  проходе (см. пример такого кода в <a href="#nasm_ru3_html_section_3_7">параграфе 3.7</a>). 
  В особых случаях, <font color="#000099">[byte eax]</font> будет кодироваться 
  как <font color="#000099">[eax+0]</font> с нулевым байтовым смещением, а <font color="#000099">[dword 
  eax]</font> будет кодироваться с нулевым смещением в двойное слово. Обычная 
  форма, <font color="#000099">[eax]</font>, будет оставлена без смещения. </p>
<p>NASM будет разделять <font color="#000099">[eax*2]</font> на <font color="#000099">[eax+eax]</font>, 
  т.к. это позволяет избежать использования поля смещения и сэкономить некоторое 
  пространство; соответственно, <font color="#000099">[eax*2+offset]</font> будет 
  разделено на <font color="#000099">[eax+eax+offset]</font>. При помощи ключевого 
  слова <font color="#000099">NOSPLIT</font> вы можете запретить такое поведение 
  NASM: <font color="#000099">[nosplit eax*2]</font> будет буквально оттранслировано 
  в <font color="#000099">[eax*2+0]</font>. </p>

<h3><a name="nasm_ru3_html_section-3.4">3.4 Константы</a></h3>
<p>NASM знает четыре различных типа констант: числовые, символьные, строковые 
  и с плавающей точкой. 
<h4><a name="nasm_ru3_html_section-3.4.1">3.4.1 </a>Числовые константы</h4>
<p>Числовая константа &#151; это просто число. NASM позволят определять числа 
  в различных системах счисления и различными способами: вы можете использовать 
  суффиксы <font color="#000099">H, Q</font> и <font color="#000099">B</font> 
  для шестнадцатеричных, восьмеричных и двоичных чисел соответственно; можете 
  использовать для шестнадцатеричных чисел префикс <font color="#000099">0х</font> 
  в стиле С, а также префикс <font color="#000099">$</font> в стиле Borland Pascal. 
  Однако имейте в виду, что префикс <font color="#000099">$</font> может быть 
  также префиксом идентификаторов (см. <a href="#nasm_ru3_html_section_3_1">параграф 3.1</a>), 
  поэтому первой цифрой шестнадцатеричного числа при использовании этого префикса 
  должна быть обязательно цифра, а не буква. </p>
<p>Некоторые примеры числовых констант: </p>
<pre><font color="#666666">     mov ax,100             ; десятичная 
     mov ax,0a2h            ; шестнадцатеричная 
     mov ax,$0a2            ; снова hex: нужен 0 
     mov ax,0xa2            ; опять hex 
     mov ax,777q            ; восьмеричная 
     mov ax,10010011b       ; двоичная</font></pre>
<h4><a name="nasm_ru3_html_section-3.4.2">3.4.2 Символьные константы</a></h4>
<p>Символьная константа содержит от одного до четырех символов, заключенных в 
  одиночные или двойные кавычки. Тип кавычек для NASM несущественен, поэтому если 
  используются одинарные кавычки, двойные могут выступать в роли символа и, соответственно, 
  наоборот. </p>
<p>Символьная константа, содержащая более одного символа, будет загружаться в 
  обратном порядке следования байт: если вы пишете </p>

<pre><font color="#666666">     mov eax,'abcd'</font></pre>
<p>сгенерированной константой будет не <font color="#000099">0x61626364</font>, 
  а <font color="#000099">0x64636261</font>, поэтому если сохранить эту константу 
  в память, а затем прочитать, получится снова <font color="#000099">abcd</font>, 
  но никак не <font color="#000099">dcba</font>. Это также влияет на инструкцию 
  <font color="#000099">CPUID</font> Пентиумов (см. <a href="#nasm_rua_html_section_A_29">section 
  A.29</a>). </p>
<h4><a name="nasm_ru3_html_section-3.4.3">3.4.3 Строковые константы</a></h4>
<p>Строковые константы допустимы только в некоторых псевдо-инструкциях, а именно 
  в семействе <font color="#000099">DB</font> и инструкции <font color="#000099">INCBIN</font>. 
  Строковые константы похожи на символьные, только длиннее. Они обрабатываются 
  как сцепленные друг с другом символьные константы. Так, например, следующие 
  строки кода эквивалентны. </p>
<pre><font color="#666666">     db 'hello'             ; строковая константа
     db 'h','e','l','l','o' ; эквивалент из символьных констант</font></pre>
<p>Следующие строки также эквивалентны: </p>
<pre><font color="#666666">     dd 'ninechars'         ; строковая константа в двойное слово 
     dd 'nine','char','s'   ; три двойных слова 
     db 'ninechars',0,0,0   ; и действительно похоже</font></pre>
<p>Обратите внимание, что когда используется <font color="#000099">db</font>, 
  константа типа <font color="#000099">'ab'</font> обрабатывается как строковая, 
  хотя и достаточно коротка, чтобы быть символьной, потому что иначе db <font color="#000099">'ab'</font> 
  имело бы тот же смысл, какой и <font color="#000099">db 'a'</font>, что глупо. 
  Соответственно, трех- или четырехсимвольные константы, являющиеся операндами 
  инструкции <font color="#000099">dw</font>, обрабатываются также как строки. 
</p>

<h4><a name="nasm_ru3_html_section-3.4.4">3.4.4 Константы с плавающей точкой</a></h4>
<p>Константы с плавающей точкой допустимы только в качестве аргументов <font color="#000099">DD, 
  DQ</font> и <font color="#000099">DT</font>. Выражаются они традиционно: цифры, 
  затем точка, затем возможно цифры после точки, и наконец, необязательная <font color="#000099"> 
  Е</font> с последующей степенью. Точка обязательна, т.к. <font color="#000099">dd 
  1</font> NASM воспримет как объявление целой константы, в то время как <font color="#330099">dd 
  1.0</font> будет воспринята им правильно. </p>
<p>Несколько примеров: </p>
<pre><font color="#666666">     dd 1.2                 ; "простое" число 
     dq 1.e10               ; 10,000,000,000 
     dq 1.e+10              ; синоним 1.e10 
     dq 1.e-10              ; 0.000 000 000 1 
     dt 3.141592653589793238462 ; число pi</font></pre>
<p>В процессе компиляции NASM не может проводить вычисления над константами с 
  плавающей точкой (это сделано с целью переносимости). Несмотря на то, что NASM 
  генерирует код для х86 процессоров, сам по себе ассемблер может работать на 
  любой системе с ANCI C компилятором. Само собой, ассемблер не может гарантировать 
  присутствия устройства, обрабатывающего числа с плавающей точкой в формате Intel, 
  поэтому стало бы необходимо включить собственный полный набор подпрограмм для 
  работы с такими числами, что неизбежно привело бы к значительному увеличению 
  размера самого ассемблера, хотя польза от этого была бы минимальна. </p>

<h3><a name="nasm_ru3_html_section-3.5">3.5 Выражения</a></h3>
<p>Синтаксис выражений NASM подобен синтаксису выражений языка C. </p>
<p>NASM не гарантирует размер целых чисел, используемых для вычисления выражений 
  при компиляции: с тех пор как NASM может вполне успешно компилировать и выполняться 
  на 64-разрядных платформах, не будьте так уверены, что выражения вычисляются 
  в 32-битных регистрах и что можно попробовать умышленно сделать переполнение. 
  Это сработает не всегда. NASM гарантирует только то, что и ANSI C: вы всегда 
  имеете дело <i>как минимум</i> с 32-битными регистрами. </p>
<p>В выражениях NASM поддерживает два специальных символа, позволяющих при вычислениях 
  выражений получать текущую позицию (смещение) ассемблирования: это знаки <font color="#000099">$</font> 
  и <font color="#000099">$$</font>. Знак <font color="#000099">$</font> вычисляет 
  позицию начала строки, содержащей выражение, т.е. вы можете сделать бесконечный 
  цикл при помощи команды <font color="#000099">JMP $</font>. Знак <font color="#000099">$$</font> 
  определяет начало текущей секции (сегмента), поэтому вы можете узнать, как далеко 
  находитесь от начала секции при помощи выражения (<font color="#000099">$-$$</font>). 
</p>
<p>Ниже перечислены арифметические операции NASM в порядке возрастания приоритета. 
</p>
<h4><a name="nasm_ru3_html_section-3.5.1">3.5.1<font color="#000099"> |</font>: Побитовый оператор 
  ИЛИ</a></h4>
<p>Оператор <font color="#000099">|</font> производит побитовую операцию ИЛИ, 
  соответствующую процессорной инструкции <font color="#000099">OR</font>. Побитовое 
  ИЛИ имеет самый низкий приоритет среди арифметических операторов, поддерживаемых 
  NASMом. 
<h4><a name="nasm_ru3_html_section-3.5.2">3.5.2 <font color="#000099">^</font>: Побитовый оператор 
  ИСКЛЮЧАЮЩЕЕ ИЛИ</a></h4>
<p>Оператор <font color="#000099">^</font> обеспечивает выполнение побитовой операции 
  ИСКЛЮЧАЮЩЕЕ ИЛИ. 
<h4><a name="nasm_ru3_html_section-3.5.3">3.5.3 <font color="#000099">&amp;</font>: Побитовый 
  оператор И</a></h4>
<p>Оператор <font color="#000099">&</font> обеспечивает выполнение побитовой операции 
  И. 
<h4><a name="nasm_ru3_html_section-3.5.4">3.5.4 <font color="#000099">&lt;&lt;</font> и <font color="#000099">&gt;&gt;</font>: 
  Операторы сдвига бит</a></h4>
<p><font   color="#000099"><<</font> производит сдвиг бит влево точно так, как 
  это делается в С. Так, <font color="#000099">5<<3</font> обрабатывается как 
  5 умножить на 8, или 40. <font color="#000099">>></font> производит сдвиг бит 
  вправо; в NASM этот сдвиг всегда <i>беззнаковый</i>, поэтому биты, освобождаемые 
  слева в результате сдвига, заполняются нулями, а не старшим знаковым разрядом. 
<h4><a name="nasm_ru3_html_section-3.5.5">3.5.5 <font color="#000099">+</font> и <font color="#0000CC">&#151;</font>: 
  Операторы сложения и вычитания</a></h4>
<p>Операторы <font color="#000099">+</font> и <font color="#000099">&#151;</font> 
  выполняют обычное сложение и вычитание. 
<h4><a name="nasm_ru3_html_section-3.5.6">3.5.6 <font color="#000099">*, /, //, %</font> и <font color="#000099">%%</font>: 
  </a>Умножение и деление</h4>
<p><font   color="#000099">*</font> является оператором умножения. Операторы <font color="#000099">/</font> 
  и <font color="#000099">//</font> обозначают деление: <font color="#0000CC">/</font> 
  соответствует беззнаковому делению, а<font color="#000099"> //</font> &#151; 
  знаковому. Подобно этому, операторы <font color="#000099">%</font> и <font color="#000099">%%</font> 
  обеспечивают соответственно беззнаковое и знаковое получение остатка от деления 
  (взятие по модулю). </p>
<p>NASM, также как и ANSI C, не дает никаких гарантий о физическом смысле знакового 
  оператора взятия по модулю.</p>
<p>Так как символ <font color="#000099">%</font> часто используется макропроцессором, 
  будьте внимательны при применении знакового и беззнакого операторов взятия по 
  модулю &#151; они должны отделяться от других символов строки по крайней мере 
  одним пробелом. </p>
<h4><a name="nasm_ru3_html_section-3.5.7">3.5.7 Унарные операторы: +, -, ~ и SEG</a></h4>
<p>Наивысший приоритет в грамматике выражений NASM имеют операторы, применяемые 
  к одному аргументу: оператор &quot;минус&quot; (<font color="#000099">&#151;</font>) 
  изменяет знак своего операнда, оператор &quot;плюс&quot; (<font color="#000099">+</font>) 
  ничего не делает (введен для симметричности с минусом), оператор &quot;тильда&quot; 
  (<font color="#000099">~</font>) вычисляет дополнение операнда, а оператор <font color="#000099">SEG</font> 
  извлекает сегментный адрес операнда (более подробно описывается в <a href="#nasm_ru3_html_section_3_6">параграфе 
  3.6</a>). 
<h3><a name="nasm_ru3_html_section-3.6">3.6 SEG и WRT</a></h3>
<p>При написании больших 16-битных программ, которые должны быть разделены на 
  несколько сегментов, часто необходимо получить сегментную часть адреса некоторого 
  символа. Для выполнения этой функции в NASM имеется оператор <font color="#000099">SEG</font>. 
</p>
<p>Оператор <font color="#000099">SEG</font> возвращает базу <i>предопределенного</i> 
  сегмента символа, относительно которой вычисляется смещение последнего. Так 
  следующий код </p>
<pre><font color="#666666">     mov ax,seg symbol 
     mov es,ax 
     mov bx,symbol</font></pre>
<p>будет загружать в пару <font color="#000099">ES:BX</font> корректный указатель 
  на символ <font color="#000099">symbol</font>. </p>
<p>Бывают и более сложные случаи: т.к. 16-битные сегменты и группы способны перекрываться, 
  вы возможно захотите иногда сослаться на некоторый символ при помощи базы сегмента, 
  отличного от предопределенного. NASM позволяет это сделать при помощи ключевого 
  слова <font color="#000099">WRT</font> (With Reference To). Например, код </p>
<pre><font color="#666666">     mov ax,weird_seg       ; weird_seg является базой сегмента 
     mov es,ax 
     mov bx,symbol wrt weird_seg</font></pre>
<p>загрузит в <font color="#000099">ES:BX</font> другой, но функционально эквивалентный 
  указатель на символ <font color="#000099">symbol</font>. </p>
<p>NASM поддерживает дальние (межсегментные) вызовы подпрограмм и передачи управления 
  при помощи синтаксиса <font color="#000099">call segment:offset</font>, где 
  <font color="#000099">segment</font> и <font color="#000099">offset</font> являются 
  непосредственными значениями, поэтому для вызова дальней процедуры вы можете 
  использовать следующий синтаксис: </p>
<pre><font color="#666666">     call (seg procedure):procedure 
     call weird_seg:(procedure wrt weird_seg)</font></pre>
<p>(Круглые скобки включены для большей ясности приведенных инструкций. На практике 
  они не нужны). </p>
<p>&nbsp;</p>
<p>NASM также поддерживает синтаксис <font color="#000099">call far</font>, являющийся 
  аналогом первой из выше приведенных инструкций. В этих примерах инструкция <font color="#000099">JMP</font> 
  будет работать также, как <font color="#000099">CALL</font>. </p>
<p>Для объявления дальнего указателя на сегмент данных, вы можете писать: </p>
<pre><font color="#666666">     dw symbol, seg symbol</font></pre>
<p>NASM не поддерживает более удобных аналогов этому объявлению, однако при помощи 
  макропроцессора вы всегда можете их придумать. </p>
<h3><a name="nasm_ru3_html_section-3.7">3.7 Критические выражения</a></h3>
<p>В отличие от TASM и других, NASM является двухпроходным ассемблером; он всегда 
  делает <i>только</i> два прохода. Из-за этого он не способен "справиться" со 
  сложными исходными файлами, требующими три и более проходов. </p>
<p>Первый проход используется для определения размера всех ассемблируемых инструкций 
  и данных, поэтому на втором проходе (где генерируется код) известны адреса всех 
  символов, на которые имеются ссылки. Таким образом, NASM не сможет обработать 
  код, в котором размер зависит от значения символа, объявленного позднее, например: 
</p>
<pre><font color="#666666">          times (label-$) db 0 
label:    db 'Где это я?'</font></pre>
<p>Аргумент <font color="#666666">TIMES</font> в этом случае должен точно рассчитываться 
  для всех меток; NASM воспримет этот пример ошибочным, т.к. он не сможет узнать 
  размер строки с <font color="#000099">TIMES</font>. Для него это будет то же, 
  что и заведомо ошибочный код </p>
<pre><font color="#666666">          times (label-$+1) db 0 
label:    db 'А теперь я где?'</font></pre>
<p>где <i>любое</i> значение аргумента <font color="#000099">TIMES</font> по определению 
  неверно! </p>
<p>NASM отклоняет такой код при помощи концепции т.н. <i>критического выражения</i>, 
  определяемого как выражение, значение которого должно быть рассчитано на первом 
  проходе и которое, следовательно, должно зависеть только от символов, описанных 
  перед ним. Аргумент префикса <font color="#000099">TIMES</font> является критическим 
  выражением; по некоторым причинам аргументы псевдо-инструкций семейства <font color="#000099">RESB</font> 
  также являются критическими выражениями. </p>
<p>Критическое выражение может неожиданно возникнуть в следующем контексте: </p>
<pre><font color="#666666">          mov ax,symbol1 
symbol1   equ symbol2 
symbol2:</font></pre>
<p>На первом проходе NASM не может определить значение <font color="#000099">symbol1</font>, 
  т.к. он объявлен равным <font color="#000099">symbol2</font>, который, в свою 
  очередь, NASM еще "не видит". Соответственно на втором проходе, при обработке 
  строки <font color="#000099">mov ax,symbol1</font> он не способен сгенерировать 
  правильный код, потому что значение <font color="#000099">symbol1</font> остается 
  неизвестным. На следующей строке, увидев <font color="#000099">EQU</font>, NASM 
  сможет определить значение <font color="#000099">symbol1</font>, однако будет 
  уже поздно.</p>
<p>NASM предотвращает возникновение данных проблем, вводя для критических выражений 
  правосторонний оператор <font color="#000099">EQU</font>, при котором объявление 
  <font color="#000099">symbol1</font> будет отбраковано на первом проходе. </p>
<p>Еще одна похожая проблема, связанная с опережающими ссылками: рассмотрите следующий 
  фрагмент кода.</p>
<pre><font color="#666666">          mov eax,[ebx+offset] 
offset    equ 10</font></pre>
<p>На первом проходе NASM должен вычислить длину инструкции <font color="#000099">mov 
  eax,[ebx+offset]</font>, не зная значение <font color="#000099">offset</font>. 
  Он никак не сможет узнать, что смещение <font color="#000099">offset</font> 
  представляет собой малую величину, вписывающуюся в однобайтное поле смещения 
  и что можно "безбоязненно" сгенерировать более короткую форму эффективного адреса. 
  Однако на первом проходе еще не известно, что такое <font color="#000099">offset</font> 
  &#151; это может быть символ в сегменте кода и для него возможно нужна полная 
  четырехбайтовая форма инструкции. Таким образом, размер инструкции рассчитывается 
  исходя из четырехбайтовой адресной части. Сделав это предположение, на втором 
  проходе NASM вынужден оставлять длину инструкции как есть, генерируя при этом 
  не совсем оптимальный код. Данная проблема может быть разрешена путем объявления 
  <font color="#000099">offset</font> <i>перед</i> ее первым использованием или 
  явным указанием на байтовый размер смещения: <font color="#000099">[byte ebx+offset]</font>. 
</p>

<h3><a name="nasm_ru3_html_section-3.8">3.8 Локальные метки</a></h3>
<p>NASM дает специальную трактовку символов, начинающихся с точки. Метка, начинающаяся 
  с точки, обрабатывается как <i>локальная</i>. Это означает, что она неразрывно 
  связана с предыдущей нелокальной меткой. Например: </p>
<pre><font color="#666666">label1    ; некоторый код 
.loop     ; еще какой-то  код 
     jne .loop 
     ret 
label2    ; некоторый код 
.loop     ; еще какой-то  код  
     jne .loop 
     ret</font></pre>
<p>В приведенном фрагменте каждая инструкция <font color="#000099">JNE</font> 
  переходит на строку непосредственно перед ней, т.к. два определения <font color="#000099">.loop</font> 
  остаются разделены в силу того, что каждое связано с предшествующей нелокальной 
  меткой. </p>
<p>Данный способ обработки локальных меток позаимствован из ассемблера DevPac 
  (Amiga); однако NASM делает шаг вперед &#151; он позволяет обращаться к локальным 
  меткам из другой части кода. Это достигается путем описания локальной метки 
  на основе предыдущей нелокальной. Описания <font color="#000099">.loop</font> 
  в примере выше в действительности описывают два разных символа: <font color="#000099">label1.loop</font> 
  и <font color="#000099">label2.loop</font>, поэтому если вам это действительно 
  надо, то можете написать: </p>
<pre><font color="#666666">label3    ; некоторый код 
     ; и т.д. 
     jmp label1.loop</font></pre>
<p>Иногда бывает полезно, например, в макросах &#151; определить метку, на которую 
  можно ссылаться отовсюду, но которая не пересекается с обычным механизмом локальных 
  меток. Такая метка не может быть нелокальной, так как существует последующее 
  описание и ссылки на локальные метки; она также не может быть и локальной, вследствие 
  того, что описывающий ее макрос не будет знать полное имя метки. Для разрешения 
  этой проблемы в NASM введен третий тип меток, которые обычно используются только 
  в описаниях макросов: если метка начинается со специального префикса <font color="#000099">..@</font>, 
  она ничего не делает по отношению к механизму локальных меток. Таким образом, 
  вы можете написать: </p>
<pre><font color="#666666">label1:   ; нелокальная метка 
.local:   ; это label1.local 
..@foo:   ; это специальный символ
label2:   ; другая нелокальная метка 
.local:   ; это label2.local 
     jmp ..@foo             ; переход на три строки вверх</font></pre>
<p>NASM имеет возможность определять другие специальные символы, начинающиеся 
  с двух точек: например, <font color="#000099">..start </font>используется для 
  указания точки входа в объектном формате <font color="#000099">obj</font> (см. 
  <a href="#nasm_ru6_html_section_6_2_6">параграф 6.2.6</a>). </p>

<p align=center><a href="#nasm_ru4_html">Следующая глава</a> | <a href="#nasm_ru2_html">Предыдущая 
  глава </a> | <a href="#contents_html">Содержание</a>
<hr>

<a name="nasm_ru4_html"></a>
<h1 align=center>Расширенный ассемблер: NASM</h1>

<p align=center><a href="#nasm_ru5_html">Следующая глава </a> | <a href="#nasm_ru3_html">Предыдущая 
  глава</a> | <a href="#contents_html">Содержание</a> | Указатель
</p>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr> 
    <td width="60%"> 
      <h2><a name="nasm_ru4_html_chapter-4">Глава 4: Препроцессор NASM</a></h2>
    </td>
    <td> 
      <div align="right"><font size="-1" color="#666666">Перевод: <a href="http://asmdev.narod.ru/asmos.html">AsmOS 
        group</a>, &copy; 2001</font></div>
    </td>
  </tr>
</table>
NASM содержит мощный макропроцессор, поддерживающий условное ассемблирование, 
многоуровневое включение файлов, две формы макро-определений (однострочные и многострочные) 
и механизм "контекстного стека", расширяющий возможности макро-определений (далее 
√ макросы). Все директивы препроцессора начинаются со знака <font color="#000099">%</font>. 
<h3><a name="nasm_ru4_html_section-4.1">4.1 Однострочные макросы</a></h3>
<h4><a name="nasm_ru4_html_section-4.1.1">4.1.1 Обычный способ: <font color="#000099">%define</font></a></h4>
<p>Однострочные макросы описываются при помощи директивы препроцессора <font color="#000099">%define</font>. 
  Определения работают подобно языку С; т.е. вы можете сделать что-то наподобие 
</p>
<pre><font color="#666666">%define ctrl 0x1F &amp; 
%define param(a,b) ((a)+(a)*(b)) 
          mov byte [param(2,ebx)], ctrl 'D'</font></pre>
<p>что будет развернуто в </p>
<pre><font color="#666666">          mov byte [(2)+(2)*(ebx)], 0x1F &amp; 'D'</font></pre>
<p>Если однострочный макрос содержит символы, вызывающие другой макрос, то развертывание 
  первого осуществляется в процессе вызова, а не при определении. Так, код</p>
<pre><font color="#666666">%define a(x) 1+b(x) 
%define b(x) 2*x 
          mov ax,a(8)</font></pre>
<p>будет обработан как и ожидается &#151; <font color="#000099">mov ax,1+2*8</font>, 
  несмотря на то, что при описании <font color="#000099">a</font> макрос <font color="#000099">b</font> 
  еще не определен. </p>
<p>Макросы, описываемые конструкцией <font color="#000099">%defin</font>e, регистрочувствительны: 
  после <font color="#000099">%define foo bar</font> только <font color="#000099">foo</font> 
  будет развернуто в <font color="#000099">bar</font>, но никак не <font color="#000099">Foo</font> 
  или <font color="#000099">FOO</font>. При использовании вместо <font color="#000099">%define</font> 
  конструкции <font color="#000099">%idefine</font> ('<font color="#000099">i</font>' 
  от слова 'insensitive') вы можете сразу описать все варианты комбинации строчных 
  и прописных букв в имени макроса, поэтому <font color="#000099">%idefine foo 
  bar</font> будет развертывать в <font color="#000099">bar</font> не только <font color="#000099">foo</font>, 
  но и <font color="#000099">Foo, FOO, fOO</font> и т.п. </p>
<p>Существует механизм, следящий за рекурсивным развертыванием макросов, предотвращающий 
  циклические ссылки и бесконечные циклы. Когда это случается, препроцессор будет 
  развертывать только первое вхождение макроса. Так, в коде </p>
<pre><font color="#666666">%define a(x) 1+a(x) 
          mov ax,a(3)</font></pre>
<p>макрос <font color="#000099">a(3)</font> будет развернут единожды, т.е. в конструкцию 
  <font color="#000099">1+a(3)</font> и дальнейшее развертывание производиться 
  не будет. Данная возможность может быть полезна: в <a href="#nasm_ru8_html_section_8_1">параграфе 
  8.1</a> имеется соответствующий пример. </p>
<p>Вы можете перегружать однострочные макросы: если вы напишете </p>
<pre><font color="#666666">%define foo(x) 1+x 
%define foo(x,y) 1+x*y</font></pre>
<p>препроцессор, подсчитав передаваемые вами параметры, корректно обработает оба 
  типа вызова макроса: <font color="#000099">foo(3)</font> будет развернуто в 
  <font color="#000099">1+3</font>, в то время как <font color="#000099">foo(ebx,2)</font> 
  &#151; в <font color="#000099">1+ebx*2</font>. В то же время, если вы напишете 
</p>
<pre><font color="#666666">%define foo bar</font></pre>
<p>последующие описания <font color="#000099">foo</font> будут запрещены: макрос 
  без параметров не допускает описание макроса с тем же именем, но с <i>параметрами</i>, 
  и наоборот. </p>
<p>Несмотря на это, <i>переопределение</i> однострочных макросов не запрещается: 
  вы можете легко описать макрос как </p>
<pre><font color="#666666">%define foo bar</font></pre>
<p>и затем, в том же самом исходном файле, переопределить его как </p>
<pre><font color="#666666">%define foo baz</font></pre>
<p>Когда макрос <font color="#000099">foo</font> будет вызван, он развернется 
  в соответствии с самым поздним своим описанием. Это полезно в основном при описании 
  однострочных макросов с конструкцией <font color="#000099">%assign</font> (см. 
  <a href="#nasm_ru4_html_section_4_1_4">параграф 4.1.4</a>). </p>
<p>Вы можете переопределить однострочный макрос при помощи ключа '<font color="#000099">-d</font>' 
  командной строки NASM: см. <a href="#nasm_ru2_html_section_2_1_8">параграф 2.1.8</a>. 
</p>
<p>При описании однострочных макросов вы можете объединять строки при помощи псевдо-оператора 
  <font color="#000099">%+</font>. Например: </p>
<pre><font color="#666666">%define _myfunc _otherfunc 
%define cextern(x) _ %+ x 
cextern (myfunc)</font></pre>
<p>После первого развертывания третья строка примет вид "<font color="#000099">_myfunc</font>". 
  При дальнейшей обработке препроцессор развернет эту строку в "<font color="#000099">_otherunc</font>". 
</p>
<p>
<h4><a name="nasm_ru4_html_section-4.1.2">4.1.2 Однострочные макросы раннего связыванияs: <font color="#000099">%xdefine</font></a></h4>
<p>Механизм <font color="#000099">%define</font>, описанный в предыдущем параграфе, 
  обеспечивает описание однострочных макросов с <i>поздним связыванием</i>, при 
  котором ссылки на другие макросы разворачиваются при их вызове, поэтому если 
  вы в это время измените внутренний макрос, значение развернутого макроса соответственно 
  изменится. Это свойство полезно, но в некоторых случаях нежелательно. Например: 
</p>
<pre><font color="#666666">%assign ofs 0 
%macro arg 1 
        %xdefine %1 dword [esp+ofs] 
        %assign ofs ofs+4 
%endmacro 
        arg  a 
        arg  b</font>
</pre>
<p>Если в этом примере вместо <font color="#000099">%xdefine</font> мы используем 
  <font color="#000099">%define</font>, оба макроса будут развернуты в одно и 
  то же значение <font color="#000099">dword [esp+8]</font>, что неверно. При 
  использовании конструкции <font color="#000099">%xdefine</font> макрос разворачивается 
  во время его определения, поэтому <font color="#000099">a</font> будет развернуто 
  в <font color="#000099">dword [esp+0]</font>, а <font color="#000099">b</font> 
  &#151; в <font color="#000099">dword [esp+4]</font>. </p>
<p>Макрос <font color="#000099">%xdefine</font> имеет нечувствительный к регистру 
  эквивалент <font color="#000099">%ixdefine</font>, работающий так же, как и 
  <font color="#000099">%idefine</font> по отношению к <font color="#000099">%define</font>. 
</p>
<h4><a name="nasm_ru4_html_section-4.1.3">4.1.3 Отмена определения макроса: <font color="#000099">%undef</font></a></h4>
<p>Команда <font color="#000099">%undef</font> удаляет однострочные макросы. Например, 
  следующая последовательность: </p>
<pre><font color="#666666">%define foo bar 
%undef foo 
        mov eax, foo</font>
</pre>
<p>будет развернута в инструкцию <font color="#000099">mov eax, foo</font>, так 
  как после <font color="#000099">%undef</font> макрос <font color="#000099">foo</font> 
  больше не определен. </p>
<p>Отмена определения предопределенных макросов может быть осуществлена при помощи 
  ключа '<font color="#000099">-u</font>' командной строки NASM: см. <a href="#nasm_ru2_html_section_2_1_9">параграф 
  2.1.9</a>. </p>
<h4><a name="nasm_ru4_html_section-4.1.4">4.1.4 Переменные препроцессора: <font color="#000099">%assign</font></a></h4>
<p>Альтернативным способом определения однострочных макросов является использование 
  директивы <font color="#000099">%assign</font> (и ее нечувствительного к регистру 
  эквивалента <font color="#000099">%iassign</font>, отличающегося от <font color="#000099">%assign</font> 
  тем же самым, чем <font color="#000099">%idefine</font> отличается от <font color="#000099">%define</font>). 
</p>
<p>Данная директива используется для определения однострочного макроса без параметров, 
  но включающего числовое значение. Это значение может быть задано в форме выражения 
  и обрабатывается оно только один раз &#151; при обработке директивы <font color="#000099">%assign</font>. 
</p>
<p>Как и в случае <font color="#000099">%define</font>, макрос, определенный при 
  помощи <font color="#000099">%assign</font>, может быть позднее переопределен, 
  например следующая строка </p>
<pre><font color="#666666">%assign i i+1</font></pre>
<p>увеличивает числовое значение макроса. </p>
<p><font  color="#000099">%assign</font> полезна для контроля завершения препроцессорных 
  циклов <font color="#000099">%rep</font>: пример этого см. в <a href="#nasm_ru4_html_section_4_4">параграфе 
  4.4</a>. Другие примеры применения <font color="#000099">%assign</font> можно 
  найти в <a href="#nasm_ru7_html_section_7_4">параграфе 7.4</a> и <a href="#nasm_ru8_html_section_8_1">парарафе 
  8.1</a>. </p>
<p>Выражение, передаваемое <font color="#000099">%assign</font>, является критическим 
  (см. <a href="#nasm_ru3_html_section_3_7">параграф 3.7</a>) и должно на выходе 
  давать просто число (не включая в себя различные перемещающиеся ссылки наподобие 
  адресов кода и данных). </p>
<h3><a name="nasm_ru4_html_section-4.2">4.2 Многострочные макросы: <font color="#000099">%macro</font></a></h3>
<p>Многострочные макросы в большинстве своем похожи на макросы в MASM и TASM: 
  определение многострочного макроса в NASM выглядит похоже. </p>
<pre><font color="#666666">%macro prologue 1 
          push ebp 
          mov ebp,esp 
          sub esp,%1 
%endmacro</font>
</pre>
<p>Здесь определяется как макрос С-подобная функция <font color="#000099">prologue</font>: 
  теперь вы можете вызвать макрос следующим образом: </p>
<pre><font color="#666666">myfunc:   prologue 12</font></pre>
<p>что будет развернуто в три строки кода </p>

<pre><font color="#666666">myfunc:   push ebp 
          mov ebp,esp 
          sub esp,12</font>
</pre>
<p>Число 1 после имени макроса в строке <font color="#000099">%macro</font> определяет 
  число параметров, которые ожидает получить макрос <font color="#000099">prologue</font>. 
  Конструкция <font color="#000099">%1</font> внутри тела макроса ссылается на 
  первый передаваемый параметр. В случае макросов, принимающих более одного параметра, 
  ссылка на них осуществляется как <font color="#000099">%2,%3</font> и т.д. </p>
<p>Многострочные макросы, как и однострочные, чувствительны к регистру символов, 
  за исключением случая, когда вы примените альтернативную директиву <font color="#000099">%imacro</font>.</p>
<p>Если вам требуется передать в многострочный макрос запятую в качестве составной 
  части параметра, вы можете сделать это, заключив параметр в фигурные скобки. 
  Например: </p>
<pre><font color="#666666">%macro silly 2 
%2:       db %1 
%endmacro 
          silly 'a', letter_a    ; letter_a:  db 'a' 
          silly 'ab', string_ab  ; string_ab: db 'ab' 
          silly {13,10}, crlf    ; crlf:      db 13,10</font>
</pre>
<h4><a name="nasm_ru4_html_section-4.2.1">4.2.1 Перегрузка многострочных макросов</a></h4>
<p>Многострочные макросы, как и однострочные, могут быть перегружены путем определения 
  одного и того же имени несколько раз с разным числом параметров. В отличие от 
  однострочных макросов, здесь не делается исключений даже для макросов без параметров. 
  Так, вы можете написать </p>

<pre><font color="#666666">%macro prologue 0 
          push ebp 
          mov ebp,esp 
%endmacro</font>
</pre>
<p>для определения альтернативной формы функции-пролога, не выделяющей место в 
  стеке.</p>
<p>Иногда вам может захотеться "перегрузить" процессорные инструкции; например, 
  если вы определите </p>

<pre><font color="#666666">%macro push 2 
          push %1 
          push %2 
%endmacro</font>
</pre>
<p>позже вы сможете написать </p>

<pre><font color="#666666">          push ebx               ; эта строка не вызов макроса! 
          push eax,ecx           ; а это - вызов</font>
</pre>
<p>По умолчанию NASM будет выдавать предупреждение при обработке первой из этих 
  строк, так как <font color="#000099">push</font> теперь определена как макрос 
  и вызывается с числом параметров, определения для которого нет. При этом будет 
  сгенерирован корректный код, однако ассемблер даст предупреждение. Данное предупреждение 
  можно отключить при помощи ключа командной строки <font color="#000099">-w-macro-params</font> 
  (см. <a href="#nasm_ru2_html_section_2_1_12">параграф 2.1.12</a>). </p>
<h4><a name="nasm_ru4_html_section-4.2.2">4.2.2 Локальные метки в макросах</a></h4>
<p>NASM позволяет внутри определения многострочного макроса описать метки, которые 
  останутся локальными для каждого вызова макроса: при многократном вызове макроса 
  имена меток каждый раз будут изменяться. Описание такой метки осуществляется 
  при помощи префикса <font color="#000099">%%</font>. Например, вы можете описать 
  инструкцию, выполняющую <font color="#000099">RET</font> если флаг <font color="#000099">Z</font> 
  установлен, следующим образом: </p>

<pre><font color="#666666">%macro retz 0 
          jnz %%skip 
          ret 
%%skip: 
%endmacro</font>
</pre>
<p>После этого вы можете вызывать этот макрос столько раз, сколько нужно, и при 
  этом в каждом вызове вместо метки <font color="#000099">%%skip</font> NASM будет 
  подставлять разные "реальные" имена. NASM создает имена в форме <font color="#000099">..@2345.skip</font>, 
  где число <font color="#000099">2345</font> изменяется при каждом вызове макроса. 
  Префикс <font color="#000099">..@</font> предотвращает пересечение имен локальных 
  меток макросов с механизмом обычных локальных меток, описанным в <a href="#nasm_ru3_html_section_3_8">параграфе 
  3.8</a>. В связи с этим вам нужно избегать определения собственных меток в такой 
  форме (префикс <font color="#000099">..@</font>, затем число, затем точка), 
  иначе они могут совпасть с локальными метками макросов. </p>
<h4><a name="nasm_ru4_html_section-4.2.3">4.2.3 Поглощающие параметры макросов</a></h4>
<p>Иногда полезно определить макрос, собирающий всю командную строку в один параметр 
  после извлечения одного или двух небольших параметров из начала очереди. Примером 
  здесь может служить макрос, записывающий строку в файл MS-DOS, где вы можете 
  захотеть написать что-то вроде </p>
<pre><font color="#666666">          writefile [filehandle],"Привет, фуфел!",13,10</font></pre>
<p>NASM позволяет определить последний параметр макроса в качестве поглощающего. 
  Это означает, что если вы вызовете макрос с большим числом параметров, чем ожидалось, 
  все "лишние" параметры вместе с разделительными запятыми присоединятся к последнему 
  ожидаемому параметру. Так, если вы напишете: </p>
<pre><font color="#666666">%macro writefile 2+ 
          jmp %%endstr 
%%str:    db %2 
%%endstr: mov dx,%%str 
          mov cx,%%endstr-%%str 
          mov bx,%1 
          mov ah,0x40 
          int 0x21 
%endmacro</font>
</pre>
<p>то приведенный выше пример вызова макроса <font color="#000099">writefile</font> 
  будет работать как нужно: текст перед первой запятой <font color="#000099">[filehandle]</font> 
  используется в качестве первого параметра и развернется, когда встретится ссылка 
  <font color="#000099">%1</font>, весь последующий текст объединится в <font color="#000099">%2</font> 
  и расположится после <font color="#000099">db</font>. </p>
<p>Поглощающая природа макроса указывается в NASM при помощи знака (+) после количества 
  параметров в строке <font color="#000099">%macro</font>. </p>
<p>При определении поглощающего макроса вы тем самым говорите NASM, как он должен 
  разворачивать <i>любое</i> число параметров свыше явно указанного; в приведенном 
  случае, например, он будет знать, что должен делать при вызове <font color="#000099">writefile</font> 
  с 2,3,4 или большим числом параметров. NASM также будет это учитывать при перегрузке 
  макросов и не позволит вам определить другую форму <font color="#000099">writefile</font>, 
  принимающую к примеру 4 параметра. </p>
<p>Естественно, приведенный выше макрос может быть реализован и обычным образом 
  (не как поглощающий). В этом случае его вызов должен выглядеть так: </p>

<pre><font color="#666666">          writefile [filehandle], {"Привет, фуфел!",13,10}</font></pre>
<p>NASM поддерживает оба механизма помещения запятых в параметры макроса и вам 
  самим выбирать, какой предпочтительнее в каждом конкретном случае. </p>
<p>В <a href="#nasm_ru5_html_section_5_2_1">параграфе 5.2.1</a> приведен более &quot;продвинутый&quot; 
  способ написания рассмотренного макроса</p>

<h4><a name="nasm_ru4_html_section-4.2.4">4.2.4 Параметры макросов по умолчанию</a></h4>
<p>NASM позволяет также определять многострочный макрос с указанием диапазона 
  допустимого количества параметров. Если вы используете эту возможность, то можете 
  задать значения по умолчанию для пропускаемых параметров. Например: </p>
<pre><font color="#666666">%macro die 0-1 "Полный кабздец твоей проге, фуфел!" 
          writefile 2,%1 
          mov ax,0x4c01 
          int 0x21 
%endmacro</font>
</pre>
<p>Данный макрос (использующий макрос <font color="#000099">writefile</font>, 
  описанный в <a href="#nasm_ru4_html_section_4_2_3">параграфе 4.2.3</a>) может быть вызван 
  как с явно указанным сообщением об ошибке, помещаемым в выходной поток перед 
  закрытием, так и без параметров. В последнем случае в качестве параметра будет 
  подставлено сообщение по умолчанию, введенное при определении макроса. </p>
<p>Обычно для макроса данного типа вы задаете минимальное и максимальное число 
  параметров; минимальное число &#151; это параметры, требующиеся при вызове макроса, 
  а для остальных вы задаете значения по умолчанию. Так, если определение макроса 
  начинается со строки </p>

<pre><font color="#666666">%macro foobar 1-3 eax,[ebx+2]</font></pre>
<p>то он может быть вызван с числом параметров от одного до трех; при этом параметр 
  <font color="#000099">%1</font> всегда берется из строки вызова макроса, параметр 
  <font color="#000099">%2</font> (если не задан) примет значение <font color="#000099">eax</font>, 
  а параметр <font color="#000099">%3</font> (если не задан) &#151; значение <font color="#000099">[ebx+2]</font>. 
</p>
<p>Вы не обязаны задавать значения по умолчанию при определении макроса &#151; 
  в этом случае они будут пустые. Это может быть полезно для макросов, принимающих 
  различное число параметров, так как число реально передаваемых параметров вы 
  можете указать при помощи конструкции <font color="#000099">%0</font> (см. <a href="#nasm_ru4_html_section_4_2_5">параграф 
  4.2.5</a> ниже). </p>
<p>Механизм параметров по умолчанию может комбинироваться с механизмом поглощающих 
  параметров; например, описанный выше макрос <font color="#000099">die</font> 
  может быть сделан более продвинутым и полезным путем изменения первой строки 
  определения: </p>

<pre><font color="#666666">%macro die 0-1+ "Полный кабздец твоей проге, фуфел!",13,10</font></pre>
<p>Максимальное число параметров может быть неограниченным, что обозначается как 
  <font color="#000099">*</font>. В этом случае, конечно невозможно предусмотреть 
  полный набор параметров по умолчанию. Примеры такого типа макросов см. в <a href="#nasm_ru4_html_section_4_2_6">параграфе 
  4.2.6</a>. </p>
<h4><a name="nasm_ru4_html_section-4.2.5">4.2.5 <font color="#000099">%0</font>: Счетчик макро-параметров</a></h4>
<p>Параметр <font color="#000099">%0</font> возвращает числовую константу, представляющую 
  собой количество передаваемых в макрос параметров. Он может использоваться как 
  аргумент для <font color="#000099">%rep</font> (см. <a href="#nasm_ru4_html_section_4_4">параграф 
  4.4</a>) с целью перебора всех параметров макроса. Примеры см. в <a href="#nasm_ru4_html_section_4_2_6">параграфе 
  4.2.6</a> ниже. 
<h4><a name="nasm_ru4_html_section-4.2.6">4.2.6 <font color="#000099">%rotate</font>: "Вращение" 
  параметров макросов</a></h4>
<p>Unix-программисты знакомы с командой <font color="#000099">shift</font> оболочки, 
  позволяющей "сдвигать" переданные шелл-скриптом аргументы (<font color="#000099">$1, 
  $2</font> и т.д.) так, что аргумент, имевший до этого ссылку <font color="#000099">$2</font>, 
  получает ссылку <font color="#000099">$1</font>, а имевший ссылку <font color="#000099">$1</font>, 
  становится недоступен. </p>
<p>NASM обеспечивает подобный механизм при помощи <font color="#000099">%rotate</font>. 
  Как видно по имени, эта команда отличается от команды Unix тем, что параметры 
  не теряются: "выталкиваемые" с левого конца списка аргументов, они появляются 
  на правом, и наоборот. </p>
<p><font  color="#000099">%rotate</font> вызывается с одним числовым аргументом 
  (который может быть выражением). Параметры макроса "вращаются" влево на количество 
  мест, указанных аргументом. Если аргумент отрицателен, параметры вращаются вправо.</p>
<p>Например, пара макросов для сохранения и восстановления набора регистров может 
  работать так: </p>

<pre><font color="#666666">%macro multipush 1-* 
%rep %0 
          push %1 
%rotate 1 
%endrep 
%endmacro</font>
</pre>
<p>Этот макрос вызывает инструкцию <font color="#000099">PUSH</font> для каждого 
  аргумента, слева-направо. Начинается это дело с сохранения первого аргумента, 
  <font color="#000099">%1</font>, затем вызывается <font color="#000099">%rotate</font> 
  для перемещения всех аргументов на один шаг влево, так что изначально второй 
  аргумент становится доступен как <font color="#000099">%1</font>. Повторение 
  данной процедуры для всего набора аргументов (достигается это передачей <font color="#000099">%0</font> 
  как аргумента для <font color="#000099">%rep</font>) позволяет сохранить каждый 
  из них. </p>
<p>Обратите внимание на использование звездочки (<font color="#000099">*</font>) 
  в качестве максимального числа параметров. Это означает, что число передаваемых 
  макросу <font color="#000099">multipush</font> параметров не ограничено. </p>
<p>Удобно иметь под рукой и обратный макрос, извлекающий регистры из стека, особенно 
  если он не требует передавать ему аргументы в обратном порядке относительно 
  <font color="#000099">PUSH</font>. В идеале вы будете помещать в текст программы 
  вызов макроса <font color="#000099">multipush</font>, затем копировать эту строку, 
  вставлять ее туда, где требуется извлечение из стека и заменять имя вызываемого 
  макроса на <font color="#000099">multipop</font>. И этот макрос будет извлекать 
  регистры со стека в порядке, обратном тому, в каком их туда поместили. </p>
<p>Все это может быть реализовано при помощи следующего определения: </p>

<pre><font color="#666666">%macro multipop 1-* 
%rep %0 
%rotate -1 
          pop %1 
%endrep 
%endmacro</font>
</pre>
Данный макрос начинает работу с поворота своих аргументов <i>вправо</i>, поэтому 
исходный <i>последний</i> аргумент становится аргументом <font color="#000099">%1</font>. 
Затем этот аргумент извлекается из стека, список аргументов снова поворачивается 
вправо и теперь аргументом <font color="#000099">%1</font> становится аргумент, 
бывший в начале предпоследним. Таким образом, аргументы извлекаются из стека в 
обратном порядке. 
<h4><a name="nasm_ru4_html_section-4.2.7">4.2.7 Объединение параметров макросов</a></h4>
<p>NASM может объединять параметры макросов с окружающим их текстом. Это позволяет 
  при определении макроса объявлять, например семейства символов. Если вы, например, 
  захотите создать таблицу кодов клавиш вместе со смещениями в этой таблице, вы 
  можете написать: </p>

<pre><font color="#666666">%macro keytab_entry 2 
keypos%1 equ $-keytab 
          db %2 
%endmacro 
keytab: 
          keytab_entry F1,128+1 
          keytab_entry F2,128+2 
          keytab_entry Return,13</font>
</pre>
<p>Это будет развернуто следующим образом: </p>

<pre><font color="#666666">keytab: 
keyposF1 equ $-keytab 
          db 128+1 
keyposF2 equ $-keytab 
          db 128+2 
keyposReturn equ $-keytab 
          db 13</font>
</pre>
<p>Точно также можно присоединять текст к другому концу параметра, написав <font color="#000099">%1foo</font>. 
</p>
<p>Если вам требуется присоединить к параметру макроса <i>цифру</i>, например 
  для определения меток <font color="#000099">foo1</font> и <font color="#000099">foo2</font> 
  при передаче параметра <font color="#000099">foo</font>, вы не можете написать 
  <font color="#000099">%11</font>, так как это будет воспринято как одиннадцатый 
  параметр макроса. Вместо этого вы должны написать <font color="#000099">%{1}1</font>, 
  где первая единица (определяющая номер параметра макроса) будет отделена от 
  второй (представляющей собой присоединяемый к параметру текст). </p>
<p>Объединение может быть применено и к другим встраиваемым объектам препроцессора, 
  таким как локальные метки макросов (<a href="#nasm_ru4_html_section_4_2_2">параграф 4.2.2</a>) 
  и контекстно-локальные метки (<a href="#nasm_ru4_html_section_4_6_2">параграф 4.6.2</a>). 
  В любом случае, неопределенность синтаксиса может быть разрешена путем заключения 
  всего, находящегося после знака <font color="#000099">%</font> и перед присоединяемым 
  текстом, в фигурные скобки: <font color="#000099">%{%foo}bar</font> прицепит 
  текст <font color="#000099">bar</font> к действительному имени локальной метки 
  <font color="#000099">%%foo</font>. (Это вообще-то излишне, так как форма, используемая 
  NASM для генерации реальных имен локальных макро-меток подразумевает, что и 
  <font color="#000099">%{%foo}bar</font>, и <font color="#000099">%%foobar</font> 
  будут развернуты в одно и то же, однако возможность существует). </p>

<h4><a name="nasm_ru4_html_section-4.2.8">4.2.8 </a>Коды условий в качестве параметров макросов</h4>
<p>NASM может особым образом обрабатывать параметры макросов, содержащие коды 
  условий. Во первых, вы можете ссылаться на макро-параметр <font color="#000099">%1</font> 
  при помощи альтернативного синтаксиса <font color="#000099">%+1</font>, информирующего 
  NASM о том, что этот параметр содержит код условия и заставляющего препроцессор 
  сообщать об ошибке, если макрос вызывается с параметром, <i>не являющимся</i> 
  действительным кодом условия. </p>
<p>Однако более полезной возможностью является ссылка на макро-параметр вида <font color="#000099">%-1</font>, 
  которую NASM будет разворачивать как обратный код условия. Так, макрос <font color="#000099">retz</font>, 
  описанный в <a href="#nasm_ru4_html_section_4_2_2">параграфе 4.2.2</a>, может быть заменен 
  макросом условного возврата более общего вида: </p>

<pre><font color="#666666">%macro retc 1 
          j%-1 %%skip 
          ret 
%%skip: 
%endmacro</font>
</pre>
<p>Данный макрос может быть теперь вызван как <font color="#000099">retc ne</font>, 
  что будет развернуто в инструкцию условного перехода <font color="#000099">JE</font>, 
  или как <font color="#000099">retc po</font>, что будет преобразовано в переход 
  <font color="#000099">JPE</font>. </p>
<p>Ссылка <font color="#000099">%+1</font> на макро-параметр может вполне спокойно 
  интерпретировать аргументы <font color="#000099">CXZ</font> и <font color="#000099">ECXZ</font> 
  как правильные коды условий; однако если передать эту лабуду ссылке <font color="#000099">%-1</font>, 
  будет сообщено об ошибке, так как обратных кодов условий к таким параметрам 
  не существует. </p>
<h4><a name="nasm_ru4_html_section-4.2.9">4.2.9 Подавление развертывания макросов в листинге</a></h4>
<p>Когда NASM генерирует из программы файл листинга, он обычно разворачивает многострочные 
  макросы посредством записи макро-вызова и последующим перечислением каждой строки, 
  полученной в результате развертывания. Это позволяет увидеть, как генерируются 
  инструкции из макроса в реальный код; однако для некоторых макросов данное загромождение 
  листинга не требуется. </p>
<p>NASM предусматривает для этой цели спецификатор <font color="#000099">.nolist</font>, 
  который вы можете включить в определение макроса с целью подавления развертывания 
  макроса в файле листинга. Спецификатор <font color="#000099">.nolist</font> 
  ставится сразу после количества параметров, например так: </p>

<pre><font color="#666666">%macro foo 1.nolist</font></pre>
<p>Или так: </p>
<pre><font color="#666666">%macro bar 1-5+.nolist a,b,c,d,e,f,g,h</font></pre>
<h3><a name="nasm_ru4_html_section-4.3">4.3 Условное ассемблирование</a></h3>
<p>Как и препроцессор языка С, NASM позволяет ассемблировать отдельные секции 
  исходного файла только тогда, когда выполняются определенные условия. Синтаксис 
  в общем виде выглядит следующим образом: </p>

<pre><font color="#666666">%if&lt;условие&gt; 
; некоторый код, ассемблируемый только при выполнении &lt;условия&gt;
%elif&lt;условие2&gt; 
; ассемблируется, если <условие> не выполняется, а выполняется <условие2> 
%else 
; ассемблируется, если и <условие>, и <условие2> не выполняются 
%endif</font>
</pre>
<p>Оператор <font color="#000099">%else</font> необязателен, так же как и оператор 
  <font color="#000099">%elif</font>. Если нужно, вы можете использовать более 
  одного оператора <font color="#000099">%elif</font>. </p>
<h4><a name="nasm_ru4_html_section-4.3.1">4.3.1 <font color="#000099">%ifdef</font>: Проверка 
  присутствия однострочного макроса</a></h4>
<p>Начинающийся со строки <font color="#000099">%ifdef MACRO</font> условно-ассемблируемый 
  блок будет обрабатываться <i>только</i> в том случае, если определен однострочный 
  макрос <font color="#000099">MACRO</font>. Если он не определен, вместо этого 
  будут обрабатываться блоки <font color="#000099">%elif</font> и <font color="#000099">%else</font> 
  (если они есть). </p>
<p>Например, для отладки программы вы можете захотеть ввести следующий код: </p>

<pre><font color="#666666">          ; выполнение некоторой функции 
%ifdef DEBUG 
          writefile 2,"Функция выполнена полностью.",13,10 
%endif 
          ; выполнение чего-нибудь еще</font>
</pre>
<p>После этого вы можете использовать ключ <font color="#000099">-dDEBUG</font> 
  командной строки для создания версии программы, выдающей отладочные сообщения, 
  а удалив этот ключ &#151; создавать окончательный релиз. </p>
<p>Для осуществления обратной проверки (отсутствия определения макроса) вы можете 
  использовать вместо <font color="#000099">%ifdef</font> оператор <font color="#000099">%ifndef</font>. 
  Вы можете также тестировать наличие определения макроса в блоках <font color="#000099">%elif</font> 
  при помощи операторов <font color="#000099">%elifdef</font> и <font color="#000099">%elifndef</font>. 
</p>
<h4><a name="nasm_ru4_html_section-4.3.2">4.3.2 <font color="#000099">%ifctx</font>: Проверка 
  контекстного стека</a></h4>
<p>Конструкция условного ассемблирования <font color="#000099">%ifctx ctxname</font> 
  предполагает обработку идущего вслед за ней кода только тогда, когда на вершине 
  контекстного стека препроцессора находится имя <font color="#000099">ctxname</font>. 
  Как и в случае с <font color="#000099">%ifdef</font>, поддерживаются также формы 
  <font color="#000099">%ifnctx,%elifctx</font> и <font color="#000099">%elifnctx</font>. 
</p>
<p>Более подробно о контекстном стеке можно узнать в <a href="#nasm_ru4_html_section_4_6">параграфе 
  4.6</a>. а пример использования <font color="#000099">%ifctx</font> приведен 
  в <a href="#nasm_ru4_html_section_4_6_5">параграфе 4.6.5</a>.</p>
<h4><a name="nasm_ru4_html_section-4.3.3">4.3.3 <font color="#000099">%if</font>: Проверка произвольных 
  числовых выражений</a></h4>
<p>Конструкция условного ассемблирования <font color="#000099">%if expr</font> 
  будет вызывать обработку последующего кода <i>только</i> в том случае, если 
  выражение <font color="#000099">expr</font> не нулевое. Примером использования 
  данной конструкции может служить проверка выхода из препроцессорного цикла <font color="#000099">%rep</font>: 
  пример смотрите в <a href="#nasm_ru4_html_section_4_4">параграфе 4.4</a>. </p>
<p>Выражения, указываемые для <font color="#000099">%if</font>, а также его эквивалента 
  <font color="#000099">%elif</font>, являются критическими (см. <a href="#nasm_ru3_html_section_3_7">параграф 
  3.7</a>). </p>
<p><font  color="#000099">%if</font> расширяет обычный синтаксис выражений NASM, 
  предусматривая набор операторов отношения, которые в выражениях обычно запрещены. 
  Операторы <font color="#000099">=, <, >, <=, >=</font> и <font color="#000099"><></font> 
  проверяют на равенство, отношения "меньше чем", "больше чем", "меньше или равно", 
  "больше или равно" и на неравенство соответственно. С-подобные формы <font color="#000099">==</font> 
  и <font color="#000099">!=</font> также поддерживаются и являются альтернативными 
  формами <font color="#000099">=</font> и <font color="#000099"><></font>. И 
  наконец, имеются операторы низкого приоритета <font color="#000099">&&, ^^</font> 
  и <font color="#000099">||</font>, производящие логические операции <font color="#000099">И, 
  ИСКЛЮЧАЮЩЕЕ ИЛИ</font> и <font color="#000099">ИЛИ</font>. Они работают также, 
  как логические операторы в С (за исключением того, что в С нет логического &quot;ИСКЛЮЧАЮЩЕЕ 
  ИЛИ&quot;), то есть возвращают всегда 0 или 1 и обрабатывают любое ненулевое 
  значение как 1 (например, <font color="#000099">^^</font> возвращает 1 только 
  если одно из его входных значений нулевое, а второе &#151; ненулевое). Операторы 
  отношения также возвращают 1 если условие истинно и 0 &#151; если ложно. </p>
<h4><a name="nasm_ru4_html_section-4.3.4">4.3.4 <font color="#000099">%ifidn</font> и <font color="#000099">%ifidni</font>: 
  </a>Проверка на идентичность текста</h4>
<p>Конструкция <font color="#000099">%ifidn text1,text2</font> будет вызывать 
  ассемблирование последующего кода <i>только</i> в том случае, если текст аргументов 
  <font color="#000099">text1</font> и <font color="#000099">text2</font> после 
  развертывания однострочных макросов становится идентичным. Отличия в виде пробелов 
  не считаются. </p>
<p><font  color="#000099">%ifidni</font> подобна <font color="#000099">%ifidn</font>, 
  но нечувствительна к регистру символов. </p>
<p>Например, следующий макрос помещает регистр или число в стек, позволяя при 
  этом обрабатывать <font color="#000099">IP</font> как реальный регистр: </p>

<pre><font color="#666666">%macro pushparam 1 
%ifidni %1,ip 
          call %%label 
%%label: 
%else 
          push %1 
%endif 
%endmacro</font>
</pre>
<p>Как и большинство других <font color="#000099">%if</font>-конструкций, <font color="#000099">%ifidn</font> 
  имеет эквивалент <font color="#000099">%elifidn</font> и обратные формы <font color="#000099">%ifnidn</font> 
  и <font color="#000099">%elifnidn</font>. Соответственно, <font color="#000099">%ifidni</font> 
  имеет эквивалент <font color="#000099">%elifidni</font> и обратные формы <font color="#000099">%ifnidni</font> 
  и <font color="#000099">%elifnidni</font>. </p>
<h4><a name="nasm_ru4_html_section-4.3.5">4.3.5 <font color="#000099">%ifid, %ifnum, %ifstr</font>: 
  Проверка типов символов</a></h4>
<p>Иногда вам может понадобиться, чтобы макросы выполняли различные задачи в зависимости 
  от того, что им передано в качестве аргумента: число, строка или идентификатор. 
  Например, может быть необходимо чтобы макрос смог обрабатывать как строковые 
  константы, так и указатели на уже существующие строки. </p>

<p>Конструкция условного ассемблирования <font color="#000099">%ifid</font>, принимающая 
  один параметр (который может быть пустым), обрабатывает последующий код <i>только</i> 
  в том случае, если первый символ в параметре существует и является идентификатором. 
  <font color="#000099">%ifnum</font> работает аналогично, но проверяет символ 
  на соответствие числовой константе; <font color="#000099">%ifstr</font> тестирует 
  на соответствие символа строке. </p>
<p>Например, описанный в <a href="#nasm_ru4_html_section_4_2_3">параграфе 4.2.3</a> макрос <font color="#000099">writefile</font> 
  может быть расширен для использования преимуществ конструкции <font color="#000099">%ifstr</font> 
  следующим образом: </p>

<pre><font color="#666666">%macro writefile 2-3+ 
%ifstr %2 
          jmp %%endstr 
%if %0 = 3 
%%str:	  db %2,%3 
%else 
%%str:	  db %2 
%endif 
%%endstr: mov dx,%%str 
          mov cx,%%endstr-%%str 
%else 
	  mov dx,%2 
	  mov cx,%3 
%endif 
          mov bx,%1 
          mov ah,0x40 
          int 0x21 
%endmacro</font>
</pre>
<p>После этого макрос <font color="#000099">writefile</font> может "справиться" 
  со следующими двумя своими вызовами: </p>

<pre><font color="#666666">          writefile [file], strpointer, length 
          writefile [file], "Привет!", 13, 10</font>
</pre>
<p>В первом случае <font color="#000099">strpointer</font> используется в качестве 
  адреса уже объявленной строки, а <font color="#000099">length</font> &#151; 
  как длина этой строки. Во втором случае макросу передается строка, которую макрос 
  объявляет и получает ее адрес и длину самостоятельно. </p>
<p>Обратите внимание на использование <font color="#000099">%if</font> внутри 
  <font color="#000099">%ifstr</font>: это нужно для определения того, передано 
  ли макросу 2 аргумента (в этом случае строка &#151; просто константа и ей достаточно 
  <font color="#000099">db %2</font>) или больше (в этом случае все аргументы 
  кроме первых двух объединяются в <font color="#000099">%3</font> и тогда уже 
  требуется <font color="#000099">db %2,%3</font>). </p>
<p>Для всех трех конструкций <font color="#000099">%ifid</font>, <font color="#000099">%ifnum</font> 
  и <font color="#000099">%ifstr</font> существуют соответствующие версии <font color="#000099">%elifXXX, 
  %ifnXXX</font> и <font color="#000099">%elifnXXX</font>. </p>
<h4><a name="nasm_ru4_html_section-4.3.6">4.3.6 <font color="#000099">%error</font>: </a>Сообщения 
  об ошибках, определяемых пользователем</h4>
<p>Директива препроцессора <font color="#000099">%error</font> заставляет NASM 
  сообщать об ошибках, случающихся на стадии ассемблирования. Так, если ваши исходники 
  будет ассемблировать кто-то еще, вы можете проверить, определен ли нужный макрос 
  при помощи следующего кода: </p>

<pre><font color="#666666">%ifdef SOME_MACRO 
; производятся некоторые настройки 
%elifdef SOME_OTHER_MACRO 
; производятся другие настройки 
%else 
%error Не определены ни SOME_MACRO, ни SOME_OTHER_MACRO. 
%endif</font>
</pre>
<p>Таким образом любой пользователь, не знающий, как правильно ассемблировать 
  ваш код, будет быстро предупрежден об этом несоответствии, вместо того, чтобы 
  увидеть крах программы при ее выполнении и не знать, что этот крах вызвало. 
</p>
<h3><a name="nasm_ru4_html_section-4.4">4.4 Препроцессорные циклы: %rep</a></h3>
<p>Несмотря на то,что префикс <font color="#000099">TIMES</font> в NASM весьма 
  удобен, он не может быть использован в многострочных макросах, потому как обрабатывается 
  уже после полного разворачивания последних. Вследствие этого, NASM предусматривает 
  другую форму циклов, работающих на уровне препроцессора, а именно <font color="#000099">%rep</font>. 
</p>
<p>Директивы <font color="#000099">%rep</font> и <font color="#000099">%endrep</font> 
  (<font color="#000099">%rep</font> принимает числовой аргумент или выражение; 
  <font color="#000099">%endrep</font> не принимает никаких аргументов) используются 
  для заключения в них куска кода, который при этом реплицируется столько раз, 
  сколько указано препроцессору: </p>

<pre><font color="#666666">%assign i 0 
%rep 64 
          inc word [table+2*i] 
%assign i i+1 
%endrep</font>
</pre>
<p>Этот пример будет генерировать 64 инструкции <font color="#000099">INC</font>; 
  инкрементируя каждое слово в памяти от <font color="#000099">[table]</font> 
  до <font color="#000099">[table+126]</font>. </p>
<p>Для образования более сложных условий окончания цикла или его принудительного 
  завершения вы можете использовать директиву <font color="#000099">%exitrep</font>, 
  например: </p>

<pre><font color="#666666">fibonacci: 
%assign i 0 
%assign j 1 
%rep 100 
%if j &gt; 65535 
%exitrep 
%endif 
          dw j 
%assign k j+i 
%assign i j 
%assign j k 
%endrep 
fib_number equ ($-fibonacci)/2</font>
</pre>
<p>Этот пример создает список всех чисел Фибоначчи, вписывающихся в размер 16 
  бит. Заметьте, что и в этом случае для <font color="#000099">%rep</font> должно 
  быть указано максимальное число повторов. Это необходимо для того, чтобы NASM 
  на стадии препроцессирования не впал в бесконечный цикл, что (в многозадачных 
  или многопользовательских системах) приводит обычно к быстрому исчерпанию памяти 
  и невозможности запуска других приложений. </p>
<h3><a name="nasm_ru4_html_section-4.5">4.5 Подключение других файлов</a></h3>
<p>Препроцессор NASMа, используя очень похожий на С синтаксис, позволяет подключать 
  к текщему исходнику другие файлы. Это осуществляется при помощи директивы <font color="#000099">%include</font>: 
</p>

<pre><font color="#666666">%include "macros.mac"</font></pre>
<p>Эта строка включит файл <font color="#000099">macros.mac</font> в исходный 
  файл, содержащий директиву <font color="#000099">%include</font>. </p>
<p>Поиск подключаемых файлов производится в текущем каталоге (каталоге, из которого 
  запускается NASM, а не того, где содержатся его исполнимые файлы или где находится 
  исходный файл) и в любых других каталогах, указанных в командной строке NASM 
  при помощи ключа <font color="#000099">-i</font>. </p>
<p>Стандартная идиома С, предотвращающая многократное включение одного и того 
  же файла, точно также срабатывает и в NASM: если файл <font color="#000099">macros.mac</font> 
  имеет форму </p>
<pre><font color="#666666">%ifndef MACROS_MAC 
%define MACROS_MAC 
; какие-то определения и объявления 
%endif</font>
</pre>
<p>то многократное его включение не будет вызывать ошибок, так как после первого 
  включения символ <font color="#000099">MACROS_MAC</font> будет уже определен. 
</p>
<p>При помощи ключа командной строки <font color="#000099">-p</font> (см. <a href="#nasm_ru2_html_section_2_1_7">параграф 
  2.1.7</a>) вы можете подключить файл даже не используя явным образом директиву 
  <font color="#000099">%include</font> в файле-потребителе.</p>
<h3><a name="nasm_ru4_html_section-4.6">4.6 </a>Контекстный стек</h3>
<p>Локальные по отношению к макроопределению метки иногда не обеспечивают необходимую 
  гибкость: вполне возможно, что иногда вы захотите разделить метки между несколькими 
  макровызовами. Примером может служить цикл <font color="#000099">REPEAT ... 
  UNTIL</font>, в котором расширению макроса <font color="#000099">REPEAT</font> 
  может понадобиться ссылаться на метки, определенные в макросе <font color="#000099">UNTIL</font>. 
  Ситуация еще более усложнится, когда вы захотите сделать эти циклы вложенными.</p>
<p>NASM обеспечивает данный уровень гибкости при помощи контекстного стека. Препроцессор 
  поддерживает стек контекстов, каждый из которых характеризуется именем. Добавление 
  нового контекста в стек осуществляется директивой <font color="#000099">%push</font>, 
  а извлечение из стека &#151; директивой <font color="#000099">%pop</font>. Вы 
  можете определять метки, являющиеся локальными по отношению к определенному 
  контексту в стеке. </p>
<h4><a name="nasm_ru4_html_section-4.6.1">4.6.1 <font color="#000099">%push</font> и <font color="#000099">%pop</font>: 
  Создание и удаление контекста</a></h4>
<p>Директива <font color="#000099">%push</font> используется для создания нового 
  контекста и помещения его на вершину контекстного стека. Эта директива требует 
  указания одного аргумента, а именно имени контекста. Например: </p>
<pre><font color="#666666">%push foobar</font></pre>
<p>Эта команда помещает в стек новый контекст <font color="#000099">foobar</font>. 
  Вы можете иметь в стеке несколько контекстов с одним и тем же именем: они все 
  равно будут отличаться друг от друга. </p>
<p>Директива <font color="#000099">%pop</font>, не требующая аргументов, удалает 
  самый верхний контекст из стека и разрушает его вместе с любыми связанными с 
  ним метками. </p>

<h4><a name="nasm_ru4_html_section-4.6.2">4.6.2 Контектно-локальные метки</a></h4>
<p>Точно так же, как использование <font color="#000099">%%foo</font> вводит локальную 
  по отношению к определенному макросу метку, конструкция <font color="#000099">%$foo</font> 
  используется для определения метки, локальной по отношению к контексту на вершине 
  контекстного стека. Таким образом, пример с циклом <font color="#0000CC">REPEAT 
  √ UNTIL</font> может быть реализован следующим образом: </p>
<pre><font color="#666666">%macro repeat 0 
%push repeat 
%$begin: 
%endmacro

%macro until 1 
          j%-1 %$begin 
%pop 
%endmacro</font>
</pre>
<p>Вызовы могут производиться, например, так:</p>
<pre><font color="#666666">          mov cx,string 
          repeat 
          add cx,3 
          scasb 
          until e</font>
</pre>
<p>В этом примере будет сканироваться каждый четвертый байт строки с целью поиска 
  байта, равного <font color="#000099">AL</font>. <i><font color="#FF0066">(Прим.перев. 
  Скорее всего, в примере ошибка)</font></i>. </p>
<p>Если вам требуется определить или получить доступ к меткам, локальным к контексту, 
  находящемуся <i>ниже</i> вершины стека, вы можете использовать <font color="#000099">%$$foo</font>, 
  или <font color="#000099">%$$$foo</font> для еще более "глубокого" контекста 
  и т.д. </p>

<h4><a name="nasm_ru4_html_section-4.6.3">4.6.3 Контекстно-локальные однострочные макросы</a></h4>
<p>NASM позволяет определять однострочные макросы, локальные по отношению к определенному 
  контексту. Например, </p>
<pre><font color="#666666">%define %$localmac 3</font></pre>
<p>будет определять однострочный макрос <font color="#000099">%$localmac</font>, 
  локальный к контексту на вершине стека. Само собой, после создания еще одного 
  контекста директивой <font color="#000099">%push</font>, данный макрос может 
  быть доступен по имени <font color="#000099">%$$localmac</font>. </p>
<h4><a name="nasm_ru4_html_section-4.6.4">4.6.4 <font color="#000099">%repl</font>: </a>Переименование 
  контекста</h4>
<p>Если вам требуется изменить имя контекста, находящегося на вершине стека , 
  вы можете выполнить <font color="#000099">%pop</font> с последующим <font color="#000099">%push</font>; 
  однако это будет иметь "побочный" эффект в виде разрушения всех локальных по 
  отношению к извлеваемому контексту меток и макросов. </p>
<p>В NASM для этой цели предусмотрена директива <font color="#000099">%repl</font>, 
  <i>изменяющая</i> имя контекста без затрагивания связанных с этим контекстом 
  локальных меток и макросов. Теперь вы можете заменить деструктивный код </p>
<pre><font color="#666666">%pop 
%push newname</font>
</pre>
<p>на недеструктивную версию <font color="#000099">%repl newname</font>. </p>
<h4><a name="nasm_ru4_html_section-4.6.5">4.6.5 Пример использования контекстного стека: Блок 
  IF</a></h4>
<p>В данном примере для реализации блока <font color="#000099">IF</font> как набора 
  макросов использованы почти все возможности контекстного стека, включая конструкцию 
  условного ассемблирования <font color="#000099">%ifctx</font>. </p>
<pre><font color="#666666">%macro if 1 
    %push if 
    j%-1 %$ifnot 
%endmacro

</font><font color="#666666">%macro else 0 
    %ifctx if 
        %repl else 
        jmp %$ifend 
        %$ifnot: 
    %else 
        %error "Перед 'else' ожидается 'if' !" 
    %endif 
%endmacro

</font><font color="#666666">%macro endif 0 
    %ifctx if 
        %$ifnot: 
        %pop 
    %elifctx else 
        %$ifend: 
        %pop 
    %else 
        %error "Перед 'endif' ожидается 'if' или 'else'!" 
    %endif 
%endmacro</font>
</pre>
<p>Данный код более устойчив, чем макросы <font color="#000099">REPEAT</font> 
  и <font color="#000099">UNTIL</font> из <a href="#nasm_ru4_html_section_4_6_2">параграфа 4.6.2</a>, 
  так как он использует условное ассемблирование для проверки правильного порядка 
  следования макросов (например, нельзя перед <font color="#000099">if</font> 
  вызвать <font color="#000099">endif</font>) и привлекает директиву <font color="#000099">%error</font>, 
  если порядок нарушен. </p>
<p>Кроме того, макрос <font color="#000099">endif</font> способен справиться сразу 
  с двумя разными условиями: следует ли он сразу за <font color="#000099">if</font> 
  или за <font color="#000099">else</font>. Достигается это опять же за счет условного 
  ассемблирования, при котором производятся разные действия в зависимости от того, 
  что на вершине стека &#151; <font color="#000099">if</font> или <font color="#000099">else</font>. 
</p>
<p>&nbsp;</p>
<p>Макрос <font color="#000099">else</font> должен сохранить контекст в стеке, 
  чтобы метка <font color="#000099">%$ifnot</font>, на которую ссылается <font color="#000099">if</font> 
  была той же самой, что и определенная в макросе <font color="#000099">endif</font>, 
  но в то же время он должен изменить имя контекста, чтобы <font color="#000099">endif</font> 
  знал, что тут поработал <font color="#000099">else</font>. Он делает это при 
  помощи <font color="#000099">%repl</font>. </p>
<p>Пример использования макроса выглядит следующим образом: </p>
<pre><font color="#666666">          cmp ax,bx 
          if ae 
            cmp bx,cx 
            if ae 
              mov ax,cx 
            else 
              mov ax,bx 
            endif 
          else 
            cmp ax,cx 
            if ae 
              mov ax,cx 
            endif 
          endif</font>
</pre>
<p>Макросы блока <font color="#000099">IF</font> совершенно спокойно обрабатывают 
  вложенность посредством сохранения контекста, вводимого внутри <font color="#000099">if</font> 
  поверх контекста, описанного извне <font color="#000099">if</font>; таким образом 
  <font color="#000099">else</font> и <font color="#000099">endif</font> всегда 
  ссылаются на последние <font color="#000099">if</font> или <font color="#000099">else</font>, 
  не имеющие на этот момент пары. </p>
<h3><a name="nasm_ru4_html_section-4.7">4.7 </a>Стандартные макросы</h3>
<p>NASM вводит набор стандартных макросов, которые на момент начала обработки 
  любого исходного файла будут уже определены. Если вам позарез нужно, чтобы программа 
  ассемблировалась без предопределенных макросов, можете для очистки препроцессорного 
  пространства имен использовать директиву <font color="#000099">%clear</font>. 
</p>
<p>Большинство пользовательских директив ассемблера реализованы как макросы, вызывающие 
  примитивные директивы; все они описываются в <a href="#nasm_ru5_html">главе 5</a>. 
  Оставшийся набор стандартных макросов описан ниже. </p>
<h4><a name="nasm_ru4_html_section-4.7.1">4.7.1 <font color="#000099">__NASM_MAJOR__</font> 
  и <font color="#000099">__NASM_MINOR__</font>: Версия NASM</a></h4>
<p>Однострочные макросы <font color="#000099">__NASM_MAJOR__</font> и <font color="#000099">__NASM_MINOR__</font> 
  разворачиваются соответственно в старшую и младшую части номера версии NASM. 
  Так, в NASM 0.96 <font color="#000099">__NASM_MAJOR__</font> будет определен 
  как 0, а <font color="#000099">__NASM_MINOR__</font> &#151; как 96. 
<h4><a name="nasm_ru4_html_section-4.7.2">4.7.2 <font color="#000099">__FILE__</font> и <font color="#000099">__LINE__</font>: 
  Имя файла и номер строки</a></h4>
<p>Как и в препроцессоре С, NASM позволяет пользователю узнать имя файла и номер 
  строки, содержащие текущую инструкцию. Макрос<font color="#000099"> __FILE__</font> 
  разворачивается в строковую константу, представляющую собой имя текущего входного 
  файла (которое в ходе ассемблирования может изменяться, если используется директива 
  <font color="#000099">%include</font>), а <font color="#000099">__LINE__</font> 
  разворачивается в числовую константу, означающую текущий номер строки во входном 
  файле. </p>
<p>Эти макросы могут быть использованы, например, для передачи макросу отладочной 
  информации, так как вызов <font color="#000099">__LINE__</font> внутри макроопределения 
  (неважно, одно- или многострочного) будет возвращать номер строки <i>макровызова</i>, 
  а не строки <i>определения</i>. Так, например, для определения в какой части 
  кода наступает крах, пишется подпрограммка <font color="#000099">stillhere</font>, 
  которой передается в <font color="#000099">EAX</font> номер строки, а на выходе 
  получается что-то вроде "<font color="#000099">строка 155: я еще жива</font>". 
  Затем вы пишете макрос </p>
<pre><font color="#666666">%macro notdeadyet 0 
          push eax 
          mov eax,__LINE__ 
          call stillhere 
          pop eax 
%endmacro</font>
</pre>
<p>и &quot;утыкаете&quot; ваш код вызовами <font color="#000099">notdeadyet</font> 
  до тех пор, пока не найдете точку краха. </p>
<h4><a name="nasm_ru4_html_section-4.7.3">4.7.3 <font color="#000099">STRUC</font> и <font color="#000099">ENDSTRUC</font>: 
  Объявление структурных типов данных</a></h4>
<p>Ядро NASM не содержит внутренних механизмов для определения структур данных; 
  вместо этого сделан довольно мощный препроцессор, который кроме всего прочего 
  способен реализовать структуры данных в виде набора макросов. Для определения 
  структур данных используются макросы <font color="#000099">STRUC</font> и <font color="#000099">ENDSTRUC</font>. 
</p>
<p><font  color="#000099">STRUC</font> принимает один параметр, являющийся именем 
  типа данных. Данное имя описывается как символ со значением 0, затем к нему 
  присоединяется суффикс <font color="#000099">_size</font> и оно определяется 
  как <font color="#000099">EQU</font> с размером структуры. После того, как <font color="#000099">STRUC</font> 
  выполнена, вы описываете структуру данных путем определения полей при помощи 
  семейства псевдо-инструкций <font color="#000099">RESB</font>. В конце описания 
  вы должны вызвать <font color="#000099">ENDSTRUC</font>. </p>
<p>Например, для определения структуры <font color="#000099">mytype</font>, содержащей 
  двойное слово, слово, байт и строку, вы можете написать: </p>
<pre><font color="#666666">          struc mytype 
mt_long:  resd 1 
mt_word:  resw 1 
mt_byte:  resb 1 
mt_str:   resb 32 
          endstruc</font>
</pre>
<p>Данный код определяет шесть символов: <font color="#000099">mt_long</font> 
  как <font color="#000099">0</font> (смещение от начала структуры <font color="#000099">mytype</font> 
  до поля с двойным словом), <font color="#000099">mt_word</font> как <font color="#0000CC">4</font>, 
  <font color="#000099">mt_byte</font> как <font color="#000099">6</font>, <font color="#000099">mt_str</font> 
  как <font color="#000099">7</font>, <font color="#000099">mytype_size</font> 
  как <font color="#000099">39</font> и собственно <font color="#000099">mytype</font> 
  как ноль. </p>
<p>Причиной, по которой имя структуры описывается как ноль, является побочный 
  эффект, позволяющий структурам работать с механизмом локальных меток: если члены 
  вашей структуры имеют метки с именами, совпадающими с именами меток других структур, 
  вы можете переписать приведенный выше код следующим образом: </p>
<pre><font color="#666666">          struc mytype 
.long:    resd 1 
.word:    resw 1 
.byte:    resb 1 
.str:     resb 32 
          endstruc</font>
</pre>
<p>Здесь описываются смещения к полям структуры в виде <font color="#000099">mytype.long</font>, 
  <font color="#000099">mytype.word</font>, <font color="#000099">mytype.byte</font> 
  и <font color="#000099">mytype.str</font>. </p>
<p>Так как NASM не имеет <i>встроенной</i> поддержки структур, он не поддерживает 
  формы нотации как в языке С с использованием точки для ссылки на элементы структуры 
  (за исключением нотации локальных меток), поэтому код наподобие <font color="#000099">mov 
  ax,[mystruc.mt_word]</font> будет ошибочным. Константа <font color="#000099">mt_word</font> 
  подобна любым другим константам, поэтому корректным синтаксисом в этом случае 
  будет <font color="#000099">mov ax,[mystruc+mt_word]</font> или <font color="#000099">mov 
  ax,[mystruc+mytype.word]</font>. </p>
<h4><a name="nasm_ru4_html_section-4.7.4">4.7.4 <font color="#000099">ISTRUC, AT</font> и<font color="#000099">IEND</font>: 
  Объявление экземпляров структур</a></h4>
<p>Имея определение структуры, вы вслед за этим обычно захотите объявить экземпляры 
  этой структуры в сегменте данных (иначе зачем она вообще нужна). NASM предусматривает 
  для этого простой способ с использованием механизма <font color="#000099">ISTRUC</font>. 
  Для объявления в программе структуры типа <font color="#000099">mytype</font> 
  вы должны написать следующий код: </p>
<pre><font color="#666666">mystruc:  istruc mytype 
          at mt_long, dd 123456 
          at mt_word, dw 1024 
          at mt_byte, db 'x' 
          at mt_str, db 'Привет, фуфел!', 13, 10, 0 
          iend</font>
</pre>
<p>Функцией макроса <font color="#000099">AT</font> является продвижение позиции 
  ассемблирования (при помощи префикса <font color="#000099">TIMES</font>) в корректную 
  точку заданного поля структуры и затем объявления указанных данных. Вследствие 
  этого, поля структуры должны объявляться в том же самом порядке, в каком они 
  следовали при определении. </p>
<p>Если данные, передаваемые в поле структуры, не помещаются на одной строке, 
  оставшаяся их часть может просто следовать за строкой с <font color="#000099">AT</font>. 
  Например: </p>
<pre><font color="#666666">          at mt_str, db 123,134,145,156,167,178,189 
          db 190,100,0</font>
</pre>
<p>В зависимости от личных предпочтений, вы можете также полностью пропустить 
  код на строке <font color="#000099">AT</font> и начать поле структуры со следующей 
  строки: </p>
<pre><font color="#666666">          at mt_str 
          db 'Привет, фуфел!' 
          db 13,10,0</font>
</pre>
<h4><a name="nasm_ru4_html_section-4.7.5">4.7.5 <font color="#000099">ALIGN</font> и <font color="#000099">ALIGNB</font>: 
  Выравнивание данных</a></h4>
<p>Макросы <font color="#000099">ALIGN</font> и <font color="#000099">ALIGNB</font> 
  предоставляют удобный способ выравнивания кода или данных по словам, двойным 
  словам, параграфам (16 байт) или другим границам. (В некоторых ассемблерах для 
  этой цели служит директива <font color="#000099">EVEN</font>). Синтаксис <font color="#000099">ALIGN</font> 
  и <font color="#000099">ALIGNB</font> следующий: </p>
<pre><font color="#666666">          align 4                ; выравнивание по 4-байтной границе 
          align 16               ; выравнивание по параграфам 
          align 8,db 0           ; заполнение 0 вместо NOP 
          align 4,resb 1         ; выравнивание 4 в BSS (неиниц. данные) 
          alignb 4               ; эквивалент предыдущей строки</font>
</pre>
<p>Оба макроса требуют, чтобы их первый аргумент был степенью двойки; они подсчитывают 
  число дополнительных байт, требуемых для подгонки длины текущей секции до соответствующей 
  границы (произведение со степенью двойки) и затем осуществляют выравнивание 
  путем применения к своему второму аргументу префикса <font color="#000099">TIMES</font>.</p>
<p>Если второй аргумент не задан, используется значение по умолчанию: <font color="#000099">NOP</font> 
  для <font color="#000099">ALIGN</font> и <font color="#000099">RESB 1</font> 
  для <font color="#000099">ALIGNB</font>. Если второй аргумент задан, оба макроса 
  становятся эквивалентными. Обычно вы должны использовать <font color="#000099">ALIGN</font> 
  в секциях кода и данных, а <font color="#000099">ALIGNB</font> &#151; в секции 
  BSS. Тогда никакого второго аргумента не понадобится (кроме, конечно, специальных 
  случаев). </p>
<p>Так как <font color="#000099">ALIGN</font> и <font color="#000099">ALIGNB</font> 
  являются простыми макросами, проверки ошибок в них нет: они не могут сообщить 
  вам о том, что переданный аргумент не является степенью двойки или что второй 
  аргумент генерирует более одного байта кода. В любом таком случае они будут 
  "молча делать плохие вещи". </p>
<p><font  color="#000099">ALIGNB</font> (или <font color="#000099">ALIGN</font> 
  со вторым аргументом <font color="#000099">RESB 1</font>) могут использоваться 
  при определении структур:</p>
<pre><font color="#666666">          struc mytype2 
mt_byte:  resb 1 
          alignb 2 
mt_word:  resw 1 
          alignb 4 
mt_long:  resd 1 
mt_str:   resb 32 
          endstruc</font>
</pre>
<p>Таким образом гарантируется, что члены структуры осмысленно выровнены относительно 
  ее базы. </p>
<p>И последнее замечание: <font color="#000099">ALIGN</font> и <font color="#000099">ALIGNB</font> 
  работают относительно начала секции, а не начала адресного пространства в конечном 
  исполнимом файле. Например, выравнивание по параграфам в секциях, гарантирующих 
  свое выравнивание только по двойным словам &#151; пустая трата времени. NASM 
  не в состоянии проверить, что характеристики выравнивания секции подходят для 
  использования <font color="#000099">ALIGN</font> или <font color="#000099">ALIGNB</font>. 
</p>
<p align=center><a href="#nasm_ru5_html">Следующая глава </a> | <a href="#nasm_ru3_html">Предыдущая 
  глава</a> | <a href="#contents_html">Содержание</a>
<hr>

<a name="nasm_ru6_html"></a>
<h1 align=center>Расширенный ассемблер: NASM</h1>

<p align=center><a href="#nasm_ru7_html">Следующая глава</a> | <a href="#nasm_ru5_html">Предыдущая 
  глава </a> | <a href="#contents_html">Содержание</a> | Указатель</p>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr> 
    <td width="60%"> 
      <h2><a name="nasm_ru6_html_chapter-6">Глава 6: Выходные форматы</a></h2>
    </td>
    <td> 
      <div align="right"><font size="-1" color="#666666">Перевод: <a href="http://asmdev.narod.ru/asmos.html">AsmOS 
        group</a>, &copy; 2001</font></div>
    </td>
  </tr>
</table>
NASM &#151; портируемый ассемблер, разработанный для компиляции на любых платформах, 
  поддерживающих ANSI C и создающий исполнимые файлы различных Intel <font color="#000099">x86</font>-совместимых 
  операционных систем. Для обеспечения этого он поддерживает большое число выходных 
  форматов, выбираемых при помощи ключа <font color="#000099">-f</font> командной 
  строки. В данной главе описываются все эти форматы вместе с их специфичным синтаксисом. 

<p>Как упоминалось в <a href="#nasm_ru2_html_section_2_1_1">параграфе 2.1.1</a>, 
  NASM выбирает имя по умолчанию для выходного файла на основе имени входного 
  файла и указанного выходного формата. При этом расширение входного файла (<font color="#000099">.asm, 
  .s</font> или др.) удаляется и вместо него подставляется расширение соответствующего 
  выходного формата. Расширения файлов приводятся ниже в описаниях каждого формата. 
<h3><a name="nasm_ru6_html_section-6.1">6.1 <font color="#000099">bin</font>: Плоский бинарный 
  формат</a></h3>
<p>Формат <font color="#000099">bin</font> не создает объектных файлов: в выходной 
  файл не генерируется ничего, кроме написанного вами кода. Такие "чисто бинарные" 
  файлы используются в MS-DOS: как исполнимые файлы <font color="#000099">.COM</font> 
  и драйвера устройств <font color="#000099">.SYS</font>. Бинарный формат полезен 
  также при разработке операционных систем и загрузчиков. 
<p>Формат <font color="#000099">bin</font> поддерживает только три стандартные 
  секции с именами <font color="#000099">.text, .data</font> и <font color="#000099">.bss</font>. 
  В файле, сгенерированном NASM, сначала будет идти содержимое секции <font color="#000099">.text</font>, 
  а затем содержимое секции <font color="#000099">.data</font>, выровненное по 
  4-байтной границе. Секция <font color="#000099">.bss</font> не хранится в выходном 
  файле, но предполагается, что она будет расположена сразу после секции <font color="#000099">.data</font>, 
  опять же выровненная по 4-байтной границе. 
<p>Если вы явно не указываете директиву <font color="#000099">SECTION</font>, 
  написанный вами код будет направлен по умолчанию в секцию <font color="#000099">.text</font>. 
<p>Использование формата bin переводит NASM по умолчанию в 16-битный режим (см. 
  <a href="#nasm_ru5_html_section_5_1">параграф 5.1</a>). Чтобы использовать его 
  для написания 32-битного кода (например, ядра ОС), вам необходимо явно указать 
  директиву <font color="#000099">BITS 32</font>. 
<p>По умолчанию <font color="#000099">bin</font> не создает расширение файла: 
  он просто оставляет исходное имя файла, удалив предварительно его расширение. 
  Таким образом, NASM по умолчанию будет ассемблировать <font color="#000099">binprog.asm</font> 
  в бинарный файл <font color="#000099">binprog</font>. 
<h4><a name="nasm_ru6_html_section-6.1.1">6.1.1 <font color="#000099">ORG</font>: Начало бинарного 
  файла</a></h4>
<p>Формат <font color="#000099">bin</font> предусматривает дополнительную к списку 
  <a href="#nasm_ru5_html">главы 5</a> директиву <font color="#000099">ORG</font>. 
  Функция этой директивы &#151; задавать начальный адрес программы, с которого 
  она располагается при загрузке в память. 
<p>Например, следующий код будет генерировать двойное слово <font color="#000099">0x00000104</font>: 
<p><pre>
          org 0x100 
          dd label 
label:
</pre>
<p>В отличие от директивы <font color="#000099">ORG</font>, применяемой MASM-совместимыми 
  ассемблерами, которые позволяют перемещаться в объектном файле и переписывать 
  уже сгенерированный код, NASM-овская <font color="#000099">ORG</font> означает 
  только то, что и соответствующее слово: <i>origin (начало)</i>. Ее единственная 
  функция &#151; задавать смещение, которое будет прибавляться ко всем ссылкам 
  на адреса внутри файла; она не допускает такого жульничества, как MASM. Дополнительные 
  комментарии содержатся в <a href="../nasmdo10.html#section-10.1.3">параграфе 
  10.1.3</a>. 
<h4><a name="nasm_ru6_html_section-6.1.2">6.1.2 bin-расширение директивы <font color="#000099">SECTION</font> 
  </a></h4>
<p>Выходной формат bin расширяет директиву <font color="#000099">SECTION</font> 
  (или <font color="#000099">SEGMENT</font>), позволяя вам указывать требования 
  к выравниванию сегментов. Это делается путем добавления в конец строки определения 
  секции спецификатора <font color="#000099">ALIGN</font>. Например, строка 
<p><pre>
          section .data align=16
</pre>
<p>переключается на секцию <font color="#000099">.data</font> и также указывает, 
  что эта секция должна быть выровнена в памяти по границе параграфа. 
<p>Спецификатор <font color="#000099">ALIGN</font> указывает, сколько младших 
  бит в начальном адресе секции должны быть установлены в ноль. Указываемое значение 
  выравнивания может быть любой степенью двойки. 
<h3><a name="nasm_ru6_html_section-6.2">6.2 <font color="#000099">obj</font>: Объектные файлы 
  OMF Microsoft</a></h3>
<p>Файлы формата <font color="#000099">obj</font> (исторически в NASM они называются 
  <font color="#000099">obj</font>, а не <font color="#000099">omf</font>), создаваемые 
  MASMом и TASMом, обычно "скармливаются" 16-битным DOS-компоновщикам, на выходе 
  которых получаются <font color="#000099">.EXE</font> файлы. Этот формат используется 
  также в OS/2. 
<p>Формат <font color="#000099">obj</font> предполагает расширение выходного файла 
  по умолчанию <font color="#000099">.obj</font>. 
<p><font color="#000099">obj</font> не является исключительно 16-битным форматом: 
  NASM полностью поддерживает 32-битные расширения этого формата. В частности, 
  32-битный <font color="#000099">obj</font> формат используется Win32-компиляторами 
  Borland, которые не применяют новый объектный формат <font color="#000099">win32</font> 
  от Майкрософт. 
<p>Формат <font color="#000099">obj</font> не определяет специальных имен сегментов: 
  вы можете называть ваши сегменты как угодно. Типичными именами сегментов <font color="#000099">obj</font> 
  формата обычно являются <font color="#000099">CODE, DATA</font> и <font color="#000099">BSS</font>. 
<p>Если в вашем исходном файле до явного указания директивы <font color="#000099">SEGMENT</font> 
  содержится код, NASM будет помещать его в собственный сегмент с именем <font color="#000099">__NASMDEFSEG</font>. 
<p>Когда вы определяете сегменты в <font color="#000099">obj</font> файле, NASM 
  воспринимает их имена как символы, поэтому вы можете легко получить адрес любого 
  определенного сегмента, например: 
<p>
<pre>
          segment data 
dvar:     dw 1234 
          segment code 
function: mov ax,data            ; получение сегментного адреса данных 
          mov ds,ax              ; и помещение его в DS 
          inc word [dvar]        ; теперь эта ссылка работает 
          ret
</pre>
<p>Формат <font color="#000099">obj</font> разрешает также использование операторов 
  <font color="#000099">SEG</font> и <font color="#000099">WRT</font>, поэтому 
  вы можете писать код, делающий что-то вроде 
<p>
<pre>
          extern foo 
          mov ax,seg foo         ; получение сегмента foo 
          mov ds,ax 
          mov ax,data            ; получение другого сегмента 
          mov es,ax 
          mov ax,[ds:foo]        ; это доступ к 'foo' 
          mov [es:foo wrt data],bx  ; так это делается
</pre>
<h4><a name="nasm_ru6_html_section-6.2.1">6.2.1 <font color="#000099">obj</font>-расширения 
  директивы <font color="#000099">SEGMENT</font> </a></h4>
<p>Выходной формат <font color="#000099">obj</font> расширяет директиву <font color="#000099">SEGMENT</font> 
  (или <font color="#000099">SECTION</font>), позволяя задавать различные характеристики 
  определяемого сегмента. Это делается путем добавления в конец строки определения 
  сегмента дополнительных спецификаторов. Например, 
<p><pre>
          segment code private align=16
</pre>
<p>определяет сегмент <font color="#000099">code</font>, объявляя его при этом 
  закрытым и требуя, чтобы код этого модуля был выровнен по границе параграфа. 
<p>Имеются следующие спецификаторы: 
<ul>
  <li><font color="#000099">PRIVATE, PUBLIC, COMMON</font> и <font color="#000099">STACK</font> 
    задают комбинацию характеристик сегмента. Сегменты <font color="#000099">PRIVATE</font> 
    не могут быть связаны компоновщиком с любыми другими; сегменты <font color="#000099">PUBLIC</font> 
    и <font color="#000099">STACK</font> на стадии компоновки объединяются; сегменты 
    <font color="#000099">COMMON</font> накладываются друг на друга, вместо того, 
    чтобы следовать друг за другом. 
  <li><font color="#000099">ALIGN</font> используется, как уже упоминалось, для 
    указания того, сколько младших бит в стартовом адресе сегмента должно быть 
    установлено в 0. Значение выравнивания может быть любой степенью двойки от 
    1 до 4096; реально поддерживаются только значения 1, 2, 4, 16, 256 и 4096, 
    поэтому если указать 8, оно будет округлено до 16, а 32, 64 и 128 будут округлены 
    до 256 и т.д. Имейте в виду, что выравнивание по 4096-битной границе является 
    PharLap-расширением формата и может не поддерживаться некоторыми компоновщиками. 
  <li><font color="#000099">CLASS</font> используется для указания класса сегмента; 
    этот спецификатор указывает компоновщику, что сегменты одного и того же класса 
    должны быть расположены в выходном файле рядом друг с другом. Имя класса может 
    быть любым словом, например <font color="#000099">CLASS=CODE</font>. 
  <li><font color="#000099">OVERLAY</font>, как и <font color="#000099">CLASS</font>, 
    имеет аргумент в виде произвольного слова и предоставляет компоновщику (способному 
    на это) оверлейную информацию. 
  <li>Сегменты могут быть объявлены как <font color="#000099">USE16</font> или 
    <font color="#000099">USE32</font>, что непосредственным образом влияет на 
    объектный файл, а также заставляет NASM при ассемблировании такого сегмента 
    переключаться на 16- или 32-битный режим соответственно. 
  <li>При создании объектных файлов OS/2 вы должны объявлять 32-битные сегменты 
    как <font color="#000099">FLAT</font>, при этом базовый сегмент по умолчанию 
    приписывается к специальной группе <font color="#000099">FLAT</font>, а также 
    определяет эту группу, если она еще не существует. 
  <li>Формат <font color="#000099">obj</font> позволяет также объявлять сегменты 
    с предопределенными абсолютными адресами, несмотря на то, что компоновщики 
    на данный момент не могут гибко использовать данную возможность; NASM все 
    же позволяет вам объявить сегмент наподобие <font color="#000099">SEGMENT 
    SCREEN ABSOLUTE=0xB800</font>, если он вам нужен. Ключевые слова <font color="#000099">ABSOLUTE</font> 
    и <font color="#000099">ALIGN</font> являются взаимоисключающими. 
</ul>
<p>Атрибуты сегмента по умолчанию в NASM &#151; это <i><font color="#000099">PUBLIC, 
  ALIGN=1, без класса, без оверлея и USE16</font></i>. 
<h4><a name="nasm_ru6_html_section-6.2.2">6.2.2 <font color="#000099">GROUP</font>: Определение 
  групп сегментов</a></h4>
<p>Формат <font color="#000099">obj</font> позволяет группировать сегменты, благодаря 
  чему для ссылки на все сегменты группы может использоваться один сегментный 
  регистр. NASM для этого поддерживает директиву <font color="#000099">GROUP</font>. 
  Вы можете написать: 
<p>
<pre>
          segment data 
               ; некоторые данные 
          segment bss 
               ; некоторые неинициализированные данные 
          group dgroup data bss
</pre>
<p>При ассемблировании этого кода будет создана группа <font color="#000099">dgroup</font>, 
  содержащая сегменты <font color="#000099">data</font> и <font color="#000099">bss</font>. 
  Как и в случае <font color="#000099">SEGMENT</font>, имя директивы <font color="#000099">GROUP</font> 
  определяется как символ, поэтому вы можете ссылаться на переменную <font color="#000099">var</font> 
  в сегменте <font color="#000099">data</font> как <font color="#000099">var wrt 
  data</font> или как <font color="#000099">var wrt dgroup</font>, в зависимости 
  от того, какое значение в данный момент находится в сегментном регистре. 
<p>Однако если вы ссылаетесь на var, объявленную в сегменте группы, NASM по умолчанию 
  предоставляет смещение относительно начала <i>группы</i>, а не <i>сегмента</i>. 
  Вследствие этого <font color="#000099">SEG var</font> также будет возвращать 
  базу группы, а не базу сегмента. 
<p>NASM позволяет сегменту являться частью более одной группы, однако при этом 
  он будет выдавать предупреждение. Переменные, объявленные в таком сегменте, 
  по умолчанию будут относиться к первой включающей данный сегмент группе. 
<p>Группа может не иметь ни одного сегмента; однако при этом вы можете делать 
  <font color="#000099">WRT</font> ссылки на группу, которая не содержит нужную 
  переменную. OS/2, например, определяет специальную группу <font color="#000099">FLAT</font> 
  без всяких сегментов. 
<h4><a name="nasm_ru6_html_section-6.2.3">6.2.3 <font color="#000099">UPPERCASE</font>: </a>Отключение 
  чувствительности к регистру</h4>
<p>В отличие от NASM, некоторые OMF компоновщики нечувствительны к регистру символов; 
  вследствие этого иногда полезно заставлять NASM генерировать объектные файлы 
  в одном регистре. Директива формата <font color="#000099">UPPERCASE</font> перед 
  записью в объектный файл переводит имена всех сегментов, групп и символов в 
  верхний регистр. В пределах исходного файла NASM остается регистро-чувствительным; 
  однако объектные файлы, если это необходимо, могут быть составлены целиком в 
  верхнем регистре. 
<p><font color="#000099">UPPERCASE</font> должна оставаться единственной в строке; 
  она не требует никаких параметров. 
<h4><a name="nasm_ru6_html_section-6.2.4">6.2.4 <font color="#000099">IMPORT</font>: Импортирование 
  символов из DLL</a></h4>
<p>Директива <font color="#000099">IMPORT</font> определяет символ, импортируемый 
  из DLL и используемый например для написания в NASM библиотеки импорта. При 
  использовании директивы <font color="#000099">IMPORT</font> вы должны объявить 
  символ как <font color="#000099">EXTERN</font>. 
<p>Директива <font color="#000099">IMPORT</font> требует указания двух параметров, 
  разделенных пробелом и являющихся соответственно именем импортируемого символа 
  и именем библиотеки, из которой он импортируется. Например: 
<p><pre>
          import WSAStartup wsock32.dll
</pre>
<p>Третьим (необязательным) параметром является имя, под которым импортируемый 
  символ известен в соответствующей библиотеке. Этот параметр применяется в том 
  случае, если вы хотите, чтобы имя символа, используемое внутри вашего кода, 
  не совпадало с именем того же символа в библиотеке. Например: 
<p><pre>
          import asyncsel wsock32.dll WSAAsyncSelect
</pre>
<h4><a name="nasm_ru6_html_section-6.2.5">6.2.5 <font color="#000099">EXPORT</font>: </a>Экспортирование 
  символов в DLL</h4>
<p>Директива <font color="#000099">EXPORT</font> определяет глобальный символ, 
  экспортируемый как DLL-символ в создаваемую DLL (если вы пишете DLL в NASM). 
  Чтобы использовать директиву <font color="#000099">EXPORT</font>, вы должны 
  объявить символ как <font color="#000099">GLOBAL</font>. 
<p><font color="#000099">EXPORT</font> требует один параметр, являющийся именем 
  экспортируемого символа (в том виде, в каком он определен в вашем исходном файле). 
  Необязательный второй параметр (отделенный пробелом от первого) представляет 
  собой <i>внешнее</i> имя символа: это имя, под которым данный символ будет известен 
  использующим эту DLL программам. Если это имя то же самое, что и внутреннее, 
  можете оставить второй параметр пустым. 
<p>Для определения атрибутов экспортируемого символа могут быть заданы дополнительные 
  параметры. Эти параметры, как и второй, отделяются друг от друга пробелами. 
  Если дополнительные параметры задаются, внешнее имя также должно указываться, 
  неважно, совпадает ли оно с внутренним или нет. Имеются следующие дополнительные 
  атрибуты: 
<ul>
  <li><font color="#000099">resident</font> указывает, что экспортируемое имя 
    должно быть оставлено системным загрузчиком резидентным. Это делается для 
    оптимизации часто используемых символом, импортируемых по имени. 
  <li><font color="#000099">nodata</font> указывает, что экспортируемый символ 
    является функцией, не использующей никаких неинициализированных данных. 
  <li><font color="#000099">parm=NNN</font>, где <font color="#000099">NNN</font> 
    целое, устанавливает число параметров-слов в случае, если символ является 
    вызовом-переходом между 32- и 16-битными сегментами. 
  <li>Атрибуты в виде числа указывают, что символ должен экспортироваться с идентификационным 
    номером (ординалом) и представляют собой собственно этот номер. 
</ul>
<p>Например: 
<p>
<pre>
          export myfunc 
          export myfunc TheRealMoreFormalLookingFunctionName 
          export myfunc myfunc 1234  ; экспортирование по ординалу 
          export myfunc myfunc resident parm=23 nodata
</pre>
<h4><a name="nasm_ru6_html_section-6.2.6">6.2.6 <font color="#000099">..start</font>: Определение 
  точки входа в программу</a></h4>
<p>OMF-компоновщики требуют, чтобы один из компонуемых объектных файлов определял 
  точку входа в программу (место, откуда начнется выполнение программы после загрузки). 
  Если этот файл ассемблируется при помощи NASM, вы можете указать точку входа 
  путем объявления в этом месте специального символа <font color="#000099">..start</font>. 
<h4><a name="nasm_ru6_html_section-6.2.7">6.2.7 <font color="#000099">obj</font>-расширения 
  директивы <font color="#000099">EXTERN</font> </a></h4>
<p>Если вы объявляете внешний символ директивой 
<p><pre>
          extern foo
</pre>
<p>то ссылки наподобие <font color="#000099">mov ax,foo</font> будут давать вам 
  смещение <font color="#000099">foo</font> относительно базы его предопределенного 
  сегмента (как задано в модуле, где определен <font color="#000099">foo</font>). 
  Таким образом, доступ к содержимому <font color="#000099">foo</font> вы будете 
  обычно осуществлять следующим образом 
<p>
<pre>          mov ax,seg foo         ; получение базы сегмента 
          mov es,ax              ; перемещение ее в ES 
          mov ax,[es:foo]        ; и использование смещения 'foo' от нее
</pre>
<p>Это получается немного громоздко, особенно если вы знаете, что внешний символ 
  будет доступен из данного сегмента или группы (например, <font color="#000099">dgroup</font>). 
  Так, если <font color="#000099">DS</font> уже содержит <font color="#000099">dgroup</font>, 
  вы можете написать 
<p><pre>
          mov ax,[foo wrt dgroup]
</pre>
<p>Однако необходимость каждый раз это печатать для получения доступа к <font color="#000099">foo</font> 
  очень утомительна; NASM позволяет вам объявить <font color="#000099">foo</font> 
  в альтернативной форме 
<p><pre>
          extern foo:wrt dgroup
</pre>
<p>Эта форма заставляет NASM делать вид, что базовым сегментом <font color="#000099">foo</font> 
  на самом деле является <font color="#000099">dgroup</font>; так, выражение <font color="#000099">seg 
  foo</font> теперь будет возвращать <font color="#000099">dgroup</font>, а выражение 
  <font color="#000099">foo</font> будет эквивалентно <font color="#000099">foo 
  wrt dgroup</font>. 
<p>Описанный WRT-механизм может быть использован для "проявления" внешних символов 
  по отношению к любой группе или сегменту в программе. Он также может быть применен 
  к общим переменным (см. <a href="#nasm_ru6_html_section_6_2_8">параграф 6.2.8</a> ниже).
<h4><a name="nasm_ru6_html_section-6.2.8">6.2.8 <font color="#000099">obj</font>-расширения 
  директивы <font color="#000099">COMMON</font> </a></h4>
<p>Формат <font color="#000099">obj</font> позволяет общим переменным быть как 
  ближними, так и дальними; NASM обеспечивает этот механизм при помощи следующего 
  синтаксиса: 
<p>
<pre>          common nearvar 2:near  ; 'nearvar' - ближняя переменная 
          common farvar 10:far   ; 'farvar' - дальняя переменная
</pre>
<p>Дальние общие переменные могут иметь размер больше 64 Кб, поэтому спецификация 
  OMF говорит, что они объявляются как число <i>элементов</i> данного размера. 
  Так, 10-байтная дальняя переменная должна быть объявлена как 10 однобайтных 
  элементов, 5 двухбайтных, 2 пятибайтных или 1 десятибайтный элемент. 
<p>Некоторые OMF-компоновщики при разрешении общих переменных, объявленных более 
  чем в одном модуле, требуют совпадения размеров элемента и переменной. Поэтому 
  NASM должен позволять задавать размер элемента дальних переменных. Он делает 
  это при помощи следующего синтаксиса: 
<p>
<pre>          common c_5by2 10:far 5 ; два пятибайтных элемента 
          common c_2by5 10:far 2 ; пять двухбайтных элементов
</pre>
<p>Если размер элемента не задан, он предполагается по умолчанию равным 1. Не 
  требуется также и явное указание ключевого слова <font color="#000099">FAR</font>, 
  так как только дальние общие переменные могут иметь размер элемента. Исходя 
  из этого, приведенные выше объявления будут эквивалентны следующим:
<p>
<pre>          common c_5by2 10:5     ; два пятибайтных элемента 
          common c_2by5 10:2     ; пять двухбайтных элементов
</pre>
<p>В дополнение ко всему вышесказанному, директива <font color="#000099">COMMON</font> 
  в <font color="#000099">obj</font> поддерживает также и спецификацию <font color="#000099">WRT</font>-умолчаний 
  наподобие тому, как это работает для <font color="#000099">EXTERN</font> (см. 
  <a href="#nasm_ru6_html_section_6_2_7">параграф 6.2.7</a>). Поэтому вы можете объявлять такие, 
  например, вещи: 
<p><pre>
          common foo 10:wrt dgroup 
          common bar 16:far 2:wrt data 
          common baz 24:wrt data:6
</pre>
<h3><a name="nasm_ru6_html_section-6.3">6.3 <font color="#000099">win32</font>: Объектные файлы 
  Win32 Microsoft</a></h3>
<p>Выходной формат <font color="#000099">win32</font> генерирует объектные файлы 
  Microsoft Win32, передаваемые обычно компоновщикам Microsoft. Заметьте, что 
  компиляторы Borland Win32 не используют этот формат, вместо него они используют 
  <font color="#000099">obj</font> (см. <a href="#nasm_ru6_html_section_6_2">параграф 6.2</a>). 
<p><font color="#000099">win32</font> подразумевает по умолчанию расширение выходного 
  объектного файла <font color="#000099">.obj</font>. 
<p>Имейте в виду, что хотя Майкрософт и утверждает, что объектные файлы Win32 
  следуют стандарту <font color="#000099">COFF</font>, объектные файлы, созданные 
  компиляторами Microsoft Win32, не совместимы с COFF-компоновщиками (например, 
  DJGPP) и наоборот. Это происходит из-за разницы во взглядах на семантику таблицы 
  перемещений. Для создания COFF-совместимых выходных файлов для <font color="#000099">DJGPP</font> 
  используйте выходной формат <font color="#000099">coff</font> NASMа; обратное 
  также справедливо &#151; файлы, полученные в объектном формате <font color="#000099">coff</font>, 
  не обрабатываются корректно компоновщиками Win32. 
<h4><a name="nasm_ru6_html_section-6.3.1">6.3.1 <font color="#000099">win32</font>-расширения 
  директивы <font color="#000099">SECTION</font> </a></h4>
<p>Как и формат <font color="#000099">obj</font>, <font color="#000099">win32</font> 
  позволяет вам указывать в строке с директивой <font color="#000099">SECTION</font> 
  дополнительную информацию, предназначенную для управления типом и свойствами 
  определяемой секции. Обычно тип секции и ее свойства для стандартных имен <font color="#000099">.text, 
  .data</font> и <font color="#000099">.bss</font> генерируются NASM автоматически, 
  но при помощи приведенных спецификаторов могут быть и переопределены. 
<p>Имеются следующие спецификаторы: 
<ul>
  <li><font color="#000099">code</font> или <font color="#000099">text</font> 
    (что эквивалентно) описывает секцию как секцию кода. При этом секция маркируется 
    как читаемая и выполняемая, но не записываемая; компоновщику указывается также, 
    что тип секции &#151; код. 
  <li><font color="#000099">data</font> и <font color="#000099">bss</font>, по 
    аналогии с <font color="#000099">code</font>, определяют секцию данных. Секция 
    данных маркируется как читаемая и записываемая, но не выполняемая. Спецификатор 
    <font color="#000099">data</font> объявляет секцию инициализированных данных, 
    в то время как спецификатор <font color="#000099">bss</font> &#151; неинициализированных. 
  <li><font color="#000099">info</font> описывает секцию как информационную, не 
    включаемую компоновщиком в исполнимый файл, но способную (например) передать 
    компоновщику информацию. Например, объявление info-секции с именем <font color="#000099">.drectve</font> 
    побуждает компоновщик интерпретировать ее содержание как опции командной строки. 
  <li><font color="#000099">align=</font> с последующим числом описывает требования 
    к выравниванию секции. Максимум, что вы можете задать &#151; 64: объектный 
    формат Win32 не имеет способа запросить выравнивание большее, чем это. Если 
    выравнивание явно не указано, для секций кода используется выравнивание по 
    параграфам, а для секций данных &#151; по двойным словам. Информационные секции 
    получают по умолчанию выравнивание в 1 байт (т.е. нет его), даже если значение 
    указано явно. 
</ul>
<p>Если вы не укажете ни одного описанного выше спецификатора, NASM принимает 
  следующие значения по умолчанию: 
<p><pre>
          section .text code align=16 
          section .data data align=4 
          section .bss bss align=4
</pre>
<p>Любые другие имена секций обрабатываются так же, как и <font color="#000099">.text</font>. 
<h3><a name="nasm_ru6_html_section-6.4">6.4 <font color="#000099">coff</font>: Общий формат 
  объектных файлов</a></h3>
<p>Выходной формат <font color="#000099">coff</font> создает COFF-объектные файлы, 
  обрабатываемые компоновщиком DJGPP. Этот формат предусматривает по умолчанию 
  расширение выходных файлов <font color="#000099">.o</font>. 
<p>Формат <font color="#000099">coff</font> поддерживает те же самые расширения 
  директивы <font color="#000099">SECTION</font>, что и <font color="#000099">win32</font>, 
  однако спецификатор <font color="#000099">align</font> и секция типа <font color="#000099">info</font> 
  не поддерживаются. 
<h3><a name="nasm_ru6_html_section-6.5">6.5 <font color="#000099">elf</font>: Объектные файлы 
  ELF Линукс</a></h3>
<p>Выходной формат elf генерирует объектные файлы <font color="#000099">ELF32</font> 
  (Executable and Linkable Format), используемые в Линукс. Этот формат использует 
  по умолчанию расширение <font color="#000099">.o</font> выходных файлов. 
<h4><a name="nasm_ru6_html_section-6.5.1">6.5.1 <font color="#000099">elf</font>-расширения 
  директивы <font color="#000099">SECTION</font> </a></h4>
<p>Как и формат <font color="#000099">obj</font>, <font color="#000099">elf</font> 
  позволяет вам указывать в строке с директивой <font color="#000099">SECTION</font> 
  дополнительную информацию, предназначенную для управления типом и свойствами 
  определяемой секции. Обычно тип секции и ее свойства для стандартных имен <font color="#000099">.text, 
  .data</font> и <font color="#000099">.bss</font> генерируются NASM автоматически, 
  но при помощи приведенных спецификаторов могут быть и переопределены. 
<p>Имеются следующие спецификаторы: 
<ul>
  <li><font color="#000099">alloc</font> описывает секцию, которая при запуске 
    программы загружается в память. <font color="#000099">noalloc</font> описывает 
    незагружаемые секции, такие как информационные или секции комментариев. 
  <li><font color="#000099">exec</font> описывает секцию, которая при запуске 
    программы может выполняться (разрешено ее выполнение). Секции <font color="#000099">noexec</font> 
    выполняться не могут. 
  <li><font color="#000099">write</font> описывает секцию, в которую после запуска 
    программы разрешается запись. В секции <font color="#000099">nowrite</font> 
    запись запрещена. 
  <li><font color="#000099">progbits</font> описывает секцию, явно сохраняемую 
    в объектном файле: обычно это секции кода и инициализированных данных. <font color="#000099">nobits</font> 
    описывает секции, не присутствующие в файле, такие как BSS (неинициализированных 
    данных). 
  <li><font color="#000099">align=</font> с последующим числом, как и <font color="#000099">obj</font>, 
    задает параметр выравнивания секции. 
</ul>
<p>Если вы не укажете ни одного описанного выше спецификатора, NASM принимает 
  следующие значения по умолчанию: 
<p><pre>
          section .text progbits alloc   exec nowrite align=16 
          section .data progbits alloc noexec   write align=4 
          section .bss    nobits alloc noexec   write align=4 
          section other progbits alloc noexec nowrite align=1
</pre>
<p>(Любые секции, не являющиеся <font color="#000099">.text, .data</font> или 
  <font color="#000099">.bss</font> обрабатываются так же, как и секция <font color="#000099">other</font>). 
<h4><a name="nasm_ru6_html_section-6.5.2">6.5.2 Позиционно-независимый код: Специальные символы 
  формата <font color="#000099">elf</font> и <font color="#000099">WRT</font></a></h4>
<p>Спецификация ELF содержит достаточное число возможностей написания позиционно-независимого 
  кода (PIC), благодаря которым разделяемые библиотеки ELF весьма гибкие. Однако 
  это также означает, что NASM должен быть способен генерировать разнообразные 
  замысловатые типы релокейшнов объектных ELF-файлов. 
<p>Так как ELF не поддерживает сегментные ссылки, оператор <font color="#000099">WRT</font> 
  для своей обычной цели не используется; вместо этого формат <font color="#000099">elf</font> 
  использует <font color="#000099">WRT</font> для других целей, а именно для специальных 
  PIC-типов перемещений. 
<p><font color="#000099">elf</font> определяет пять специальных символов, которые 
  вы можете использовать с правой стороны оператора <font color="#000099">WRT</font> 
  для получения PIC-типов перемещений. Это <font color="#000099">..gotpc, ..gotoff, 
  ..got, ..plt</font> и <font color="#000099">..sym</font>. Их функции описаны 
  ниже: 
<ul>
  <li>Ссылка на символ, помеченный как база глобальной таблицы смещений (GOT) 
    при помощи <font color="#000099">wrt ..gotpc</font>, будет в результате давать 
    расстояние от начала текущей секции до глобальной таблицы смещений. (Для ссылки 
    на <font color="#000099">GOT</font> используется обычно стандартный символ 
    <font color="#000099">_GLOBAL_OFFSET_TABLE_</font>). Таким образом, для получения 
    реального адреса GOT, вам необходимо прибавить к результату конструкцию <font color="#000099">$$</font>. 
  <li>Ссылка на определенную позицию в одной из ваших собственных секций при помощи 
    <font color="#000099">wrt ..gotoff</font> будет давать расстояние от начала 
    GOT до заданной позиции, поэтому прибавив это расстояние к адресу GOT, вы 
    получите реальный адрес нужной вам позиции. 
  <li>Ссылка на внешний или глобальный символ при помощи <font color="#000099">wrt 
    ..got</font> заставляет компоновщик построить элемент GOT, содержащий адрес 
    символа, поэтому ссылка дает расстояние от начала GOT до этого элемента. Таким 
    образом, прибавляя к полученной ссылке адрес GOT, вы получите адрес, по которому 
    содержится адрес символа. 
  <li>Ссылка на имя процедуры при помощи <font color="#000099">wrt ..plt</font> 
    заставляет компоновщик построить элемент таблицы компоновки процедуры (PLT) 
    и ссылка в результате дает адрес элемента PLT. Вы можете использовать это 
    обычно только в контексте создания относительных перемещений (т.е. цели для 
    <font color="#000099">CALL</font> или <font color="#000099">JMP</font>), так 
    как ELF абсолютно не имеет перемещаемых типов для ссылки на элементы PLT. 
  <li>Ссылка на имя символа при помощи <font color="#000099">wrt ..sym</font> 
    заставляет NASM записать обычное перемещение, однако вместо того, чтобы сделать 
    перемещение относительным к началу секции и затем добавить смещение символа, 
    он создаст запись смещения непосредственно к запрашиваемому символу. Различие 
    необходимо из-за особенностей динамического компоновщика. 
</ul>
<p>Более полное объяснение использования типов перемещений для написания в NASM 
  разделяемых библиотек дано в <a href="#nasm_ru8_html_section_8_2">параграфе 8.2</a>. 
<h4><a name="nasm_ru6_html_section-6.5.3">6.5.3 <font color="#000099">elf</font>-расширения 
  директивы <font color="#000099">GLOBAL</font> </a></h4>
<p>Объектные файлы ELF могут содержать больше информации о глобальном символе, 
  чем просто его адрес: они могут содержать размер символа, а также его тип. Это 
  сделано не только для удобства при отладке, это просто необходимо, если программа 
  пишется в виде разделяемой библиотеки. Для задания дополнительной информации 
  NASM поддерживает некоторые расширения директивы <font color="#000099">GLOBAL</font>. 
<p>Поставив после имени глобальной переменной двоеточие и написав <font color="#000099">function</font> 
  или <font color="#000099">data</font> (<font color="#000099">object</font> является 
  синонимом <font color="#000099">data</font>), вы можете указать, чем является 
  глобальная переменная &#151; функцией или объектом данных. Например, строка 
<p><pre>
          global hashlookup:function, hashtable:data
</pre>
<p>экспортирует глобальный символ <font color="#000099">hashlookup</font> как 
  функцию, а <font color="#000099">hashtable</font> &#151; как объект данных. 
<p>После ввода спецификатора вы можете также указать в виде числового выражения 
  (которое может включать метки и даже опережающие ссылки) размер ассоциированных 
  с символом данных, например: 
<p>
<pre>
          global hashtable:data (hashtable.end - hashtable) 
hashtable: 
          db this,that,theother  ; здесь некоторые данные 
.end:
</pre>
<p>Это заставит NASM автоматически подсчитать длину таблицы и поместить эту информацию 
  в символьную таблицу ELF. 
<p>Объявление типа и размера глобальных символов требуется при написании разделяемых 
  библиотек. Дополнительную информацию вы можете найти в <a href="#nasm_ru8_html_section_8_2_4">параграфе 
  8.2.4</a>. 
<h4><a name="nasm_ru6_html_section-6.5.4">6.5.4 <font color="#000099">elf</font>-расширение 
  директивы <font color="#000099">COMMON</font> </a></h4>
<p>ELF позволяет задавать требования к выравниванию общих переменных. Это делается 
  путем помещения числа (которое должно быть степенью двойки) после имени и размера 
  общей переменной и отделения этого числа (как обычно) двоеточием. Например, 
  массив двойных слов, который должен быть выровнен по двойным словам: 
<p><pre>
          common dwordarray 128:4
</pre>
<p>Эта строка объявляет массив размером 128 байт и требует, чтобы он был выровнен 
  по 4-байтной границе. 
<h3><a name="nasm_ru6_html_section-6.6">6.6 <font color="#000099">aout</font>: Объектные файлы 
  <font color="#000099">a.out</font> Линукс</a></h3>
<p>Формат <font color="#000099">aout</font> генерирует объектные файлы <font color="#000099">a.out</font> 
  в форме, используемой устаревшими Линукс системами. (Он отличается от других 
  объектных файлов <font color="#000099">a.out</font> магическим числом в первых 
  четырех байтах файла. Также некоторые реализации <font color="#000099">a.out</font>, 
  например NetBSD, поддерживают позиционно-независимый код, который реализация 
  Линукс не знает). 
<p>Формат <font color="#000099">a.out</font> подразумевает расширение выходных 
  файлов по умолчанию <font color="#000099">.o</font>. 
<p>Этот формат очень простой. Он не поддерживает специальных директив и символов, 
  не использует <font color="#000099">SEG</font> или <font color="#000099">WRT</font> 
  и в нем нет расширений никаких стандартных директив. Он поддерживает только 
  три стандартных секции с именами <font color="#000099">.text, .data</font> и 
  <font color="#000099">.bss</font>. 
<h3><a name="nasm_ru6_html_section-6.7">6.7 <font color="#000099">aoutb</font>: Объектные файлы 
  <font color="#000099">a.out</font> NetBSD/FreeBSD/OpenBSD </a></h3>
<p>Формат <font color="#000099">aoutb</font> генерирует объектные файлы <font color="#000099">a.out</font> 
  в форме, используемой различными BSD-клонами UNIX: NetBSD, FreeBSD и OpenBSD. 
  Для большинства объектных файлов этот формат не отличается от <font color="#000099">aout</font> 
  за исключением магического числа в первых четырех байтах файла. Однако формат 
  поддерживает (как и формат <font color="#000099">elf</font>) позиционно-независимый 
  код, поэтому вы можете использовать его для написания разделяемых библиотек 
  BSD. 
<p>Расширение объектных файлов формата <font color="#000099">aoutb</font> по умолчанию 
  <font color="#000099">.o</font>. 
<p>Формат не поддерживает специальных директив и символов и имеет только три стандартных 
  секции с именами <font color="#000099">.text, .data</font> и <font color="#000099">.bss</font>. 
  Несмотря на это, для обеспечения типов перемещений в позиционно-независимом 
  коде он поддерживает использование <font color="#000099">WRT</font> так же, 
  как это делает <font color="#000099">elf</font>. Более подробно это описано 
  в <a href="#nasm_ru6_html_section_6_5_2">параграфе 6.5.2</a>. 
<p><font color="#000099">aoutb</font>, как и <font color="#000099">elf</font> 
  поддерживает также расширение директивы <font color="#000099">GLOBAL</font>: 
  см. <a href="#nasm_ru6_html_section_6_5_3">параграф 6.5.3</a>. 
<h3><a name="nasm_ru6_html_section-6.8">6.8 <font color="#000099">as86</font>: Объектные файлы 
  as86 Линукс</a></h3>
<p>16-битный ассемблер Линукс <font color="#000099">as86</font> имеет свой собственный 
  нестандартный формат объектных файлов. Хотя его компаньон компоновщик <font color="#000099">ld86</font> 
  выдает что-то близкое к обычным бинарникам <font color="#000099">a.out</font>, 
  объектный формат, используемый для взаимодействия между <font color="#000099">as86</font> 
  и <font color="#000099">ld86</font>, все же не является <font color="#000099">a.out</font>. 
<p>NASM на всякий случай поддерживает данный формат как <font color="#000099">as86</font>. 
  Расширение выходного файла по умолчанию для данного формата <font color="#000099">.o</font>. 
<p>Формат <font color="#000099">as86</font> &#151; это очень простой объектный 
  формат (с точки зрения NASM). Он не поддерживает специальных директив и символов, 
  не использует <font color="#000099">SEG</font> и <font color="#000099">WRT</font>, 
  и в нем нет никаких расширений стандартных директив. Он поддерживает только 
  три стандартных секции с именами <font color="#000099">.text, .data</font> и 
  <font color="#000099">.bss</font>. 
<h3><a name="nasm_ru6_html_section-6.9">6.9 <font color="#000099">rdf</font>: Перемещаемые динамические 
  объектные файлы</a></h3>
<p>Выходной формат <font color="#000099">rdf</font> создает объектные файлы RDOFF. 
  RDOFF &#151; это "доморощенный" формат объектных файлов, разработанный вместе 
  с NASM и отражающий в себе внутреннюю структуру ассемблера. 
<p>RDOFF не используется никакими широко известными операционными системами. Однако 
  тот, кто пишет собственную систему, возможно захочет использовать его в качестве 
  собственного объектного формата, так как разработан он прежде всего для упрощения 
  и содержит очень мало бюрократии в заголовках файлов. 
<p>Архив Unix NASM и архив DOS с исходниками имеют подкаталог <font color="#000099">rdoff</font>, 
  содержащий набор RDOFF-утилит: RDF-компоновщик, менеджер статических библиотек, 
  утилита, делающая дамп RDF-файла, и программа, загружающая и выполняющая RDF-исполнимый 
  файл под Линукс. 
<p>Формат <font color="#000099">rdf</font> поддерживает только стандартные секции 
  с именами <font color="#000099">.text, .data</font> и <font color="#000099">.bss</font>. 
<h4><a name="nasm_ru6_html_section-6.9.1">6.9.1 Требование библиотеки: Директива <font color="#000099">LIBRARY</font> 
  </a></h4>
<p>RDOFF содержит механизм "требования библиотеки", которая будет связана с модулем 
  как во время загрузки, так и при выполнении. Это осуществляется директивой <font color="#000099">LIBRARY</font>, 
  которая принимает один аргумент, являющийся именем модуля: 
<p><pre>
          library mylib.rdl
</pre>
<h3><a name="nasm_ru6_html_section-6.10">6.10 <font color="#000099">dbg</font>: Формат для отладки</a></h3>
<p>Выходной <font color="#000099">dbg</font> формат в конфигурации NASM по умолчанию 
  отсутствует. Если вы строите собственный исполнимый файл NASM из исходников, 
  то можете для включения этого формата определить символ <font color="#000099">OF_DBG</font> 
  в файле <font color="#000099">outform.h</font> или командной строке компилятора. 
<p>Формат <font color="#000099">dbg</font> не создает объектных файлов как таковых; 
  вместо этого он создает текстовый файл, содержащий полный список всех транзакций 
  между ядром NASM и модулем выходных форматов. Это обычно нужно людям, намеревающимся 
  написать собственные выходные драйвера и которые благодаря этому формату могут 
  получить картину различных запросов основной программы к выходному драйверу 
  и увидеть, в каком порядке они осуществляются. 
<p>Для простых файлов можно использовать <font color="#000099">dbg</font> формат 
  так: 
<p><pre>
nasm -f dbg filename.asm
</pre>
<p>в результате чего генерируется диагностический файл <font color="#000099">filename.dbg</font>. 
  Однако это не будет работать на файлах, разработанных под различные объектные 
  форматы, так как каждый формат определяет собственные макросы (обычно пользовательские 
  формы директив), не определенные в формате <font color="#000099">dbg</font>. 
  Поэтому здесь необходимо запускать NASM дважды, с препроцессированием выбранного 
  объектного формата: 
<p><pre>
nasm -e -f rdf -o rdfprog.i rdfprog.asm 
nasm -a -f dbg rdfprog.i
</pre>
<p>Здесь <font color="#000099">rdfprog.asm</font> препроцессируется в <font color="#000099">rdfprog.i</font>, 
  оставляя при этом выбранным объектный формат <font color="#000099">rdf</font>. 
  Это нужно, чтобы специальные директивы RDF правильно конвертировались в примитивную 
  форму. Затем препроцессированный исходный файл обрабатывается в формате <font color="#000099">dbg</font> 
  и при этом генерируется окончательный диагностический файл. 
<p>Такой обходной путь обычно не будет работать с программами, предназначенными 
  для формата <font color="#000099">obj</font>, так как директивы <font color="#000099">SEGMENT</font> 
  и <font color="#000099">GROUP</font> последнего имеют побочные эффекты определения 
  имен сегментов и групп как символов; <font color="#000099">dbg</font> этого 
  не делает, поэтому программа ассемблироваться не будет. Если вам позарез нужно 
  получить dbg-трассировку исходников, написанных для <font color="#000099">obj</font>, 
  вы можете обойти это, определив символы самостоятельно (например, при помощи 
  <font color="#000099">EXTERN</font>). 
<p>Формат <font color="#000099">dbg</font> принимает любые имена секций и любые 
  директивы, протоколируя все их в свой выходной файл. 
<p align=center><a href="#nasm_ru7_html">Следующая глава</a> | <a href="#nasm_ru5_html">Предыдущая 
  глава </a> | <a href="#contents_html">Содержание</a>
<hr>

<a name="nasm_ru7_html"></a>
<h1 align=center>Расширенный ассемблер: NASM</h1>

<p align=center><a href="#nasm_ru8_html">Следующая глава</a> | <a href="#nasm_ru6_html">Предыдущая 
  глава </a> | <a href="#contents_html">Содержание</a> | Указатель</p>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr> 
    <td width="71%"> 
      <h2><a name="nasm_ru7_html_chapter-7">Глава 7: Написание 16-битного кода (DOS, 
        Windows 3/3.1)</a></h2>
    </td>
    <td width="29%"> 
      <div align="right"><font size="-1" color="#666666">Перевод: <a href="http://asmdev.narod.ru/asmos.html">AsmOS 
        group</a>, &copy; 2001</font></div>
    </td>
  </tr>
</table>
В данной главе рассмотрены некоторые общие вопросы создания 16-битного кода, 
  выполняющегося под MS-DOS или Windows 3.x: как скомпоновать программы для получения 
  <font color="#000099">.EXE</font> или <font color="#000099">.COM</font> файлов, 
  как создать драйвер устройства <font color="#000099">.SYS</font>, а также как 
  ассемблерный код взаимодействует с 16-битными компиляторами и с Borland Pascal. 
<h3><a name="nasm_ru7_html_section-7.1">7.1 Получение <font color="#000099">.EXE</font> файлов</a></h3>
<p>Любые большие программы, написанные под DOS, необходимо создавать как <font color="#000099">.EXE</font> 
  файлы: только они имеют необходимую внутреннюю структуру для захвата более одного 
  64К сегмента. Программы Windows также требуется создавать как <font color="#000099">.EXE</font> 
  файлы, так как <font color="#000099">.COM</font> файлы Windows не поддерживает. 
<p>Обычно <font color="#000099">.EXE</font> файлы генерируются при помощи выходного 
  формата <font color="#000099">obj</font> (при этом создаются один или более 
  <font color="#000099">.OBJ</font> файлов, связываемых затем друг с другом компоновщиком). 
  Однако при помощи выходного формата <font color="#000099">bin</font> и некоторых 
  макросредств NASM поддерживает также непосредственное создание простых <font color="#000099">.EXE</font> 
  файлов DOS (заголовок <font color="#000099">.EXE</font> файла конструируется 
  при помощи <font color="#000099">DB</font> и <font color="#000099">DW</font>). 
  Спасибо Yann Guidon за содействие при кодировании этого. 
<p>В будущем NASM может быть станет поддерживать и "родной" выходной <font color="#000099">.EXE</font> 
  формат. 
<h4><a name="nasm_ru7_html_section-7.1.1">7.1.1 Использование формата <font color="#000099">obj</font> 
  для получения <font color="#000099">.EXE</font> файлов</a></h4>
<p>В данном параграфе описан обычный способ создания <font color="#000099">.EXE</font> 
  файлов путем компоновки друг с другом <font color="#000099">.OBJ</font> файлов. 
<p>Большинство 16-битных языков программирования поставляются с собственным компоновщиком; 
  если у вас нет ни одного, возьмите с <a href="ftp://x2ftp.oulu.fi/pub/msdos/programming/lang/">x2ftp.oulu.fi</a> 
  свободно распространяемый компоновщик VAL, упакованный в формате LZH. LZH-архиватор 
  можно найти на <a href="ftp://ftp.simtel.net/pub/simtelnet/msdos/arcers">ftp.simtel.net</a>. 
  На <a href="http://www.pcorner.com/tpc/old/3-101.htm">www.pcorner.com</a> имеется 
  еще один бесплатный компоновщик <font color="#000099">FREELINK</font> (только 
  он без исходников), и наконец, на <a href="http://www.delorie.com/djgpp/16bit/djlink/">www.delorie.com</a> 
  можно взять компоновщик <font color="#000099">djlink</font>, написанный DJ Delorie. 
<p>При компоновке нескольких <font color="#000099">.OBJ</font> файлов в один <font color="#000099">.EXE</font> 
  файл вы должны убедиться, что только один из них (<font color="#000099">.OBJ</font>) 
  имеет точку входа (при помощи специального символа <font color="#000099">..start</font>, 
  определяемого <font color="#000099">obj</font> форматом: см. <a href="#nasm_ru6_html_section_6_2_6">параграф 
  6.2.6</a>). Если ни один из модулей не определяет точки входа, компоновщик не 
  будет знать, какое значение записать в заголовок выходного файла в качестве 
  стартового адреса; если же точка входа определена в нескольких файлах, компоновщик 
  не сможет понять, <i>какое</i> именно значение использовать. 
<p>Здесь приводится пример исходного файла, который ассемблируется NASMом в <font color="#000099">.OBJ</font> 
  файл и им же компонуется в <font color="#000099">.EXE</font>. На этом примере 
  продемонстрированы основные принципы определения стека, инициализации сегментных 
  регистров и объявления точки входа. Данный файл содержится также в подкаталоге 
  <font color="#000099">test</font> NASM-архивов под именем <font color="#000099">objexe.asm</font>. 
<p><pre>
          segment code 

..start:  mov ax,data 
          mov ds,ax 
          mov ax,stack 
          mov ss,ax 
          mov sp,stacktop
</pre>
<p>Эта инициализационная часть кода устанавливает <font color="#000099">DS</font> 
  на сегмент данных и инициализирует <font color="#000099">SS</font> и <font color="#000099">SP</font> 
  для указания на вершину стека. Заметьте, что после записи в <font color="#000099">SS</font> 
  прерывания неявно запрещаются на время выполнения следующей команды, в качестве 
  которой подразумевается загрузка <font color="#000099">SP</font>. Это необходимо 
  для корректной инициализации стека. 
<p>Заметьте также, что в начале данного кода определен символ <font color="#000099">..start</font>, 
  который в результирующем исполнимом файле будет являться точкой входа. 
<p><pre>
          mov dx,hello 
          mov ah,9 
          int 0x21
</pre>
<p>Здесь начинается основная программа: загрузка в <font color="#000099">DS:DX</font> 
  указателя на приветствующее сообщение (<font color="#000099">hello</font> является 
  неявной ссылкой на сегмент <font color="#000099">data</font>, загруженный в 
  <font color="#000099">DS</font> настроечным кодом, поэтому полный указатель 
  корректен) и вызов DOS-функции вывода строки на экран. 
<p><pre>
          mov ax,0x4c00 
          int 0x21
</pre>
<p>Здесь программа завершается при помощи другого системного DOS-вызова. 
<p>
<pre>
          segment data 
hello:    db 'Привет, фуфел!', 13, 10, '$'
</pre>
<p>Сегмент данных содержит строку, которую нужно отобразить на экране. 
<p><pre>
          segment stack stack 
          resb 64 
stacktop:
</pre>
<p>Данный код объявляет сегмент стека, содержащий 64 байта неинициализированного 
  стекового пространства, где символ <font color="#000099">stacktop</font> указывает 
  на его вершину. Директива <font color="#000099">segment stack stack</font> определяет 
  сегмент под <i>именем</i> <font color="#000099">stack</font>, <i>тип</i> которого 
  также <font color="#000099">STACK</font>. В нашем случае не требуется дальнейшее 
  выполнение программы, но если в ней не определить сегмент <font color="#000099">STACK</font>, 
  компоновщики вероятнее всего выдадут предупреждение или сообщение об ошибке. 
<p>Приведенный выше файл будет ассемблироваться в <font color="#000099">.OBJ</font> 
  файл, затем компоноваться NASM в корректный <font color="#000099">.EXE</font> 
  файл, который при запуске будет выводить на экран строку '<font color="#000099">Привет, 
  фуфел!</font>' и затем завершаться. 
<h4><a name="nasm_ru7_html_section-7.1.2">7.1.2 Использование формата <font color="#000099">bin</font> 
  для получения <font color="#000099">.EXE</font> файлов</a></h4>
<p>Формат <font color="#000099">.EXE</font> является достаточно простым, поэтому 
  построение <font color="#000099">.EXE</font> файлов возможно путем написания 
  чисто бинарной программы с последующим помещением в ее начало 32-битного заголовка. 
  Структура заголовка несложная, поэтому он может быть создан обычными командами 
  <font color="#000099">DB</font> и <font color="#000099">DW</font>. Исходя из 
  вышесказанного, для непосредственного создания <font color="#000099">.EXE</font> 
  файлов может быть использован формат <font color="#000099">bin</font>. 
<p>В архиве NASM имеется подкаталог <font color="#000099">misc</font>, в котором 
  находится файл макросов <font color="#000099">exebin.mac</font>. В этом файле 
  определены три макроса: <font color="#000099">EXE_begin, EXE_stack</font> и 
  <font color="#000099">EXE_end</font>. 
<p>Для создания файла при помощи формата <font color="#000099">bin</font> вы должны 
  включить в свой исходный файл директиву <font color="#000099">%include exebin.mac</font>, 
  загружающую в него пакет требуемых макросов. Затем для генерации заголовка файла 
  вы должны выполнить макрокоманду <font color="#000099">EXE_begin</font> (не 
  имеет аргументов). После этого следует обычный для формата <font color="#000099">bin</font> 
  код программы &#151; вы можете использовать все три стандартные секции <font color="#000099">.text, 
  .data</font> и <font color="#000099">.bss</font>. В конце файла вы должны вызвать 
  макрос <font color="#000099">EXE_end</font> (без аргументов), который для маркировки 
  размеров секции определяет некоторые символы, ссылающиеся на заголовок кода, 
  сгенерированный макросом <font color="#000099">EXE_begin</font>. 
<p>В данной модели написанный вами код стартует с адреса <font color="#000099">0x100</font>, 
  как и обычный <font color="#000099">.COM</font> файл &#151; в действительности, 
  если вы удалите 32-битный заголовок из сгенерированного <font color="#000099">.EXE</font> 
  файла, то получите работающую <font color="#000099">.COM</font> программу. Все 
  базы сегментов в полученном файле одинаковы, поэтому размер программы ограничен 
  64К (опять же, как и <font color="#000099">.COM</font> файл). Имейте в виду, 
  что директива <font color="#000099">ORG</font> используется макросом <font color="#000099">EXE_begin</font>, 
  поэтому вы не должны применять ее самостоятельно. 
<p>Вы не можете прямо ссылаться на значение базы вашего сегмента, к сожалению 
  это потребовало бы перемещений в заголовке, что реализовать гораздо сложнее. 
  Поэтому вы должны получать базу сегмента копированием ее из <font color="#000099">CS</font>. 
<p>При запуске полученного <font color="#000099">.EXE</font> файла пара <font color="#000099">SS:SP</font> 
  настраивается на указание вершины 2Кб стека. Вызвав макрос <font color="#000099">EXE_stack</font>, 
  вы можете изменить размер стека по умолчанию. Например, для изменения размера 
  стека вашей программы до <font color="#000099">64 байт</font> вы должны вызвать 
  <font color="#000099">EXE_stack 64</font>. 
<p>В подкаталоге архива NASM содержится простая программа <font color="#000099">binexe.asm</font>, 
  из которой <font color="#000099">.EXE</font> файл создается вышеописанным способом. 
<h3><a name="nasm_ru7_html_section-7.2">7.2 Получение .COM файлов</a></h3>
<p>В то время, как большие DOS-программы должны писаться в виде <font color="#000099">.EXE</font> 
  файлов, небольшие часто лучше и проще написать как <font color="#000099">.COM</font> 
  файлы. <font color="#000099">.COM</font> файлы являются чисто бинарными, поэтому 
  большинство их может быть создано при помощи выходного формата <font color="#000099">bin</font>. 
<h4><a name="nasm_ru7_html_section-7.2.1">7.2.1 Использование формата <font color="#000099">bin</font> 
  для получения <font color="#000099">.COM</font> файлов</a></h4>
<p><font color="#000099">.COM</font> файлы загружаются в свой сегмент по смещению 
  <font color="#000099">100h</font> (сегмент может меняться). Выполнение начинается 
  с адреса 100h, т.е. программа по этому адресу стартует. Таким образом, при написании 
  <font color="#000099">.COM</font> программы ваш исходный файл должен выглядеть 
  наподобие следующего: 
<p>
<pre>
          org 100h 
          section .text 
start:    ; сюда поместите код 
          section .data 
          ; сюда поместите данные 
          section .bss 
          ; здесь находятся неинициализированные данные
</pre>
<p>Формат <font color="#000099">bin</font> помещает секцию <font color="#000099">.text</font> 
  в начале файла, поэтому вы можете объявлять данные или BSS перед написанием 
  собственно кода. 
<p>Секция <font color="#000099">BSS</font> (неинициализированные данные) не занимает 
  места в самом <font color="#000099">.COM</font> файле: вместо этого адреса BSS-элементов 
  разрешаются относительно адреса конца файла, т.е. при запуске программы это 
  пространство будет являться свободной памятью, поэтому вы не должны предполагать, 
  что оно будет заполнено нулями или чем-либо еще &#151; там находится просто 
  мусор. 
<p>Для ассемблирования приведенной выше программы вы должны использовать следующую 
  командную строку: 
<p><pre>
nasm myprog.asm -fbin -o myprog.com
</pre>
<p>Если явно не указать имя выходного файла, формат <font color="#000099">bin</font> 
  создаст файл с именем <font color="#000099">myprog</font>; в этом случае вы 
  можете просто переименовать его так, как вам нужно. 
<h4><a name="nasm_ru7_html_section-7.2.2">7.2.2 Использование формата <font color="#000099">obj</font> 
  для получения <font color="#000099">.COM</font> файлов</a></h4>
<p>Если вы пишете <font color="#000099">.COM</font> программу с применением более 
  одного модуля, то возможно захотите ассемблировать несколько <font color="#000099">.OBJ</font> 
  файлов и затем собрать их в одну программу. Вы можете это сделать двумя путями: 
  при помощи компоновщика, способного непосредственно создавать <font color="#000099">.COM</font> 
  файлы (TLINK это может) или применив конвертер <font color="#000099">EXE2BIN</font> 
  для преобразования <font color="#000099">.EXE</font> файла, полученного на выходе 
  компоновщика, в <font color="#000099">.COM</font> файл. 
<p>Если вы это делаете, вам нужно позаботиться о нескольких вещах: 
<ul>
  <li>Кодовый сегмент первого объектного файла должен начинаться со строки вида 
    <font color="#000099">RESB 100h</font>. Это гарантирует начало кода по смещению 
    <font color="#000099">100h</font> относительно начала сегмента, так чтобы 
    компоновщик или программа конвертации не корректировали адресные ссылки при 
    генерации <font color="#000099">.COM</font> файла. Другие ассемблеры для данной 
    цели используют директиву <font color="#000099">ORG</font>, однако в NASM 
    <font color="#000099">ORG</font> является дополнительной директивой выходного 
    формата <font color="#000099">bin</font> и не означает то же самое, что в 
    MASM-совместимых ассемблерах. 
  <li>Вам не нужно определять сегмент стека. 
  <li>Все ваши сегменты должны быть в одной и той же группе, чтобы все смещения 
    на символы как в коде, так и в данных были смещениями относительно одной и 
    той же базы сегмента. Это нужно для того, чтобы при загрузке <font color="#000099">.COM</font> 
    файла все сегментные регистры содержали одно и то же значение. 
</ul>
<h3><a name="nasm_ru7_html_section-7.3">7.3 Получение .SYS файлов</a></h3>
<p>Драйверы устройств MS-DOS &#151; <font color="#000099">.SYS</font> файлы &#151; 
  это чисто бинарные файлы, во всем похожие на <font color="#000099">.COM</font>, 
  за исключением того, что они запускаются по нулевому смещению, а не по смещению 
  <font color="#000099">100h</font>. Поэтому если вы пишете драйвер при помощи 
  формата <font color="#000099">bin</font>, директива <font color="#000099">ORG</font> 
  вам не нужна, так как по умолчанию смещение для <font color="#000099">bin</font> 
  всегда нулевое. Соответственно вам не требуется указывать в начале кодового 
  сегмента <font color="#000099">RESB 100h</font>, если вы используете формат 
  <font color="#000099">obj</font>. 
<p><font color="#000099">.SYS</font> файлы начинаются с заголовочной структуры, 
  содержащей указатели на различные подпрограммы внутри драйвера. Данная структура 
  должна быть определена в начале сегмента кода, несмотря на то, что в действительности 
  кодом она не является. 
<p>Дополнительную информацию о формате <font color="#000099">.SYS</font> файлов 
  и данных, содержащихся в их заголовочной структуре, вы можете почерпнуть в часто 
  задаваемых вопросах конференции <a href="news:comp.os.msdos.programmer">comp.os.msdos.programmer</a>. 
<h3><a name="nasm_ru7_html_section-7.4">7.4 Взаимодействие с 16-битными C-программами</a></h3>
<p>В данном параграфе описываются основы создания ассемблерных подпрограмм, которые 
  вызывают или которые вызываются из программ С. Для осуществления этого обычно 
  нужно написать ассемблерный модуль в виде <font color="#000099">.OBJ</font> 
  файла и скомпоновать его с С-модулями. 
<h4><a name="nasm_ru7_html_section-7.4.1">7.4.1 Внешние символьные имена</a></h4>
<p>Компиляторы С имеют соглашения, в соответствии с которыми имена всех глобальных 
  символов (функций или данных) образуются путем префиксирования имени из С-программы 
  символом подчеркивания. Так, например, функция, о которой С-программист думает 
  как о <font color="#000099">printf</font>, для программиста на ассемблере является<font color="#000099"> 
  _printf</font>. Это означает, что в своей ассемблерной программе вы можете определять 
  символы без лидирующего знака подчеркивания, не боясь при этом, что они случайно 
  совпадут с именами С-символов. 
<p>Если вам неудобно использовать знаки подчеркивания, вы можете определить макросы 
  для замены директив <font color="#000099">GLOBAL</font> и <font color="#000099">EXTERN</font> 
  следующим образом: 
<p><pre>
%macro cglobal 1 
          global _%1 
%define %1 _%1 
%endmacro
</pre>
<p><pre>
%macro cextern 1 
          extern _%1 
%define %1 _%1 
%endmacro
</pre>
<p>(Данные формы макросов принимают только один аргумент; если вам требуется больше, 
  используйте конструкцию <font color="#000099">%rep</font>). 
<p>Если вы определите внешний символ как 
<p><pre>
          cextern printf
</pre>
<p>макрос развернет его в следующие строки: 
<p><pre>
          extern _printf 
%define printf _printf
</pre>
<p>Thereafter, you can reference printf as if it
was a symbol, and the preprocessor will put the leading underscore on where
necessary.
<p>После этого вы можете ссылаться на <font color="#000099">printf</font>, а препроцессор, 
  где это нужно, будет помещать ведущий знак подчеркивания. Макрос <font color="#000099">cglobal</font> 
  работает точно также. 
<h4><a name="nasm_ru7_html_section-7.4.2">7.4.2 Модели памяти</a></h4>
<p>NASM прямо не поддерживает механизма различных моделей памяти, реализованных 
  в С; вы должны отслеживать это самостоятельно. Это означает, что вы должны учитывать 
  следующее: 
<ul>
  <li>В моделях, имеющих один сегмент кода (tiny, small и compact), функции являются 
    ближними. Это значит, что указатели на функции при сохранении в сегменте данных 
    или помещении в стек являются 16-битными и содержат только поле смещения (регистр 
    <font color="#000099">CS</font> никогда не изменяет свое значение и всегда 
    содержит сегментную часть полного адреса функции) и что такие функции вызываются 
    инструкцией <font color="#000099">near CALL</font> и возврат из них производится 
    при помощи <font color="#000099">RETN</font> (что в NASM является синонимом 
    <font color="#000099">RET</font>). Следовательно, вы должны писать свои подпрограммы 
    с использованием <font color="#000099">RETN</font>, а также вызывать внешние 
    С-подпрограммы при помощи ближней инструкции <font color="#000099">CALL</font>. 
  <li>В моделях, использующих более одного сегмента кода (medium, large и huge), 
    функции являются дальними. Это значит, что длина указателей функций составляет 
    32 бита (16 бит смещение и 16 бит сегмент) и что функции вызываются при помощи 
    <font color="#000099">CALL FAR</font> (или <font color="#000099">CALL seg:offset</font>) 
    и возврат из них производится при помощи <font color="#000099">RETF</font>. 
    При использовании таких моделей вы должны писать свои подпрограммы так, чтобы 
    возврат из них производился по <font color="#000099">RETF</font>, а внешние 
    подпрограммы вызывать при помощи <font color="#000099">CALL FAR</font>. 
  <li>В моделях, использующих единственный сегмент данных (tiny, small и medium), 
    указатели на данные являются 16-битными, содержащими только поле смещения 
    (регистр <font color="#000099">DS</font> не изменяет своего значения и всегда 
    представляет сегментную часть полного адреса). 
  <li>В моделях, использующих более одного сегмента данных (compact, large и huge), 
    длина указателей на данные составляет 32 бит, 16 бит из которых является смещением, 
    а другие 16 бит &#151; сегментом. Вы должны стараться в своих подпрограммах 
    не модифицировать <font color="#000099">DS</font> без необходимости, а после 
    модификации &#151; всегда восстанавливать. В то же время регистр <font color="#000099">ES</font> 
    свободен и вы можете использовать его для доступа к содержимому, на которое 
    ссылается 32-битный указатель. 
  <li>Модель памяти <font color="#000099">huge</font> позволяет одиночным элементам 
    данных превышать размер 64К. В любых других моделях вы можете получить доступ 
    ко всем элементам данных простым арифметическим манипулированием переданного 
    поля смещения (неважно, присутствует поле сегмента или нет). В модели памяти 
    huge к вычислению указателей надо подходить более тщательно. 
  <li>В большинстве моделей памяти имеется сегмент данных <i>по умолчанию</i>, 
    сегментный адрес которого хранится в <font color="#000099">DS</font> на протяжении 
    всего выполнения программы. Этот сегмент данных обычно совпадает с сегментом 
    стека, хранящемся в <font color="#000099">SS</font>, поэтому и локальные переменные 
    функций (хранящиеся в стеке), и глобальные элементы данных могут быть легко 
    доступны без изменения <font color="#000099">DS</font>. Большие элементы данных 
    обычно хранятся в других сегментах. Однако некоторые модели памяти (хотя обычно 
    они нестандартные) используют <font color="#000099">SS</font> и <font color="#000099">DS</font> 
    по другому. Будьте внимательны в этом случае по отношению к локальным переменным 
    функций. 
</ul>
<p>В моделях с единственным сегментом кода этот сегмент называется <font color="#000099">_TEXT</font>, 
  поэтому ваш сегмент должен иметь то же самое имя для компоновки его в то же 
  место, что и основной сегмент кода. В моделях с единственным сегментом данных 
  или с сегментом данных по умолчанию последний именуется как <font color="#000099">_DATA</font>. 
<h4><a name="nasm_ru7_html_section-7.4.3">7.4.3 Определения и вызовы функций</a></h4>
<p>Соглашения по вызовам С в 16-битных программах описываются ниже. 
<ul>
  <li>Вызывающая программа помещает параметры функции в стек один за другим в 
    обратном порядке следования (так что первый аргумент функции помещается в 
    стек последним). 
  <li>Вызывающая программа выполняет инструкцию <font color="#000099">CALL</font> 
    для передачи управления подпрограмме. Эта инструкция в зависимости от модели 
    памяти может быть как ближней, так и дальней. 
  <li>Подпрограмма получает управление и обычно (несмотря на то, что это не требуется 
    в функциях, которым не нужен доступ к своим параметрам) начинается с сохранения 
    <font color="#000099">SP</font> в <font color="#000099">BP</font> с целью 
    дальнейшего использования <font color="#000099">BP</font> в качестве базы 
    указателя для нахождения параметров в стеке. Однако частью соглашений о вызовах 
    является сохранение содержимого <font color="#000099">BP</font> любой функцией 
    С. Следовательно подпрограмма, если она использует <font color="#000099">BP</font> 
    как указатель кадра, должна предварительно поместить в стек его содержимое. 
  <li>Подпрограмма может получить свои параметры через <font color="#000099">BP</font>. 
    Слово <font color="#000099">[BP]</font> хранит предыдущее значение <font color="#000099">BP</font>, 
    помещенное в стек; следующее слово, <font color="#000099">[BP+2]</font>, хранит 
    смещение адреса возврата, помещенное в стек инструкцией <font color="#000099">CALL</font>. 
    В ближних функциях после этого (<font color="#000099">[BP+4]</font>) начинаются 
    параметры; в дальных функциях по адресу <font color="#000099">[BP+4]</font> 
    находится сегментная часть адреса возврата и параметры начинаются с <font color="#000099">[BP+6]</font>. 
    Самый левый параметр функции доступен по смещению из <font color="#000099">BP</font>, 
    т.к. в стек он был помещен последним; следующие параметры соответственно доступны 
    по следующим смещениям. Таким образом, в функциях с переменным числом параметров, 
    подобных <font color="#000099">printf</font>, помещение параметров в стек 
    в обратном порядке означает, что функция знает, где находится ее первый параметр, 
    сообщающий число и тип оставшихся параметров. 
  <li>Подпрограмма после этого может увеличить значение <font color="#000099">SP</font>, 
    например для распределения места в стеке для локальных переменных, которые 
    после этого будут доступны по отрицательным смещениям от <font color="#000099">BP</font>. 
  <li>Подпрограмма, если она возвращает значение вызывающей программе, должна 
    передавать это значение в <font color="#000099">AL, AX</font> или <font color="#000099">DX:AX</font> 
    в зависимости от размера последнего. Результаты, являющиеся числами с плавающей 
    точкой иногда (в зависимости от компилятора) возвращаются в регистре сопроцессора 
    <font color="#000099">ST0</font>. 
  <li>Как только подпрограмма завершит свою работу, она восстанавливает значение 
    <font color="#000099">SP</font> из <font color="#000099">BP</font> (если она 
    распределяла локальное пространство стека), затем изымает из стека предыдущее 
    значение <font color="#000099">BP</font> и в зависимости от модели памяти 
    возвращается в вызвавшую программу через <font color="#000099">RETN</font> 
    или <font color="#000099">RETF</font>. 
  <li>Когда вызывающая программа возвратит себе управление, параметры функции 
    остаются в стеке, поэтому для удаления их к <font color="#000099">SP</font> 
    обычно прибавляется непосредственная константа (вместо выполнения серии медленных 
    инструкций <font color="#000099">POP</font>). Поэтому если функция случайно 
    (например, из-за несоответствия прототипов) будет вызвана с неверным числом 
    параметров, стек при возврате останется в осмысленном состоянии, т.к. вызвавшая 
    программа, которая <i>знает</i>, сколько параметров она поместила в стек, 
    удалит их. 
</ul>
<p>Поучительно сравнить данное соглашение о вызовах с программами на Паскале (см. 
  <a href="#nasm_ru7_html_section_7_5_1">параграф 7.5.1</a>). Паскаль имеет более простое соглашение, 
  т.к. в нем нет функций с переменным числом параметров и подпрограмма знает, 
  сколько параметров ей передается и способна самостоятельно удалить их из стека 
  путем указания в инструкциях <font color="#000099">RET</font> или <font color="#000099">RETF</font> 
  непосредственного значения. Параметры помещаются в стек слева-направо, а не 
  справа-налево как в С, поэтому компилятор может дать лучшую гарантию последовательности 
  выполнения без снижения производительности. 
<p>Исходя из вышесказанного, вы можете определить С-подобную функцию следующим 
  образом (в примере использована модель памяти <font color="#000099">small</font>): 
<p>
<pre>
          global _myfunc 
_myfunc:  push bp 
          mov bp,sp 
          sub sp,0x40            ; 64 байта локального пространства стека 
          mov bx,[bp+4]          ; первый параметр функции 
          ; некоторый код
          mov sp,bp              ; отмена "sub sp,0x40" выше
          pop bp 
          ret
</pre>
<p>Для больших моделей памяти вы должны заменить <font color="#000099">RET</font> 
  в данной функции на <font color="#000099">RETF</font> и брать первый параметр 
  не из <font color="#000099">[BP+4]</font>, а из <font color="#000099">[BP+6]</font>. 
  Естественно, если один из параметров будет указателем, смещения следующих параметров 
  будут зависеть от модели памяти: дальние указатели занимают в стеке 4 байта, 
  в то время как короткие &#151; два. 
<p>Если посмотреть с другой стороны, то для вызова С-функции из вашего ассемблерного 
  кода вы должны сделать что-то наподобие следующего: 
<p>
<pre>
          extern _printf 
          ; здесь идет супер-пупер-прога... 
          push word [myint]      ; целое значение - параметр 
          push word mystring     ; указатель на мой сегмент данных 
          call _printf 
          add sp,byte 4          ; 'byte' экономит размер 
          ; затем следует сегмент данных... 
          segment _DATA 
myint     dw 1234 
mystring  db 'Это число -> %d <- должно быть 1234, фуфел!',10,0
</pre>
<p>Этот ассемблерный код, использующий модель памяти small, эквивалентен С-коду 
<p>
<pre>
    int myint = 1234; 
    printf("Это число -> %d <- должно быть 1234, фуфел!\n", myint);
</pre>
<p>В больших моделях памяти кодирование функции вызова выглядит похоже, но все-таки 
  несколько отличается. В приведенном ниже примере подразумевается, что регистр 
  <font color="#000099">DS</font> уже содержит базу сегмента<font color="#000099"> 
  _DATA</font>. Если это не так, вы должны его проинициализировать. 
<p>
<pre>
          push word [myint] 
          push word seg mystring ; Теперь сохраняем в стеке сегмент, и... 
          push word mystring     ; ... смещение "mystring" 
          call far _printf 
          add sp,byte 6
</pre>
<p>Целое число по прежнему будет занимать в стеке одно слово, так как большая 
  модель памяти не влияет на размер типа данных <font color="#000099">int</font>. 
  В то же время первый аргумент для <font color="#000099">printf</font> (помещаемый 
  в стек последним), является указателем и поэтому состоит из двух частей &#151; 
  сегмента и смещения. Сегмент должен сохраняться в памяти вторым, поэтому в стек 
  он помещается первым. (Конечно <font color="#000099">PUSH DS</font> будет иметь 
  более короткую инструкцию, чем <font color="#000099">PUSH WORD SEG mystring</font>, 
  если <font color="#000099">DS</font> инициализирован так, как подразумевается 
  в приведенном примере). Затем следует дальний вызов <font color="#000099">call 
  far</font>, как это определено для больших моделей памяти; после возврата из 
  подпрограммы регистр стека увеличивается на 6 (а не на 4) с целью коррекции 
  на размер дополнительного слова, помещенного туда ранее. 
<h4><a name="nasm_ru7_html_section-7.4.4">7.4.4 Доступ к элементам данных</a></h4>
<p>Для получения доступа к переменным С или объявления переменных, к которым С 
  в свою очередь может обратиться, вы должны всего лишь объявить имена как <font color="#000099">EXTERN</font> 
  или <font color="#000099">GLOBAL</font> соответственно. (Имена требуют лидирующего 
  знака подчеркивания, см. <a href="#nasm_ru7_html_section_7_4_1">параграф 7.4.1</a>.) Таким 
  образом, объявленная в С переменная<font color="#000099"> int i</font> может 
  быть доступна из ассемблера как 
<p><pre>
          extern _i 
          mov ax,[_i]
</pre>
<p>Чтобы объявить собственную целую переменную, к которой С-программа сможет обратиться 
  как <font color="#000099">extern int j</font>, вы должны сделать следующее (убедитесь, 
  что эта переменная находится в сегменте <font color="#000099">_DATA</font>): 
<p><pre>
          global _j 
_j        dw 0
</pre>
<p>Для получения доступа к С-массиву вам нужно знать размер компонетов последнего. 
  Например, переменные типа <font color="#000099">int</font> имеют размер два 
  байта (слово), поэтому если С-программа объявляет массив как <font color="#000099">int 
  a[10]</font>, вы можете обратиться к элементу <font color="#000099">a[3]</font> 
  при помощи инструкции <font color="#000099">mov ax,[_a+6]</font>. (Байтовое 
  смещение 6 получено путем умножения индекса 3 требуемого элемента на размер 
  элементов массива 2). Размеры базовых типов С для 16-битных компиляторов: 1 
  для <font color="#000099">char</font>, 2 для <font color="#000099">short</font> 
  и <font color="#000099">int</font>, 4 для <font color="#000099">long</font> 
  и <font color="#000099">float</font>, 8 для <font color="#000099">double</font>. 
<p>Чтобы получить доступ к структуре данных С, вам необходимо знать смещение интересующего 
  вас поля от базы этой структуры. Вы можете сделать это либо преобразовав определение 
  С-структуры в определение NASM-структуры (при помощи <font color="#000099">STRUC</font>), 
  либо рассчитать это смещение и использовать его "как есть". 
<p>Чтобы правильно использовать структуры С, вы должны изучить руководство по 
  вашему С-компилятору, чтобы знать, как он организует структуры данных. NASM 
  не делает специального выравнивания для членов его собственных структур <font color="#000099">STRUC</font>, 
  поэтому если С-компилятор делает это, вы можете задать такое смещение самостоятельно. 
  Обычно вы можете предположить, что структура наподобие 
<p><pre>
struct { 
    char c; 
    int i; 
} foo;
</pre>
<p>будет иметь длину 4 байта, а не 3, так как поле <font color="#000099">int</font> 
  выравнивается по двухбайтной границе. Однако такие особенности имеют тенденцию 
  конфигурироваться компилятором С при помощи ключей командной строки, либо директив 
  <font color="#000099">#pragma</font>, поэтому вы должны выяснить, как именно 
  это делает ваш компилятор. 
<h4><a name="nasm_ru7_html_section-7.4.5">7.4.5 c16.mac: Макросы для 16-битного C-интерфейса</a></h4>
<p>В подкаталоге <font color="#000099">misc</font> архива NASM имеется файл макросов 
  <font color="#000099">c16.mac</font>. В нем определены три макроса: <font color="#000099">proc, 
  arg</font> и <font color="#000099">endproc</font>. Они предназначены для использования 
  в определениях С-подобных процедур и автоматизируют большинство работ по слежению 
  за соблюдением соглашения о вызовах. 
<p>Ниже приведен пример ассемблерной функции, использующей этот набор макросов: 
<p><pre>
          proc _nearproc 
%$i       arg 
%$j       arg 
          mov ax,[bp + %$i] 
          mov bx,[bp + %$j] 
          add ax,[bx] 
          endproc
</pre>
<p>Здесь определяется процедура <font color="#000099">_nearproc</font>, принимающая 
  два аргумента, первый (<font color="#000099">i</font>) &#151; это целое и второй 
  (<font color="#000099">j</font>) &#151; указатель на целое. Процедура возвращает 
  <font color="#000099">i + *j</font>. 
<p>Заметьте, что макрос <font color="#000099">arg</font> при его разворачивании 
  содержит в первой строке <font color="#000099">EQU</font>, которая в результате 
  определяет <font color="#000099">%$i</font> как смещение от <font color="#000099">BP</font>. 
  При этом используются контекстно-локальные переменные (локальные к контексту, 
  сохраняемому в контекстном стеке макросом <font color="#000099">proc</font> 
  и удаляемому оттуда макросом <font color="#000099">endproc</font>), поэтому 
  в других процедурах может быть использовано то же самое имя аргумента. Конечно, 
  вы можете этого <i>не делать</i>. 
<p>По умолчанию представленный набор макросов создает код для ближних функций 
  (модели памяти tiny, small и compact). Чтобы генерировать код для дальних функций 
  (модели medium, large и huge), вы должны определить <font color="#000099">%define 
  FARCODE</font>. Данное определение изменяет тип возвращаемой <font color="#000099">endproc</font> 
  инструкции, а также начальную точку смещения аргументов. Набор макросов совершенно 
  не зависит от того, являются ли указатели данных дальними или нет. 
<p>Макрос <font color="#000099">arg</font> может принимать дополнительный параметр, 
  представляющий собой размер аргумента. Если размер не задан, по умолчанию принимается 
  2, т.к. большинство параметров функций вероятно будут иметь тип <font color="#000099">int</font>. 
<p>Эквивалент представленной выше функции для модели памяти large будет таким: 
<p><pre>
%define FARCODE 
          proc _farproc 
%$i       arg 
%$j       arg 4 
          mov ax,[bp + %$i] 
          mov bx,[bp + %$j] 
          mov es,[bp + %$j + 2] 
          add ax,[bx] 
          endproc
</pre>
<p>Так как<font color="#000099"> j</font> теперь будет дальним указателем, в этом 
  примере используется аргумент макроса <font color="#000099">arg</font>, определяющий 
  параметр размером 4. Когда мы читаем значение по адресу <font color="#000099">j</font>, 
  мы должны загрузить как смещение, так и сегмент. 
<h3><a name="nasm_ru7_html_section-7.5">7.5 </a>Взаимодействие с программами Borland Pascal</h3>
<p>Взаимодействие с программами на Паскале в концепции схоже по взаимодействию 
  с 16-битными С-программами, однако имеются следующие различия: 
<ul>
  <li>Требуемые для взаимодействия с С-программами ведущие символы подчеркивания 
    в Паскале не нужны. 
  <li>Модель памяти всегда большая: функции и указатели данных являются дальними, 
    но длина отдельного элемента данных не должна превышать 64К. (На самом деле 
    некоторые функции остаются ближними, но эти функции локализованы в модуле 
    Паскаля и <i>никогда</i> не вызываются извне. Все функции ассемблера, осуществляющие 
    Паскаль-вызовы, а также все функции Паскаля, обращающиеся к ассемблерному 
    коду, <i>должны быть дальними</i>). В то же время все объявленные в Паскаль-программе 
    статические данные помещаются в сегменте данных по умолчанию, т.е. его сегментный 
    адрес при передаче управления вашему ассемблерному коду будет содержаться 
    в DS. В сегменте данных не располагаются только локальные переменные (они 
    находятся в сегменте стека) и переменные, память для которых выделяется динамически. 
    Однако все <i>указатели</i> данных являются дальними. 
  <li>Соглашение о вызовах функций отличается от С &#151; описание приведено далее. 
  <li>Некоторые типы данных, такие как строки, хранятся по другому. 
  <li>Имеются ограничения на имена сегментов, которые вам разрешено использовать 
    &#151; Borland Pascal будет игнорировать код или данные, объявленные в сегменте 
    с неподходящим именем. Эти ограничения также описаны ниже. 
</ul>
<h4><a name="nasm_ru7_html_section-7.5.1">7.5.1 Соглашение о вызовах в Pascal</a></h4>
<p>Ниже описываются соглашения о вызовах в 16-битных Паскаль-программах. 
<ul>
  <li>Вызывающая программа помещает параметры функции в стек один за другим в 
    обычном порядке (слева-направо, так что первый аргумент функции помещается 
    также первым). 
  <li>Вызывающая программа для передачи управления подпрограмме выполняет дальнюю 
    инструкцию <font color="#000099">CALL</font>. 
  <li>Подпрограмма получает управление и обычно (несмотря на то, что это не требуется 
    в функциях, которым не нужен доступ к своим параметрам) начинается с сохранения 
    <font color="#000099">SP</font> в <font color="#000099">BP</font> с целью 
    дальнейшего использования <font color="#000099">BP</font> в качестве базы 
    указателя для нахождения параметров в стеке. Однако частью соглашений о вызовах 
    является сохранение содержимого <font color="#000099">BP</font> любой функцией. 
    Следовательно подпрограмма, если она использует <font color="#000099">BP</font> 
    как указатель кадра, должна предварительно поместить в стек его содержимое. 
  <li>Подпрограмма может получить доступ к своим параметрам относительно <font color="#000099">BP</font>. 
    Слово <font color="#000099">[BP]</font> адресует в стеке предыдущее значение 
    <font color="#000099">BP</font>. Следующее слово, <font color="#000099">[BP+2]</font>, 
    адресует смещение адреса возврата, а <font color="#000099">[BP+4]</font> &#151; 
    сегмент адреса возврата. Параметры начинаются со смещения <font color="#000099">[BP+6]</font>. 
    По этому смещению от <font color="#000099">BP</font> доступен самый "правый" 
    параметр функции, так как в стек он был помещен последним; следующие параметры 
    идут соответственно по более большим смещениям. 
  <li>В процессе выполнения подпрограмма может увеличить значение <font color="#000099">SP</font> 
    с целью выделения в стеке места под свои локальные переменные. Эти переменные 
    будут доступны по отрицательным от <font color="#000099">BP</font> смещениям. 
  <li>Подпрограмма должна передавать результат выполнения назад в вызвавшую программу 
    через <font color="#000099">AL, AX</font> или <font color="#000099">DX:AX</font>, 
    в зависимости от размера значения. Результаты в виде чисел с плавающей точкой 
    возвращаются через регистр <font color="#000099">ST0</font>. Результаты типа 
    <font color="#000099">Real</font> (собственные типы Борланда &#151; числа 
    с плавающей точкой, прямо не обрабатываемые в <font color="#000099">FPU</font>) 
    возвращаются в группе <font color="#000099">DX:BX:AX</font>. Чтобы возвратить 
    результат типа <font color="#000099">String</font>, вызывающая программа перед 
    помещением в стек параметров помещает туда указатель на временную строку, 
    а подпрограмма по этому адресу возвращает строковое значение. Указатель не 
    является параметром и не должен удаляться из стека инструкцией <font color="#000099">RETF</font>. 
  <li>Когда подпрограмма заканчивает свою работу, она восстанавливает содержимое 
    <font color="#000099">SP</font> из <font color="#000099">BP</font>, достает 
    из стека предыдущее значение <font color="#000099">BP</font> и возвращается 
    через <font color="#000099">RETF</font>. Здесь используется форма <font color="#000099">RETF</font> 
    с непосредственным операндом, представляющим собой число байт, снимаемых с 
    вершины стека в качестве параметров. Снятие параметров со стека &#151; это 
    побочный эффект инструкции возврата. 
  <li>Дополнительных действий от вызвавшей программы не требуется, так как параметры 
    функции при получении ей управления уже удалены из стека. 
</ul>
<p>Исходя из вышесказанного, вы должны определить функцию в стиле Паскаль, принимающую 
  два аргумента типа <font color="#000099">Integer</font>, следующим образом: 
<p>
<pre>
          global myfunc 
myfunc:   push bp 
          mov bp,sp 
          sub sp,0x40            ; резервируется 64 байта в стеке 
          mov bx,[bp+8]          ; первый аргумент функции 
          mov bx,[bp+6]          ; второй аргумент функции 
          ; код, который наверное что-то делает
          mov sp,bp              ; отмена "sub sp,0x40" выше 
          pop bp 
          retf 4                 ; общий размер аргументов 4
</pre>
<p>С другой стороны, для вызова Паскаль-функции из вашего ассемблерного кода, 
  вы должны сделать что-то вроде следующего: 
<p>
<pre>
          extern SomeFunc 
          ; тут идет какой-то код...
          push word seg mystring ; Теперь в стек помещается сегмент и...
          push word mystring     ; ... смещение строки "mystring"
          push word [myint]      ; одна из переменных 
          call far SomeFunc
</pre>
<p>Этот код эквивалентен следующим строкам на Паскале: 
<p><pre>
procedure SomeFunc(String: PChar; Int: Integer); 
    SomeFunc(@mystring, myint);
</pre>
<h4><a name="nasm_ru7_html_section-7.5.2">7.5.2 Ограничение имен сегментов в Borland Pascal</a></h4>
<p>Так как внутренний формат модуля Borland Pascal полностью отличается от <font color="#000099">OBJ</font>, 
  при компоновке модуля с реальным <font color="#000099">OBJ</font> файлом выполняется 
  очень поверхностная работа по чтению и пониманию различной информации из последнего. 
  Вследствие этого объектные файлы, предназначенные для компоновки с Паскаль-программами, 
  должны удовлетворять нескольким ограничениям: 
<ul>
  <li>Процедуры и функции должны находиться в сегменте с именем <font color="#000099">CODE, 
    CSEG</font>, или заканчивающимся на <font color="#000099">_TEXT</font>. 
  <li>Инициализированные данные должны находиться в сегменте с именем <font color="#000099">CONST</font> 
    или заканчивающимся на <font color="#000099">_DATA</font>. 
  <li>Неинициализированные данные должны находиться в сегменте с именем <font color="#000099">DATA, 
    DSEG</font>, или заканчивающимся на <font color="#000099">_BSS</font>. 
  <li>Любые другие сегменты, имеющиеся в объектном файле, полностью игнорируются. 
    Директивы <font color="#000099">GROUP</font> и атрибуты сегментов также игнорируются. 
</ul>
<h4><a name="nasm_ru7_html_section-7.5.3">7.5.3 Использование <font color="#000099">c16.mac</font> 
  с Pascal-программами</a></h4>
<p>Пакет макросов c16.mac, описанный в <a href="#nasm_ru7_html_section_7_4_5">параграфе 7.4.5</a>, 
  может быть также использован для облегчения написания функций, вызываемых из 
  программ на Паскале. Для этого вам нужно определить <font color="#000099">%define 
  PASCAL</font>. Данное определение делает все функции дальними (это подразумевает 
  <font color="#000099">FARCODE</font>), а также генерирует инструкции возврата 
  из подпрограммы в форме, имеющей операнд. 
<p>Определение <font color="#000099">PASCAL</font> не изменяет код, рассчитывающий 
  смещения аргументов; вы должны объявлять аргументы вашей функции в обратном 
  порядке. Например: 
<p><pre>
%define PASCAL 
          proc _pascalproc 
%$j       arg 4 
%$i       arg 
          mov ax,[bp + %$i] 
          mov bx,[bp + %$j] 
          mov es,[bp + %$j + 2] 
          add ax,[bx] 
          endproc
</pre>
<p>Концептуально здесь определяется та же самая подпрограмма, что и в <a href="#nasm_ru7_html_section_7_4_5">параграфе 
  7.4.5</a>: функция принимает два аргумента, целое число и указатель на целое 
  и возвращает сумму целого и содержимого, на которое ссылается указатель. Отличие 
  между этим кодом и версией С для большой модели памяти состоит в том, что вместо 
  <font color="#000099">FARCODE</font> определяется <font color="#000099">PASCAL</font>, 
  а аргументы объявляются в обратном порядке. 
<p align=center><a href="#nasm_ru8_html">Следующая глава</a> | <a href="#nasm_ru6_html">Предыдущая 
  глава </a> | <a href="#contents_html">Содержание</a>
<hr>

<a name="nasm_ru8_html"></a>
<h1 align=center>Расширенный Ассемблер: NASM</h1>

<p align=center><a href="#nasm_ru9_html">Следующая глава</a> | <a href="#nasm_ru7_html">Предыдущая 
  глава</a> | <a href="#contents_html">Содержание</a> | Указатель</p>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr> 
    <td width="71%"> 
      <h2><a name="nasm_ru8_html_chapter-8">Глава 8: Написание 32-х битного кода <br>
        (Unix, Win32, DJGPP)</a></h2>
    </td>
    <td width="29%"> 
      <div align="right"><font size="-1" color="#666666">Перевод: <a href="http://asmdev.narod.ru/asmos.html">AsmOS 
        group</a>, &copy; 2001</font></div>
    </td>
  </tr>
</table>
Эта глава повествует о наиболее распространенных проблемах, возникающих
при написании 32-ух разрядного кода для Win32 или Unix, или для сборки
(linking) с Си-кодом, полученным компилятором Си Unix-стиля, таким как
DJGPP. Здесь также рассматривается как писать ассемблерный код для
взаимодействия (interface) с кодом, полученным 32-ух битным компилятором
с Cи и как создавать перемещаемый код для разделяемых библиотек.

<p>Почти весь 32-ух битный код и практически весь код, выполняемый под Win32, 
  DJGPP или под любой вариант Unix для ПК выполняется в <em>плоской</em> (<em>flat</em>) 
  модели памяти. Это означает, что сегментные регистры и механизм страничной адресации 
  уже установлены заранее для того, чтобы дать вам одно и то же 32-битное адресное 
  пространство в 4 Гб, не зависимо относительно какого сегмента вы работаете, 
  и поэтому вы должны полностью игнорировать (не использовать) все сегментные 
  регистры. Когда вы пишите приложение под плоскую модель памяти, вам никогда 
  не потребуется замещение сегментов или изменение значения каких-либо сегментных 
  регистров, и адреса сегмента кода, которые вы передаете инструкциям <font color="#000099">CALL</font> 
  и <font color="#000099">JMP</font> остаются в том же адресном пространстве, 
  что и адреса сегмента данных через которые вы обращаетесь к переменным и адреса 
  сегмента стека, которые вы используете для доступа к локальным переменным и 
  параметрам процедур. Каждый адрес имеет размер 32 бита и содержит только смещение 
  (offset-ную) часть адреса. 
<h3><a name="nasm_ru8_html_section-8.1">8.1 Интерфейс с 32-ух битными программами на Си</a></h3>

<p>Все рассуждения в <a href="#nasm_ru7_html_section_7_4">параграфе 7.4</a>, относящиеся 
  к интерфейсу с 16-ти битными программами на Си также применимы и к 32-ух битным. 
  Отсутствие моделей памяти или сегментации не должно вызывать у вас беспокойства. 
<h4><a name="nasm_ru8_html_section_8_1_1">8.1.1 Внешние символьные имена</a></h4>
<p>Большинство 32-ух битных Си-компиляторов поддерживают конвенцию,
используемую в 16-ти битных компиляторах: имена всех глобальных
имен (функций или переменных) они определяют префиксом
⌠подчеркивание■ (например: extrn_link в Си будет _extrnlink в
линкуемом файле), добавляемое к имени, действующем в Си-программе.
Правда, не все это делают: спецификация ELF указывает, что все имена
в Си-программе <em>не имеют</em> предваряющего подчеркивания в их
эквивалентах на языке ассемблера.

<p>Старый Си-компилятор в Линуксе <font color="#000099">a.out</font>, все компиляторы 
  для Win32, DJGPP, NetBSD и FreeBSD, все они используют предваряющее ⌠подчеркивание■; 
  для этих компиляторов макросы <font color="#000099">cextern</font> и <code><font color="#000099">cglobal</font></code>, 
  как они описаны в <a href="#nasm_ru7_html_section_7_4_1">параграфе 7.4.1</a>, 
  будут работать. Для ELF, разумеется, предваряющее подчеркивание не используется. 
<h4><a name="nasm_ru8_html_section_8_1_2">8.1.2 Определение и вызов функций</a></h4>
<p>Конвенция Си для вызова в 32-ух битных программах приведена ниже.
В этом описании использованы выражения <em>вызывающий код</em> и
<em>вызываемая функция</em> для того, чтобы указать делает ли
функция вызов, или функция получает управление.

<ul>
  <li>Вызывающий код проталкивает параметры в стек один за другим в обратном порядке 
    (справа налево, таким образом, первый объявленный аргумент функции будет помещен 
    в стек последним). 
  <li>Затем вызывающий код выполняет ближний вызов, чтобы передать управление 
    вызываемой функции. 
  <li>Вызываемая функция, получая управление, и обычно (хотя это не всегда необходимо 
    в функциях, которые не обращаются к своим параметрам) начиная с сохранения 
    значений <font color="#000099">ESP</font> в <font color="#000099">EBP</font>,чтобы 
    можно было использовать <font color="#000099">EBP</font> как базовый указатель 
    для доступа к параметрам в стеке. Однако, вызывающий код возможно делает тоже 
    самое (устанавливает <font color="#000099">EBP</font> на свой стек), поэтому 
    по этой части конвенции о вызове, состояние <font color="#330099">EBP</font> 
    должно быть сохранено во всех Си-функциях. Поэтому вызываемая функция, если 
    она хочет установить <font color="#000099">EBP</font> как указатель на свои 
    параметры должна сначала сохранить в стеке его предыдущее значение. 
  <li>Вызываемая функция может обращаться к своим параметрам относительно <font color="#000099">EBP</font>. 
    Двойное слово по адресу <font color="#000099">[EBP]</font> содержит предыдущее 
    значение <font color="#000099">EBP</font>, т.к. оно было сохранено в стеке; 
    следующее двойное слово по адресу <font color="#000099">[EBP+4]</font> содержит 
    адрес возврата, протолкнутый туда инструкцией <font color="#000099">CALL</font>. 
    После этого начинаются параметры &#151; с адреса <font color="#000099">[EBP+8]</font>. 
    Самый левый параметр функции, т.к. он был помещен в стек последним, доступен 
    по этому смещению от <font color="#000099">EBP</font>; остальные расположены 
    по бОльшим смещениям. Поэтому, в таких функциях как <font color="#000099">printf</font>, 
    которые имеют переменное число параметров, заталкивание параметров в обратном 
    порядке позволяет функции узнать где находится первый параметр, в котором 
    содержится информация о количестве и типах остальных. 
  <li>Вызываемая функция также может уменьшить значение <font color="#000099">ESP</font> 
    для того, чтобы зарезервировать место в стеке для локальных переменных, которые 
    будут доступны как отрицательные смещения относительно <font color="#000099">EBP</font>. 
  <li>Вызываемая функция, если она хочет вернуть значение вызывающему коду, должна 
    оставить это значение в <font color="#000099">AL, AX</font> или <font color="#000099">EAX</font>, 
    в зависимости от размера. Значения с плавающей запятой обычно возвращаются 
    в <font color="#000099">ST0</font>. 
  <li>Как только вызываемая функция закончила свои основные действия, она восстанавливает 
    <font color="#000099">ESP</font> из <font color="#000099">EBP</font> если 
    она резервировала место в стеке, затем выталкивает предыдущее значение <font color="#000099">EBP</font>, 
    и возвращает управление через <font color="#000099">RET</font> (эквивалентно, 
    <font color="#000099">RETN</font>). 
  <li>Когда вызывающий код снова получает контроль от вызываемой функции, параметры 
    функции все еще остаются в стеке, поэтому обычно к значению <font color="#000099">ESP</font> 
    прибавляется непосредственное значение, чтобы убрать их (вместо выполнения 
    нескольких медленных инструкций <font color="#000099">POP</font>). Поэтому, 
    если функция случайно будет вызвана с неверным числом параметров, т.е. не 
    соответствующем прототипу, стек будет возвращен вызывающим кодом в то состояние, 
    в котором он находился до вызова этой функции, который <em>знает</em> сколько 
    параметров было помещено в стек, и удаляет их оттуда. 
</ul>

<p>Существует альтернативная конвенция вызова, используемая в <font color="#000099">Win32</font> 
  программах для вызовов через Windows API, а также для функций, вызываемых Windows 
  API, таких как оконные процедуры (window procedures): они описаны так, чтобы 
  использовать Microsoft <font color="#000099">__stdcal</font>l конвенцию. Это 
  очень похоже на конвенцию Паскаля, в вызываемой функции очищаются параметры 
  из стека, используя параметр с инструкцией <font color="#000099">RET</font>. 
  Однако, параметры также передаются справа налево. 
<p>Если вы определите функцию в стиле языка Си следующим образом:
<p><pre>
          global _myfunc 
_myfunc:  push ebp 
          mov ebp,esp 
          sub esp,0x40           ; 64 байта для локальных переменных
          mov ebx,[ebp+8]        ; Первый параметр функции
          ; еще какой-нибудь код 
          leave                  ; mov esp,ebp / pop ebp 
          ret
</pre>

<p>С другой стороны, чтобы вызывать Си-функцию из вашего
ассемблерного кода, вы должны сделать что-то вроде этого:

<p><pre>
          extern _printf 
          ; и затем... 
          push dword [myint]     ; одна из моих переменных целого типа 
          push dword mystring    ; указатель в моем сегменте данных
          call _printf 
          add esp,byte 8         ; `byte' уменьшит размер кода 
          ; и теперь объявления данных... 
          segment _DATA 
myint     dd 1234 
mystring  db 'Это число -&gt; %d &lt;- должно быть 1234',10,0
</pre>


<p>Этот фрагмент кода √ ассемблерный эквивалент Си-кода
<p><pre>
    int myint = 1234; 
    printf("Это число -&gt; %d &lt;- должно быть 1234\n", myint);
</pre>

<h4><a name="nasm_ru8_html_section_8_1_3">8.1.3 Доступ к переменным</a></h4>

<p>Чтобы получить доступ к Си-переменным, или чтобы объявить переменные, к которым 
  может обращаться Си, вам достаточно объявить имена как <font color="#000099">GLOBAL</font> 
  или <font color="#000099">EXTERN</font>. (Опять же, имена нужно предварять подчеркиванием, 
  как это описано в <a href="#nasm_ru8_html_section_8_1_1"> параграфе 8.1.1</a>.) Таким образом, 
  Си-переменные, объявленные как<font color="#000099"> int i </font>могут быть 
  доступны из ассемблера как 
<p><pre>
          extern _i 
          mov eax,[_i]
</pre>

<p>И чтобы объявить ваши собственные переменные, которые будут доступны Си-программе 
  как<font color="#000099"> int j</font>, делайте это так (проверьте, что вы ассемблируете 
  это в <font color="#000099">_DATA</font> сегменте, если это необходимо): 
<p><pre>
          global _j 
_j        dd 0
</pre>

<p>Чтобы обращаться с Си-массивами необходимо знать размер элементов этого массива. 
  Например, <font color="#000099">int</font> переменные имеют размер 4 байта, 
  поэтому если в Си-программе объявлен массив как <font color="#000099">int a[10]</font>, 
  можно обращаться к <font color="#000099">a[3]</font> так: <font color="#000099">mov 
  ax,[_a+12]</font>. ( Смещение 12 полчается в результате умножения номера в массиве, 
  3 на размер элемента массива, 4.) Размеры базовых типов в 32-х разрядных Си-компиляторах: 
  1 для <font color="#000099">char</font>, 2 для <font color="#000099">short</font>, 
  4 для <font color="#000099">int, long</font> и <font color="#000099">float</font>, 
  и 8 для <font color="#000099">double</font>. Указатель, содержащий 32-ух битный 
  адрес имеет также размер 4 байта. 
<p>Чтобы обращаться к структурам языка Си, необходимо знать смещение от базового 
  адреса структуры до интересующего вас поля. Вы можете просто это делать, конвертируя 
  определения Си-структур в определения структур NASM (<font color="#000099">STRUC</font>), 
  или вычисляя одно смещение и используя только его. 
<p>Чтобы делать это проще, вам необходимо причитать руководство по вашему компилятору 
  языка Си и найти как он организует структуры данных. NASM не делает специальных 
  выравниваний членов структуры в его макросе <font color="#000099">STRUC</font>, 
  поэтому вы должны указывать выравнивания самостоятельно, если Си-компилятор 
  генерирует их. Обычно вы можете обнаружить, что подобная структура 
<p><pre>
struct { 
    char c; 
    int i; 
} foo;
</pre>
<p>имеет размер не 5 байт, а 8, так как <font color="#000099">int</font> поле 
  будет выровнено на границу двойного слова. Однако, эту возможность иногда можно 
  настроить в Си-компиляторе, используя параметры командной строки или <font color="#000099">#pragma</font> 
  &#151; директивы, поэтому можно найти как ваш компилятор это делает. 
<h4><a name="nasm_ru8_html_section-8.1.4">8.1.4 c32.mac: Вспомогательные макросы для 32-ух битного 
  интерфейса с Си</a></h4>
<p>Файл макроса <font color="#000099">c32.mac</font> включен в архив NASM, в каталог 
  <font color="#000099">misc</font>. В этом файле определены 3 макроса: <font color="#000099">proc, 
  arg</font> и <font color="#000099">endproc</font>. Они введены для использования 
  в определении процедур в стиле Си, и она автоматизируют операции, необходимые 
  для соблюдения конвенции вызова. 
<p>Пример ассемблерной функции, использующей этот набор макросов приведен ниже: 
<p><pre>
          proc _proc32 
%$i       arg 
%$j       arg 
          mov eax,[ebp + %$i] 
          mov ebx,[ebp + %$j] 
          add eax,[ebx] 
          endproc
</pre>

<p>Этот фрагмент определяет<font color="#000099"> _proc32</font> как процедуру 
  с двумя аргументами, первый (<font color="#000099">i</font>) является <font color="#000099">integer</font> 
  и второй (<font color="#000099">j</font>) является указателем на <font color="#000099">integer</font>. 
  Процедура возвращяет<font color="#000099"> i + *j</font>. 
<p>Заметьте, что макрос <font color="#000099">arg</font> при его разворачивании 
  содержит в первой строке <font color="#000099">EQU</font>, которая в результате 
  определяет <font color="#000099">%$i</font> как смещение от <font color="#000099">BP</font>. 
  При этом используются контекстно-локальные переменные (локальные к контексту, 
  сохраняемому в контекстном стеке макросом <font color="#000099">proc</font> 
  и удаляемому оттуда макросом <font color="#000099">endproc</font>), поэтому 
  в других процедурах может быть использовано то же самое имя аргумента. Конечно, 
  вы можете этого <i>не делать</i>.
<p><font color="#000099">arg</font> можно передать необязательный параметр, указывающий 
  размер аргумента. Если размер не задан, он предполагается равным 4-ем, потому 
  что абсолютное большинство параметров функции будут типа <font color="#000099">int</font> 
  или указателями. 
<h3><a name="nasm_ru8_html_section-8.2">8.2 Написание разделяемых библиотек для NetBSD/FreeBSD/OpenBSD 
  и Linux/ELF</a></h3>

<p>ELF замещает старый объектный формат<font color="#000099"> a.out</font> для 
  Линукса, потому что он поддерживает перемещаемый код (position-independent code 
  &#151; PIC), который позволяет писать разделяемые библиотеки намного проще. 
  NASM поддерживает особености перемещаемого кода для <font color="#000099">ELF</font>, 
  поэтому вы можете писать разделяемый библиотеки для Линукс ELF на NASM. 
<p>NetBSD, и его близкие родственники FreeBSD и OpenBSD, используют другой подход, 
  добавив поддержку перемещаемого кода в формат <font color="#000099">a.out</font>. 
  NASM поддерживает это как формат <font color="#000099">aoutb</font> для скомпилированных 
  файлов, поэтому вы можете писать разделяемые библиотеки для BSD на NASM тоже. 
<p>Операционная система загружает разделяемую PIC (пермещаемый код) 
библиотеку, делая
отображение в память файла библиотеки в произвольно выбранное 
место в адресном пространстве выполняемого процесса. Поэтому содержимое
секции кода библиотеки должно не зависеть от места в памяти, куда она 
загружена.

<p>Поэтому, вы не можете обращаться к вашей переменной таким вот способом:
<p><pre>
          mov eax,[myvar]        ; ОШИБКА
</pre>

<p>Вместо этого, линковщик предоставляет область памяти, называемую <em>глобальной 
  таблицей смещений (global offset table)</em>, или просто ГТС (GOT); ГТС расположена 
  на постоянном расстоянии от кода вашей библиотеки, поэтому если вы сможете узнать 
  куда загружена ваша библиотека (что обычно осуществляется комбинацией <font color="#000099">CALL</font> 
  и <font color="#000099">POP</font>), вы сможете получить адрес ГТС, и затем 
  загрузить адрес вашей переменной из сгенерированной линковщиком записи в ГТС. 
<p>Секция <em>data</em> PIC (перемещяемый код) разделяемой библиотеки не имеет 
  подобных ограничений: поскольку секция данных доступна для записи, она может 
  быть скопирована в память каким бы то ни было образом, не только отображением 
  в страницы из файла библиотеки, поэтому как только она будет скопирована, она 
  может быть также перемещена. Поэтому вы можете обычный способ для доступа в 
  секции данных, особо не заботясь об этом (но посмотрите в <a href="#nasm_ru8_html_section_8_2_4">параграфе 
  8.2.4</a> предостережения). 
<h4><a name="nasm_ru8_html_section-8.2.1">8.2.1 Получение адреса ГТС</a></h4>

<p>Каждый фрагмент кода в вашей разделяемой библиотеке должен
определить ГТС как внешнее имя:

<p><pre>
          extern _GLOBAL_OFFSET_TABLE_   ; в ELF 
          extern __GLOBAL_OFFSET_TABLE_  ; в BSD a.out
</pre>

<p>В начале каждой функции вашей разделяемой библиотеки, которая собирается
обращаться к вашим секциям data или BSS, должен вычисляться адрес ГТС.
Это обычно осуществляется написанием функции в такой форме:

<p><pre>
func:     push ebp 
          mov ebp,esp 
          push ebx 
          call .get_GOT 
.get_GOT: pop ebx 
          add ebx,_GLOBAL_OFFSET_TABLE_+$$-.get_GOT wrt ..gotpc 
          ; Тело функции начинается отсюда 
          mov ebx,[ebp-4] 
          mov esp,ebp 
          pop ebp 
          ret
</pre>
<p>(Для BSD, снова, имя <font color="#000099">_GLOBAL_OFFSET_TABLE</font> нужно 
  предварить вторым знаком подчеркивания.) 
<p>Первые две сточки этой функции &#151; это просто стандартное начало для Си, 
  чтобы установить стековый кадр, и последние три строчки &#151; стандартное завершение 
  Си-функции. Третья строка, и с четвертой по последнюю сктроки, сохраняют и восстанавливают 
  регистр <font color="#000099">EBX</font>, потому что PIC (перемещаемый код) 
  разделяемая библиотека использует этот регистр для сохранения адреса ГТС. 
<p>Интересный фрагмент это инструкция <font color="#000099">CALL</font> и следующие 
  за ней две строки. Комбинация <font color="#000099">CALL</font> и <font color="#000099">POP</font> 
  получают адрес метки<font color="#000099"> .get_GOT</font>, без узнавания в 
  точности куда загружена программа (потому что инструкция <font color="#000099">CALL</font> 
  кодируется относительно текущей позиции). Инструкция <font color="#000099">ADD</font> 
  позволяет использовать специальный PIC (перемещаемый код) тип размещения: <font color="#000099">GOTPC</font> 
  размещение. Со спецификатором <font color="#000099">WRT ..gotpc</font> размещение 
  имен (здесь <font color="#000099">_GLOBAL_OFFSET_TABLE_</font>, специальное 
  имя, связанное с ГТС) дается как смещение от начала секции. (Вобще-то, ELF кодирует 
  это как смещение от поля операндов инстуркции <font color="#000099">ADD</font>, 
  но NASM нарочно это упрощает, поэтому этот метод подходит для обоих ELF и BSD.) 
  Таким образом, затем инструкция <em>добавляет</em> начало секции, чтобы получить 
  настоящий адрес ГТС, и вычитает значение <font color="#000099">.get_GOT</font> 
  которое находится в <font color="#000099">EBX</font>. Поэтому, в то время, когда 
  инструкция завершится, <font color="#000099">EBX</font> содержит адрес ГТС. 
<p>Если вы не следили за рассуждениями, не беспокойтесь:
никогда не приходится получать адрес ГТС другими способами,
поэтому вы можете поместить эти три инструкции в макрос и
не обращать на них внимания:
<p><pre>
%macro get_GOT 0 
          call %%getgot 
%%getgot: pop ebx 
          add ebx,_GLOBAL_OFFSET_TABLE_+$$-%%getgot wrt ..gotpc 
%endmacro
</pre>


<h4><a name="nasm_ru8_html_section-8.2.2">8.2.2 Нахождение ваших локальных переменных</a></h4>

<p>Имея ГТС, вы можете использовать ее для получения адресов ваших переменных. 
  Большинство переменных будут постоянно находится в секциях, которые вы объявили; 
  к ним можно получить доступ, используя <font color="#000099">..gotoff</font> 
  специальный тип <font color="#000099">WRT</font>. Вот как это работает: 
<p><pre>
          lea eax,[ebx+myvar wrt ..gotoff]
</pre>

<p>Выражение <font color="#000099">myvar wrt ..gotoff</font> вычисляется, затем 
  разделяемая библиотека линкуется, чтобы оно стало смещением локальной переменной 
  <font color="#000099">myvar</font> от начала ГТС Поэтому, прибавление его к 
  <font color="#000099">EBX</font>, как это показано выше, помещает настоящий 
  адрес <font color="#000099">myvar</font> в <font color="#000099">EAX</font>. 
<p>Если объявить переменные как <font color="#000099">GLOBAL</font> без указания 
  их размера, они разделяются между фрагментами кода в библиотеке, но не могут 
  быть экспортированы из библиотеки в программу, которая ее загрузила. Они будут 
  по прежнему в вашей обычных секциях <font color="#000099">data</font> и <font color="#000099">BSS</font>, 
  поэтому доступ к ним можно получить таким же методом, что и к локальным переменных, 
  используя описанный ранее механизм <font color="#000099">..gotoff</font>. 
<p>Обратите внимание, что из-за специфики в BSD <font color="#000099">a.out</font> 
  формата описатели этого перемещаемого типа, должно существовать хотя бы одно 
  нелокальное имя в той же секции, что и адрес, к которому вы обращаетесь. 
<h4><a name="nasm_ru8_html_section-8.2.3">8.2.3 Нахождение внешних и общих переменных</a></h4>

<p>Если вашей библиотеки требуется получить внешнюю переменную (внешнюю по отношению 
  к <em>library</em>, не только к одному модулю в ней), необходимо использовать 
  тип <font color="#000099">..got</font>, чтобы этого добиться. Тип <font color="#000099">..got</font>, 
  вместо того, чтобы давать смещение от базы ГТС до переменной, дает смещение 
  от базы ГТС до <em>элемента</em> ГТС, содержащего адрес переменной. Линковщик 
  настраивает этот элемент ГТС когда делает библиотеку, и динамический линковщик 
  помещает правильный адрес во время загрузки. Таким образом, чтобы получить адрес 
  внешней переменной <font color="#000099">extvar</font> в <font color="#000099">EAX</font>, 
  вам понадобиться написать: 
<p><pre>
          mov eax,[ebx+extvar wrt ..got]
</pre>

<p>Эта строчка загружает адрес <font color="#000099">extvar</font> из элемента 
  ГТС. Линковщик, когда он делает разделяемую библиотеку, собирает вместе все 
  перемещения типа<font color="#000099"> ..got</font>, и создает ГТС, поэтому 
  это обеспечивает существование каждого необходимого элемента. 
<p>Общие переменные должны использоваться таким же образом. 
<h4><a name="nasm_ru8_html_section-8.2.4">8.2.4 Экспортирование имен в библиотеку пользователя</a></h4>

<p>Чтобы экспортировать имена пользователю библиотеки, необходимо объявить являются 
  ли они функциями или данными, и если это данные, необходимо указать размер переменной. 
  Это нужно для того, чтобы динамический линковщик создает таблицу связей входов 
  процедур для каждой экспортированной функции, а также перемещает экспортированные 
  переменные из секции данных библиотеки в которой они были объявлены. 
<p>Таким образом, чтобы экспортировать функцию в библиотеку пользователя, 
необходимо использовать
<p><pre>
          global func:function   ; объявить это как функцию 
func:     push ebp 
          ; etc.
</pre>
<p>А чтобы экспортировать переменные, такие как массивы, понадобится
такой код
<p><pre>
          global array:data array.end-array ; и указать размер... 
array:    resd 128 
.end:
</pre>

<p>Будьте осторожны: если экспортировать переменную в библиотеку пользователя, 
  объявив ее как <font color="#000099">GLOBAL</font> и указать ее размер, переменная 
  окажется в сегменте данных главной программы, вместо сегмента данных вашей библиотеки, 
  в котором объявлена. Поэтому получать доступ к вашей глобальной переменной вам 
  нужно, используя механизм <font color="#000099">..got</font>, вместо<font color="#000099"> 
  ..gotoff</font>, как если бы она была внешней (которая, вобщем, таковой и стала). 
<p>В равной мере, если необходимо сохранить адрес экспортированной
глобальной переменной в вашем сегменте данных, вам ен удастся это
сделать стандартным образом:

<p><pre>
dataptr:  dd global_data_item    ; ОШИБКА
</pre>

<p>NASM интерпретирует этот код как обычное резервирование, в котором <font color="#000099">global_data_item</font> 
  просто смещение от начала сегмента <font color="#000099">.data</font> (или чего-то 
  другого); поэтому это определение будет указывать на ваш сегмент данных, вместо 
  экспортирования глобальной переменной, которая находится в другом месте. 
<p>Вместо вышеописанного кода, тогда, используйте 
<p><pre>
dataptr:  dd global_data_item wrt ..sym
</pre>

<p>что использует специальный тип <font color="#000099">WRT ..sym</font>, чтобы 
  указать NASM-у искать в таблице имен особое имя для этого объявления, место 
  простого определения относительно базы сегмента. 
<p>Тотже метод будет работать и для функций: объявление одной
из ваших функций следующим образом
<p><pre>
funcptr:  dd my_function
</pre>

<p>предоставит пользователю адрес вашего кода, тогда как

<p><pre>
funcptr:  dd my_function wrt ..sym
</pre>
<p>предоставит адрес процедуры сборки (линковки) таблицы для этой функции, который 
  вызывающая прогамма будет полагать как местоположение функции. Получение этого 
  адреса &#151; правильный способ вызова функции. 
<h4><a name="nasm_ru8_html_section-8.2.5">8.2.5 Вызов процедур вне библиотеки</a></h4>

<p>Вызов процедур извне вашей разделяемой библиотеки может быть
осуществлен через <em>таблицу сборки процедуры(procedure linkage table)</em>, 
или ТСП(PLT). ТСП помещается по известному смещению от того места, куда
загружена библиотека, поэтому библиотечный код может делать вызовы
к ТСП в переносимом (не зависимого от места) стиле. Внутри ТСП есть
код для перехода на смещения, расположенные в ГТС, поэтому вызовы
из функции к другим разделяемым библиотекам или к коду в главной программе
могут быть незаметно направлены на их реальные местоположения.
 
<p>Чтобы вызывать внешний код, необходимо использовать другой специальный PIC 
  (переносимый код) тип переноса, <font color="#000099">WRT ..plt</font>. Это 
  намного проще, чем использовать ГТС: просто замещается вызовы, например, такие 
  <font color="#000099">CALL printf </font>на версию, использующую ТСП &#151; 
  <font color="#000099">CALL printf WRT ..plt</font>. 
<h4><a name="nasm_ru8_html_section-8.2.6">8.2.6 Создание библиотечного файла</a></h4>

<p>Написав несколько модулей с кодом и ассемблировав их в <font color="#000099">.o</font> 
  файлы, вы создаете вашу разделяемую библиотеку командами наподобие таких: 
<p><pre>
ld -shared -o library.so module1.o module2.o       # for ELF 
ld -Bshareable -o library.so module1.o module2.o   # for BSD
</pre>

<p>Для ELF, если вашу разделяемую библиотеку предполагается использовать в системных 
  каталогах, таких как <font color="#000099">/usr/lib</font> или<font color="#000099"> 
  /lib</font>, это обычно делают, использую параметр <font color="#000099">-soname</font> 
  при сборке (линковке), чтобы сохранить конечный библиотечный файл с именем, 
  с номером версии в библиотеке: 
<p><pre>
ld -shared -soname library.so.1 -o library.so.1.2 *.o
</pre>
<p>А вы потом скопируете файл <font color="#000099">library.so.1.2</font> в библиотечный 
  каталог, и создадите символьную ссылку <font color="#000099">library.so.1</font> 
  к нему. 
<p align=center><a href="#nasm_ru9_html">Следующая глава</a> | <a href="#nasm_ru7_html">Предыдущая 
  глава</a> | <a href="#contents_html">Содержание</a>
<hr>

<a name="nasm_ru9_html"></a>
<h1 align=center>Расширенный Ассемблер: NASM</h1>

<p align=center><a href="#nasm_r10_html">Следующая глава</a> | <a href="#nasm_ru8_html">Предыдущая 
  глава</a> | <a href="#contents_html">Содержание</a> | Указатель</p> 
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr> 
    <td width="71%"> 
      <h2><a name="nasm_ru9_html_chapter-9">Глава 9: Смешивание 16- 
        и 32-битного кода.</a></h2>
    </td>
    <td width="29%"> 
      <div align="right"><font size="-1" color="#666666">Перевод: <a href="http://asmdev.narod.ru/asmos.html">AsmOS 
        group</a>, &copy; 2001</font></div>
    </td>
  </tr>
</table>
Эта глава повествует о некоторых проблемах, связанных с использованием необычных 
способов адресации и инструкций перехода, возникающих при написании кода операционных 
систем, таких мест как инициализация защищенного режима, которые требуют, чтобы 
код, который оперирует с сегментами смешанных адресаций, например, код из 16-битного 
сегмента пытается модифицировать данные в 32-битном, или инструкции перехода между 
сегментами разной разрядности. 
<h3><a name="nasm_ru9_html_section_9_1">9.1 Переходы между сегментами смешанной разрядности</a></h3>

<p>Наиболее распространенные формы инструкций смешанной разрядности 
встречаются при написании 32-битной ОС: как только закончился ваш код 
настройки в 16-битном режиме, например, загрузка ядра, вам придется 
запускать его, переключаясь в защищенный режим и прыгая в 32-битный 
сегмент на точку входя ядра. В полностью 32-биной ОС, есть 
потребность в использовании только инструкций смешанной разрядности, 
потому что любой код до ее создания может быть выполнен как 
чистый 16-битный, и все написанное для нее после, может быть 
чистым 32-битным.

<p>Пусть переход должен быть осуществлен по 48-битному дальнему адресу, так как 
  сегмент, в который происходит переход &#151; 32-битный. Однако, он должен быть 
  ассемблирован в 16-битном сегменте, поэтому, если мы для примера напишем, 
<pre>          jmp 0x1234:0x56789ABC  ; ошибка!</pre>

<p>то это будет неправильно работать, так как смещение будет обрезано до <font color="#000099">0x9ABC</font> 
  и переход окажется обычным 16-битным. 
<p>В коде инициализации ядра Линукса, из-за неспособности <font color="#000099">as86</font> 
  генерировать необходимые инструкции, их кодируют вручную, используя директиву 
  <font color="#000099">DB</font>. NASM способен сделать это лучше, он действительно 
  самостоятельно генерирует правильный код. Вот как это делается правильно: 
<pre>          jmp dword 0x1234:0x56789ABC  ; правильно</pre>
Префикс <font color="#000099">DWORD</font> (строго говоря, он должен следовать 
<I>после</I> двоеточия, так как это объявление размера двойного слова для смещения, 
но NASM поддерживает и такую форму записи, потому что обе они не двусмысленны) 
сообщает, что смещение должно рассматриваться как дальнее, в предположении, что 
вы умышленно совершаете переход их 16-битного сегмента в 32-битный. 
<p>Вы можете сделать обратное действие, делая переход из 32-битного сегмента в 
  16-битный, указав префикс <font color="#000099">WORD</font>: 
<p><pre>          jmp word 0x8765:0x4321 ; 32 to 16 bit</pre>
<p>Если префикс <font color="#000099">WORD</font> указан в 16-битном режиме, или 
  префикс <font color="#000099">DWORD</font> в 32-битном, они будут проигнорированы, 
  потому что они переводят NASM в режим, в котором он и так находится. 
<h3><a name="nasm_ru9_html_section-9.2">9.2 Адресация между сегментами различной разрядности</a></h3>

<p>Если ваша ОС является смесью 16 и 32-битной, или если вы пишете
расширитель ДОС, наверняка захотите использовать несколько 16-битных
и несколько 32-битных сегментов. Но с другой стороны, вам придется писать
код в 16-битном сегменте, который обращается к данным в 32-битном сегменте,
или наоборот.

<p>Если данные в 32-битном сегменте расположены в передлах первых 64К
сегмента, то к ним можно обращаться, используя обычные 16-битные операции,
но рано или поздно, вам понадобится совершать 32-битную адресацию
из 16-битного сегмента.

<p>Самый легкий путь сделать это, убедится, что вы используете
регистр для адреса, с этих пор каждый эффективный адрес, содержащийся
в 32-битном регистре принудительно будет 32-битным адресом.  Поэтому
вы можете сделать так
<p><pre>
          mov eax,offset_into_32_bit_segment_specified_by_fs 
          mov dword [fs:eax],0x11223344
</pre>

<p>Это хорошо, но немного громоздко (потому что мы проигрываем инструкцию и регистр) 
  если вам уже известно точное смещение. Архитектура <font color="#0000CC">x86</font> 
  поддерживает 32-битную эффективную адресацию, чтобы указать только 4-байтное 
  смещение, поэтому почему NASM не мог бы генерировать инструкцию лучше для этих 
  целей? 
<p>Он может. Как описано в <a href="#nasm_ru9_html_section_9_1">параграфе 9.1</a>, понадобится 
  только предварить адрес ключевым словом <font color="#000099">DWORD</font>, 
  и это будет 32-битным адресом: 
<p><pre>
          mov dword [fs:dword my_offset],0x11223344
</pre>
<p>Еще, как описано в <a href="#nasm_ru9_html_section_9_1">параграфе 9.1</a>, NASM не придирчив 
  к использованию префикса <font color="#000099">DWORD</font>, он может идти до 
  или после замещения сегмента, поэтому неплохо будет выглядеть код с этой инструкцией 
  вот так: 
<p><pre>
          mov dword [dword fs:my_offset],0x11223344
</pre>
<p>Не удивляйтесь, что префикс <font color="#000099">DWORD</font> <em>вне</em> 
  квадратных скобок, он контролирует размер данных, сохраняемых по этому адресу, 
  а один внутри квадратных скобок, который указывает на длину адреса. Последнее 
  можно очень просто продемонстрировать: 
<p><pre>
          mov word [dword 0x12345678],0x9ABC
</pre>

<p>Это объявление помещает 16 бит данных по адресу, указанному по 
32-битному смещению.

<p>Вы также можете указать префикс <font color="#000099">WORD</font> или <font color="#000099">DWORD</font> 
  месте с префиксом <font color="#000099">FAR</font> для косвенных дальних переходов 
  или вызовов. Например: 
<p><pre>
          call dword far [fs:word 0x4321]
</pre>

<p>Эта инструкция содержит адрес, указанный 16 битным смещением; она
загружает 48-битный дальний указатель из него (16-битного сегмента
и 32-битного смещения), и вызывает этот адрес.

<h3><a name="nasm_ru9_html_section-9.3">9.3 Другие инструкции смешанного размера</a></h3>

<p>Другой способ, который вы можете использовать для доступа к данным, является 
  применение инструкций для работы со строками (<font color="#000099">LODSx</font>, 
  <font color="#000099">STOSx</font> и так далее) или инструкции <font color="#000099">XLATB</font>. 
  Поскольку эти инструкции не имеют параметров, может показаться, что нет простого 
  способа заставить их работать с 32-битными адресами из 16-битного сегмента. 
<p>Как раз для этого и предназначены префиксы <font color="#000099">a16</font> 
  и <font color="#000099">a32</font> NASM-а. Если вы пишите <font color="#000099">LODSB</font> 
  в 16-битном сегменте, но предполагаете обращаться к строке из 32-битного сегмента, 
  загрузите адрес в <font color="#000099">ESI</font> и затем напишите 
<p><pre>
          a32 lodsb
</pre>
<p>Этот префикс даставит использовать 32-битную адресацию, это означает, что <font color="#000099">LODSB</font> 
  загружает из <font color="#000099">[DS:ESI]</font> вместо <font color="#000099">[DS:SI]</font>. 
  Чтобы получить доступ к строке в 16-битном сегменте из 32-битного, можно использовать 
  соответствующий префикс <font color="#000099">a16</font>. 
<p>Префиксы <font color="#000099">a16</font> и <font color="#000099">a32</font> 
  могут быть применимы к любой инструкции из таблицы инструкций NASM-а, но для 
  большинства из них создаются необходимые формы адресации и без них. Эти префиксы 
  необходимы только для инструкций с неявной адресацией: <font color="#000099">CMPSx</font> 
  (<a href="#nasm_rua_html_section_A_24">параграф A.24</a>), <font color="#000099">SCASx</font> 
  (<a href="#nasm_rua_html_section_A_229">параграф A.229</a>), <font color="#000099">LODSx</font> 
  (<a href="#nasm_rua_html_section_A_117">параграф A.117</a>), <font color="#000099">STOSx</font> 
  (<a href="#nasm_rua_html_section_A_243">параграф A.243</a>), <font color="#000099">MOVSx</font> 
  (<a href="#nasm_rua_html_section_A_137">параграф A.137</a>), <font color="#000099">INSx</font> 
  (<a href="#nasm_rua_html_section_A_98">параграф A.98</a>), <font color="#000099">OUTSx</font> 
  (<a href="#nasm_rua_html_section_A_149">параграф A.149</a>) и <font color="#000099">XLATB</font> 
  (<a href="#nasm_rua_html_section_A_269">параграф A.269</a>). Также, различные 
  инструкции <font color="#000099">push</font> и <font color="#000099">pop</font> 
  (<font color="#000099">PUSHA</font> и <font color="#000099">POPF</font> также 
  как и более частоиспользуемые <font color="#000099">PUSH</font> и <font color="#000066">POP</font>) 
  могут использоваться с префиксами <font color="#000099">a16</font> и <font color="#000099">a32</font> 
  для выбора <font color="#000099">SP</font> или <font color="#000099">ESP</font> 
  для использования в качестве указателя стека, в случае, если размер сегмента 
  стека имеет разрядность, отличную от кодового сегмента. 
<p><font color="#000099">PUSH</font> и <font color="#000099">POP</font>, когда 
  они используются с сегментными регистрами в 32-битном режиме, также имеют немного 
  необычное поведение, когда они помещают в стек и выталкивают из него 4 байта 
  за один раз, из них два верхних игнорируются и нижние два используются как значения 
  сегментых регистров, с которыми вызывались инструкции. Чтобы зафиксировать 16-битное 
  поведение инструкций <font color="#000099">push</font> и <font color="#000099">pop</font> 
  для операций с сегментными регистрами, вы можете использовать префикс размера 
  операнда <font color="#000099">o16</font>: 
<p><pre>
          o16 push ss 
          o16 push ds
</pre>
<p>Этот код сохраняет двойные слово стекового пространства, запихивая
два сегментных регистра в пространство, которое при нормальных 
обстоятельствах используется только под одну операцию помещения в стек.

<p>(Вы также можете использовать префикс <font color="#000099">o32</font> для 
  указания 32-битного поведения, когда вы в 16-битном режиме, но это оказывается 
  менее полезно.) 
<p align=center><a href="#nasm_r10_html">Следующая глава</a> | <a href="#nasm_ru8_html">Предыдущая 
  глава</a> | <a href="#contents_html">Содержание</a>
<hr>

<a name="contents_html"></a>
<h1 align=center>Расширенный ассемблер: NASM</h1>

<p><font face="Verdana, Arial, Helvetica" size="-1" color="#666666">Перевод: 
<a href="http://asmdev.narod.ru/asmos.html">AsmOs 
  group</a>, &copy; 2001 </font> 
<p>Данное руководство 
  описывает NASM, расширенный ассемблер, предназначенный для написания программ 
  процессоров серии Intel x86, способный в то же время работать на разных платформах. 
  </p>
<h3><a href="#nasm_ru1_html">Глава 1. Введение</a></h3>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td> 
      <p>&nbsp;</p>
    </td>
    <td width="96%"><a href="#nasm_ru1_html_section_1_1">1.1. 
      Что такое NASM?</a> </td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr>
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_ru1_html_section_1_1_1">1.1.1. 
      Зачем еще один ассемблер?</a><br>
      <a href="#nasm_ru1_html_section_1_1_2">1.1.2. Условия лицензирования</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr>
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru1_html_section_1_2">1.2. 
      Контакты</a><br>
      <a href="#nasm_ru1_html_section_1_3">1.3. Инсталляция</a> </td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_ru1_html_section_1_3_1">1.3.1. 
      Инсталляция NASM под MS-DOS или Windows</a><br>
      <a href="#nasm_ru1_html_section_1_3_2">1.3.2. Инсталляция NASM под Unix</a></td>
  </tr>
</table>
<h3><a href="#nasm_ru2_html">Глава 2. Запуск NASM</a> </h3>
<table width="95%" border="0" cellpadding="2" cellspacing="0">
  <tr> 
    <td> 
      <p>&nbsp;</p>
    </td>
    <td width="96%"><a href="#nasm_ru2_html_section_2_1">2.1. 
      Синтаксис командной строки NASM</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr>
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_ru2_html_section_2_1_1">2.1.1. 
      Ключ -o. Указание имени выходного файла</a><br>
      <a href="#nasm_ru2_html_section_2_1_2"> 2.1.2. Ключ -f. Указание формата выходного 
      файла</a><br>
      <a href="#nasm_ru2_html_section_2_1_3"> 2.1.3. Ключ -l. Генерация файла-листинга</a><br>
      <a href="#nasm_ru2_html_section_2_1_4"> 2.1.4. Ключ -E. Перенаправление ошибок 
      в файл</a><br>
      <a href="#nasm_ru2_html_section_2_1_5"> 2.1.5. Ключ -s. Перенаправление ошибок 
      в stdout</a><br>
      <a href="#nasm_ru2_html_section_2_1_6"> 2.1.6. Ключ -i. Каталоги поиска включаемых 
      файлов</a><br>
      <a href="#nasm_ru2_html_section_2_1_7"> 2.1.7. Ключ -p. Предварительно включаемые 
      файлы</a><br>
      <a href="#nasm_ru2_html_section_2_1_8"> 2.1.8. Ключ -d. Предопределенные макросы</a><br>
      <a href="#nasm_ru2_html_section_2_1_9"> 2.1.9. Ключ -u. Отмена определения 
      макроса</a><br>
      <a href="#nasm_ru2_html_section_2_1_10"> 2.1.10. Ключ -e. Только препроцессирование</a><br>
      <a href="#nasm_ru2_html_section_2_1_11"> 2.1.11. Ключ -a. Отключение препроцессора</a><br>
      <a href="#nasm_ru2_html_section_2_1_12"> 2.1.12. Ключ -w. Разрешение/Запрещение 
      предупреждений при ассемблировании</a><br>
      <a href="#nasm_ru2_html_section_2_1_13"> 2.1.13. Переменная окружения NASM</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr>
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru2_html_section_2_2">2.2. 
      Пользователям MASM: Отличия</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr>
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_ru2_html_section_2_2_1">2.2.1. 
      NASM чувствителен к регистру символов</a><br>
      <a href="#nasm_ru2_html_section_2_2_2"> 2.2.2. NASM требует квадратные скобки 
      для ссылок на память</a><br>
      <a href="#nasm_ru2_html_section_2_2_3"> 2.2.3. NASM не хранит типы переменных</a><br>
      <a href="#nasm_ru2_html_section_2_2_4"> 2.2.4. NASM не поддерживает ASSUME</a> 
      <br>
      <a href="#nasm_ru2_html_section_2_2_5">2.2.5. NASM не поддерживает модели 
      памяти</a><br>
      <a href="#nasm_ru2_html_section_2_2_6"> 2.2.6. Различия в обработке чисел 
      с плавающей точкой</a><br>
      <a href="#nasm_ru2_html_section_2_2_7"> 2.2.7. Прочие различия</a></td>
  </tr>
</table>
<h3><a href="#nasm_ru3_html">Глава 3. Язык NASM</a></h3>
<table width="95%" border="0" cellpadding="2" cellspacing="0">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru3_html_section_3_1">3.1. 
      Обзор ассемблерной строки NASM</a><br>
      <a href="#nasm_ru3_html_section_3_2"> 3.2. Псевдо-инструкции</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr>
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_ru3_html_section_3_2_1">3.2.1. 
      DB и его друзья: Объявление инициализированных данных</a><br>
      <a href="#nasm_ru3_html_section_3_2_2"> 3.2.2. RESB и его друзья: Объявление 
      не инициализированных данных</a><br>
      <a href="#nasm_ru3_html_section_3_2_3"> 3.2.3. INCBIN: Включение внешних бинарных 
      файлов</a><br>
      <a href="#nasm_ru3_html_section_3_2_4"> 3.2.4. EQU: Определение констант</a><br>
      <a href="#nasm_ru3_html_section_3_2_5"> 3.2.5. TIMES: Повторение инструкций 
      или данных</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr>
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru3_html_section_3_3">3.3. 
      Эффективные адреса</a><br>
      <a href="#nasm_ru3_html_section_3_4"> 3.4. Константы</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr>
    <td >&nbsp;</td>
    <td width="92%"><a href="#nasm_ru3_html_section_3_4_1">3.4.1. 
      Числовые константы</a><br>
      <a href="#nasm_ru3_html_section_3_4_2"> 3.4.2. Символьные константы</a><br>
      <a href="#nasm_ru3_html_section_3_4_3"> 3.4.3. Строковые константы</a><br>
      <a href="#nasm_ru3_html_section_3_4_4"> 3.4.4. Константы с плавающей точкой</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr>
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru3_html_section_3_5">3.5. 
      Выражения</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr>
    <td >&nbsp;</td>
    <td width="92%"><a href="#nasm_ru3_html_section_3_5_1">3.5.1. 
      |: Побитовый оператор ИЛИ</a><br>
      <a href="#nasm_ru3_html_section_3_5_2"> 3.5.2. ^: Побитовый оператор ИСКЛЮЧАЮЩЕЕ 
      ИЛИ</a><br>
      <a href="#nasm_ru3_html_section_3_5_3"> 3.5.3. &amp;: Побитовый оператор И</a><br>
      <a href="#nasm_ru3_html_section_3_5_4"> 3.5.4. &lt;&lt; и &gt;&gt;: Операторы 
      сдвига бит</a><br>
      <a href="#nasm_ru3_html_section_3_5_5"> 3.5.5. + и -: Операторы сложения и 
      вычитания</a><br>
      <a href="#nasm_ru3_html_section_3_5_6"> 3.5.6. *, /, //, % и %%: Умножение 
      и деление</a><br>
      <a href="#nasm_ru3_html_section_3_5_7"> 3.5.7. Унарные операторы: +, -, ~ 
      и SEG</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr>
    <td >&nbsp;</td>
    <td width="96%"><a href="#nasm_ru3_html_section_3_6">3.6. 
      SEG и WRT</a><br>
      <a href="#nasm_ru3_html_section_3_7"> 3.7. Критические выражения</a><br>
      <a href="#nasm_ru3_html_section_3_8"> 3.8. Локальные метки</a> </td>
  </tr>
</table>
<h3><a href="#nasm_ru4_html">Глава 4. Препроцессор NASM</a> </h3>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru4_html_section_4_1">4.1. 
      Однострочные макросы</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_ru4_html_section_4_1_1">4.1.1. 
      Обычный способ: %define</a><br>
      <a href="#nasm_ru4_html_section_4_1_2"> 4.1.2. Однострочные макросы раннего 
      связывания: %xdefine</a><br>
      <a href="#nasm_ru4_html_section_4_1_3"> 4.1.3. Отмена определения макроса: 
      %undef</a><br>
      <a href="#nasm_ru4_html_section_4_1_4"> 4.1.4. Переменные препроцессора: %assign</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru4_html_section_4_2">4.2. 
      Многострочные макросы: %macro</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_ru4_html_section_4_2_1">4.2.1. 
      Перегрузка многострочных макросов</a><br>
      <a href="#nasm_ru4_html_section_4_2_2"> 4.2.2. Локальные метки в макросах</a><br>
      <a href="#nasm_ru4_html_section_4_2_3"> 4.2.3. Поглощающие параметры макросов</a><br>
      <a href="#nasm_ru4_html_section_4_2_4"> 4.2.4. Параметры макросов по умолчанию</a><br>
      <a href="#nasm_ru4_html_section_4_2_5"> 4.2.5. %0: Счетчик параметров</a><br>
      <a href="#nasm_ru4_html_section_4_2_6"> 4.2.6. %rotate: "Вращение" параметров 
      макросов</a><br>
      <a href="#nasm_ru4_html_section_4_2_7"> 4.2.7. Объединение параметров макросов</a><br>
      <a href="#nasm_ru4_html_section_4_2_8"> 4.2.8. Коды условий в качестве параметров 
      макросов</a><br>
      <a href="#nasm_ru4_html_section_4_2_9"> 4.2.9. Подавление развертывания макросов 
      в листинге</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru4_html_section_4_3">4.3. 
      Условное ассемблирование</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_ru4_html_section_4_3_1">4.3.1. 
      %ifdef: Проверка присутствия однострочного макроса</a><br>
      <a href="#nasm_ru4_html_section_4_3_2"> 4.3.2. %ifctx: Проверка контекстного 
      стека</a><br>
      <a href="#nasm_ru4_html_section_4_3_3"> 4.3.3. %if: Проверка произвольных 
      числовых выражений</a><br>
      <a href="#nasm_ru4_html_section_4_3_4"> 4.3.4. %ifidn и %ifidni: Проверка 
      на идентичность текста</a><br>
      <a href="#nasm_ru4_html_section_4_3_5"> 4.3.5. %ifid, %ifnum, %ifstr: Проверка 
      типов символов</a><br>
      <a href="#nasm_ru4_html_section_4_3_6"> 4.3.6. %error: Сообщения об ошибках, 
      определяемые пользователем</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru4_html_section_4_4">4.4. 
      Циклы препроцессора: %rep</a><br>
      <a href="#nasm_ru4_html_section_4_5"> 4.5. Подключение других файлов</a><br>
      <a href="#nasm_ru4_html_section_4_6"> 4.6. Контекстный стек</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_ru4_html_section_4_6_1">4.6.1. 
      %push и %pop: Создание и удаление контекста</a><br>
      <a href="#nasm_ru4_html_section_4_6_2"> 4.6.2. Контектно-локальные метки</a><br>
      <a href="#nasm_ru4_html_section_4_6_3"> 4.6.3. Контекстно-локальные однострочные 
      макросы</a><br>
      <a href="#nasm_ru4_html_section_4_6_4"> 4.6.4. %repl: Переименование контекста</a><br>
      <a href="#nasm_ru4_html_section_4_6_5"> 4.6.5. Пример использования контекстного 
      стека: Блок IF</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru4_html_section_4_7">4.7. 
      Стандартные макросы</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_ru4_html_section_4_7_1">4.7.1. 
      __NASM_MAJOR__ и __NASM_MINOR__: Версия NASM</a><br>
      <a href="#nasm_ru4_html_section_4_7_2"> 4.7.2. __FILE__ и __LINE__: Имя файла 
      и номер строки</a><br>
      <a href="#nasm_ru4_html_section_4_7_3"> 4.7.3. STRUC и ENDSTRUC: Объявление 
      структурных типов данных</a><br>
      <a href="#nasm_ru4_html_section_4_7_4"> 4.7.4. ISTRUC, AT и IEND: Объявление 
      экземпляров структур</a><br>
      <a href="#nasm_ru4_html_section_4_7_5"> 4.7.5. ALIGN и ALIGNB: Выравнивание 
      данных</a> </td>
  </tr>
</table>
<h3><a href="#nasm_ru4_html_section_4_1_4"></a> <a href="#nasm_ru5_html">Глава 5. 
  Директивы ассемблера</a> </h3>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru5_html_section_5_1">5.1. 
      BITS: Указание разрядности выполняемого кода</a><br>
      <a href="#nasm_ru5_html_section_5_2"> 5.2. SECTION или SEGMENT: Изменение 
      и описание секций</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_ru5_html_section_5_2_1">5.2.1. 
      Макрос __SECT__</a> </td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru5_html_section_5_3">5.3. 
      ABSOLUTE: Определение абсолютных меток</a><br>
      <a href="#nasm_ru5_html_section_5_4"> 5.4. EXTERN: Импорт символов из других 
      модулей</a><br>
      <a href="#nasm_ru5_html_section_5_5"> 5.5. GLOBAL: Экспорт символов в другие 
      модули</a><br>
      <a href="#nasm_ru5_html_section_5_6"> 5.6. COMMON: Определение общих данных</a> 
      </td>
  </tr>
</table>
<h3><a href="#nasm_ru6_html">Глава 6. Выходные форматы</a> </h3>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru6_html_section_6_1">6.1. 
      bin: Плоский бинарный формат</a> </td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_ru6_html_section_6_1_1">6.1.1. 
      ORG: Начало бинарного файла</a><br>
      <a href="#nasm_ru6_html_section_6_1_2"> 6.1.2. bin-расширение директивы SECTION 
      </a> </td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru6_html_section_6_2">6.2. 
      obj: Объектные файлы OMF Microsoft</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_ru6_html_section_6_2_1">6.2.1. 
      obj-расширения директивы SEGMENT </a><br>
      <a href="#nasm_ru6_html_section_6_2_2"> 6.2.2. GROUP: Определение групп сегментов</a><br>
      <a href="#nasm_ru6_html_section_6_2_3"> 6.2.3. UPPERCASE: Отключение чувствительности 
      к регистру</a><br>
      <a href="#nasm_ru6_html_section_6_2_4"> 6.2.4. IMPORT: Импортирование символов 
      из DLL</a><br>
      <a href="#nasm_ru6_html_section_6_2_5"> 6.2.5. EXPORT: Экспортирование символов 
      в DLL</a><br>
      <a href="#nasm_ru6_html_section_6_2_6"> 6.2.6. ..start: Определение точки 
      входа в программу</a><br>
      <a href="#nasm_ru6_html_section_6_2_7"> 6.2.7. obj-расширения директивы EXTERN 
      </a><br>
      <a href="#nasm_ru6_html_section_6_2_8"> 6.2.8. obj-расширения директивы COMMON 
      </a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru6_html_section_6_3">6.3. 
      win32: Объектные файлы Win32 Майкрософт</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_ru6_html_section_6_3_1">6.3.1. 
      win32-расширения директивы SECTION </a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru6_html_section_6_4">6.4. 
      coff: Общий формат объектных файлов</a><br>
      <a href="#nasm_ru6_html_section_6_5"> 6.5. elf: Объектные файлы ELF Линукс</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_ru6_html_section_6_5_1">6.5.1. 
      elf-расширения директивы SECTION </a><br>
      <a href="#nasm_ru6_html_section_6_5_2"> 6.5.2. Позиционно-независимый код: 
      Специальные символы формата elf и WRT</a><br>
      <a href="#nasm_ru6_html_section_6_5_3"> 6.5.3. elf-расширения директивы GLOBAL 
      </a><br>
      <a href="#nasm_ru6_html_section_6_5_4"> 6.5.4. elf-расширение директивы COMMON</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru6_html_section_6_6">6.6. 
      aout: Объектные файлы a.out Линукс</a><br>
      <a href="#nasm_ru6_html_section_6_7"> 6.7. aoutb: Объектные файлы a.out NetBSD/FreeBSD/OpenBSD</a><br>
      <a href="#nasm_ru6_html_section_6_8"> 6.8. as86: Объектные файлы as86 Линукс</a><br>
      <a href="#nasm_ru6_html_section_6_9"> 6.9. rdf: Перемещаемые динамические 
      объектные файлы</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_ru6_html_section_6_9_1">6.9.1. 
      Требование библиотеки: Директива LIBRARY</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru6_html_section_6_10">6.10. 
      dbg: Формат для отладки</a></td>
  </tr>
</table>
<h3><a href="#nasm_ru7_html">Глава 7. Написание 16-битного кода (DOS, Windows 3/3.1)</a> 
</h3>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru7_html_section_7_1">7.1. 
      Получение .EXE файлов</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_ru7_html_section_7_1_1">7.1.1. 
      Использование формата obj для получения .EXE файлов</a><br>
      <a href="#nasm_ru7_html_section_7_1_2"> 7.1.2. Использование формата bin для 
      получения .EXE файлов</a> </td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru7_html_section_7_2">7.2. 
      Получение .COM файлов</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_ru7_html_section_7_2_1">7.2.1. 
      Использование формата bin для получения .COM файлов</a><br>
      <a href="#nasm_ru7_html_section_7_2_2"> 7.2.2. Использование формата obj для 
      получения .COM файлов</a> </td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru7_html_section_7_3">7.3. 
      Получение .SYS файлов</a><br>
      <a href="#nasm_ru7_html_section_7_4"> 7.4. Взаимодействие с 16-битными C-программами</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_ru7_html_section_7_4_1">7.4.1. 
      Внешние символьные имена</a><br>
      <a href="#nasm_ru7_html_section_7_4_2"> 7.4.2. Модели памяти</a><br>
      <a href="#nasm_ru7_html_section_7_4_3"> 7.4.3. Определения и вызовы функций</a><br>
      <a href="#nasm_ru7_html_section_7_4_4"> 7.4.4. Доступ к элементам данных</a><br>
      <a href="#nasm_ru7_html_section_7_4_5"> 7.4.5. c16.mac: Макросы для 16-битного 
      C-интерфейса</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru7_html_section_7_5">7.5. 
      Взаимодействие с программами Borland Pascal</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_ru7_html_section_7_5_1">7.5.1. 
      Соглашение о вызовах в Pascal</a><br>
      <a href="#nasm_ru7_html_section_7_5_2"> 7.5.2. Ограничение имен сегментов 
      в Borland Pascal</a><br>
      <a href="#nasm_ru7_html_section_7_5_3"> 7.5.3. Использование c16.mac с Pascal-программами</a></td>
  </tr>
</table>
<h3><a href="#nasm_ru8_html">Глава 8. Написание 32-битного кода (Unix, Win32, DJGPP)</a> 
</h3>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru8_html_section_8_1">8.1. Интерфейс с 32-ух 
      битными программами на Си</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_ru8_html_section_8_1_1">8.1.1. 
      </a><a href="#nasm_ru7_html_section_7_4_1">Внешние 
      символьные имена</a><br>
      <a href="#nasm_ru8_html_section_8_1_2"> 8.1.2. </a><a href="#nasm_ru7_html_section_7_4_3">Определение 
      и вызов функций</a><br>
      <a href="#nasm_ru8_html_section_8_1_3"> 8.1.3. </a><a href="#nasm_ru7_html_section_7_4_4">Доступ 
      к переменным</a><br>
      <a href="#nasm_ru8_html_section_8_1_4"> 8.1.4. c32.mac: </a><a href="#nasm_ru7_html_section_7_4_5">Вспомогательные 
      макросы для 32-ух битного интерфейса с Си</a> </td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru8_html_section_8_2">8.2. Написание разделяемых 
      библиотек для NetBSD/FreeBSD/OpenBSD и Linux/ELF</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_ru8_html_section_8_2_1">8.2.1. Получение адреса 
      ГТС</a><br>
      <a href="#nasm_ru8_html_section_8_2_2"> 8.2.2. Нахождение ваших локальных 
      переменных </a><br>
      <a href="#nasm_ru8_html_section_8_2_3"> 8.2.3. Нахождение внешних и общих 
      переменных </a><br>
      <a href="#nasm_ru8_html_section_8_2_4"> 8.2.4. Экспортирование имен в библиотеку 
      пользователя </a><br>
      <a href="#nasm_ru8_html_section_8_2_5"> 8.2.5. Вызов процедур вне библиотеки</a><br>
      <a href="#nasm_ru8_html_section_8_2_6"> 8.2.6. Создание библиотечного файла</a></td>
  </tr>
</table>
<h3><a href="#nasm_ru9_html">Глава 9. Смешивание16- и 32-битного кода</a> </h3>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_ru9_html_section_9_1">9.1. Переходы между сегментами 
      смешанной разрядности</a><br>
      <a href="#nasm_ru9_html_section_9_2"> 9.2. Адресация между сегментами различной 
      разрядности </a><br>
      <a href="#nasm_ru9_html_section_9_3"> 9.3. Другие инструкции смешанного размера</a> 
    </td>
  </tr>
</table>
<h3><a href="#nasm_r1010_html">Глава 10. Разрешение проблем</a> </h3>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_r1010_html_section_10_1">10.1. 
      Общие проблемы</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="92%"><a href="#nasm_r1010_html_section_10_1_1">10.1.1. Генерация NASM 
      неэффективного кода</a><br>
      <a href="#nasm_r1010_html_section_10_1_2"> 10.1.2. Мои &quot;JUMPы&quot; вне 
      диапазона </a><br>
      <a href="#nasm_r1010_html_section_10_1_3"> 10.1.3. ORG не работает</a><br>
      <a href="#nasm_r1010_html_section_10_1_4"> 10.1.4. TIMES не работает</a></td>
  </tr>
</table>
<table width="95%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td>&nbsp;</td>
    <td width="96%"><a href="#nasm_r1010_html_section_10_2">10.2. Дефекты (Ошибки)</a></td>
  </tr>
</table>
<h3> Указатель </h3>
<hr>

<a name="nasm_ru5_html"></a>
<h1 align=center>Расширенный ассемблер: NASM</h1>

<p align=center><a href="#nasm_ru6_html">Следующая глава</a> | <a href="#nasm_ru4_html">Предыдущая 
  глава </a> | <a href="#contents_html">Содержание</a> | Указатель</p>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr> 
    <td width="60%"> 
      <h2><a name="nasm_ru5_html_chapter-5">Глава 5: Директивы ассемблера</a></h2>
    </td>
    <td> 
      <div align="right"><font size="-1" color="#666666">Перевод: <a href="http://asmdev.narod.ru/asmos.html">AsmOS 
        group</a>, &copy; 2001</font></div>
    </td>
  </tr>
</table>
Хотя NASM и пытается избежать бюрократизм ассемблеров наподобие MASM и TASM, 
  он вынужден поддерживать <i>несколько</i> директив. Все они описаны в этой главе. 
<p>Существует два типа директив NASM: <i>пользовательские</i> и <i>примитивные</i>. 
  Обычно каждая директива имеет как пользовательскую, так и примитивную форму. 
  В большинстве случаев рекомендуется использовать пользовательскую форму директив, 
  которая реализована как макрос, вызывающий примитивные формы. Примитивные директивы 
  заключаются в квадратные скобки; для пользовательских директив этого не требуется. 
<p>В дополнение к описанным в этой главе универсальным директивам каждый объектный 
  формат может опционально предоставлять дополнительные директивы, служащие для 
  управления особенностями этого формата. Такие дополнительные директивы описываются 
  далее в главе, посвященной выходным форматам файлов (<a href="#nasm_ru6_html">глава 
  6</a>). 
<h3><a name="nasm_ru5_html_section-5.1">5.1 <font color="#000099">BITS</font>: </a>Указание 
  разрядности выполняемого кода</h3>
<p>Директива <font color="#000099">BITS</font> указывает, код какой разрядности 
  должен генерировать NASM: для процессора, работающего в 16-битном режиме, или 
  для процессора в 32-битном режиме. Соответствующим синтаксисом будет <font color="#000099">BITS 
  16</font> или <font color="#000099">BITS 32</font>. 
<p>В большинстве случаев вам не потребуется использовать <font color="#000099">BITS</font> 
  явно. Объектные форматы <font color="#000099">aout, coff, elf</font> и <font color="#000099">win32</font>, 
  разработанные для 32-битных операционных систем, вынуждают NASM выбирать 32-битный 
  режим по умолчанию. Объектный формат <font color="#000099">obj</font> позволяет 
  вам описывать каждый сегмент как <font color="#000099">USE16</font> или <font color="#000099">USE32</font>, 
  поэтому NASM будет соответственно настраивать режим работы и здесь использование 
  директивы <font color="#000099">BITS</font> также не требуется. 
<p>Наиболее вероятным использование директивы <font color="#000099">BITS</font> 
  представляется при написании 32-битного плоского бинарного файла. (Выходной 
  формат <font color="#000099">bin</font> по умолчанию предназначен для 16-битного 
  режима, т.к. он наиболее часто используется для написания DOS <font color="#000099">.COM</font> 
  программ, DOS <font color="#000099">.SYS</font> драйверов устройств, а также 
  загрузчиков). 
<p><i>Не нужно</i> задавать <font color="#000099">BITS 32</font> для использования 
  32-битных инструкций в 16-битных DOS-программах; если вы это сделаете, ассемблер 
  сгенерирует некорректный код, так как он получится 32-битным и на 16-битных 
  платформах будет не работоспособен. 
<p>Когда NASM находится в состоянии <font color="#000099">BITS 16</font>, инструкции, 
  использующие 32-битные данные, префиксируются байтом 0х66, а 32-битные адреса 
  √ байтом 0х67. В состоянии <font color="#000099">BITS 32</font> справедливо 
  обратное: 32-битные инструкции не нуждаются в префиксе, инструкции, использующие 
  16-битные данные, префиксируются байтом 0х66, а 16-битные адреса √ байтом 0х67. 
<p>Директива <font color="#000099">BITS</font> имеет абсолютно эквивалентные примитивные 
  формы: <font color="#000099">[BITS 16]</font> и <font color="#000099">[BITS 
  32]</font>. Пользовательская форма инструкции является макросом, который не 
  делает ничего, кроме как вызывает соответствующую примитивную форму. 
<h3><a name="nasm_ru5_html_section-5.2">5.2 <font color="#000099">SECTION</font> или <font color="#000099">SEGMENT</font>: 
  Описание и изменение секций</a></h3>
<p>Директива <font color="#000099">SECTION</font> (<font color="#000099">SEGMENT</font> 
  &#151; это абсолютно эквивалентный синоним) указывает, в какую секцию выходного 
  файла будет ассемблирован код, который вы пишете. В некоторых объектных форматах 
  количество и имена секций фиксированы; в других пользователь может сделать их 
  столько, сколько захочет. Поэтому если вы захотите переключиться на секцию, 
  которая в данный момент не существует, директива <font color="#000099">SECTION</font> 
  может либо вызвать сообщение об ошибке, либо создать новую секцию. 
<p>Объектные форматы Unix и <font color="#000099">bin</font> поддерживают стандартизованные 
  имена секций: <font color="#000099">.text</font> &#151; для кода, <font color="#000099">.data</font> 
  &#151; для данных и <font color="#000099">.bss</font> &#151; для неинициализированных 
  данных. Формат <font color="#000099">obj</font> наоборот, не признает эти имена 
  секций специальными и более того, удаляет ведущую точку в имени любой секции. 
<h4><a name="nasm_ru5_html_section-5.2.1">5.2.1 Макрос <font color="#000099">__SECT__</font> 
  </a></h4>
<p>Директива <font color="#000099">SECTION</font> необычна тем, что ее пользовательская 
  форма функционально отличается от примитивной. Примитивная форма <font color="#000099">[SECTION 
  xyz]</font> просто переключает текущую секцию на указанную. Пользовательская 
  форма <font color="#000099">SECTION xyz</font> сначала определяет однострочный 
  макрос <font color="#000099">__SECT__</font> для примитивной директивы <font color="#000099">[SECTION]</font>, 
  которую собирается выдать, и затем выдает ее. Таким образом, пользовательская 
  директива 
<p><pre>
          SECTION .text
</pre>
<p>развернется в две строки: 
<p><pre>
%define __SECT__ [SECTION .text] 
          [SECTION .text]
</pre>
<p>Пользователи могут использовать это в своих собственных макросах. Например, 
  макрос <font color="#000099">writefile</font>, описанный в <a href="#nasm_ru4_html_section_4_2_3">параграфе 
  4.2.3</a>, может быть с успехом переписан в следующей, более изощренной форме: 
<p><pre>
%macro writefile 2+ 
          [section .data] 
%%str:    db %2 
%%endstr: 
          __SECT__ 
          mov dx,%%str 
          mov cx,%%endstr-%%str 
          mov bx,%1 
          mov ah,0x40 
          int 0x21 
%endmacro
</pre>
<p>Данная форма макроса, записывающего строку в файл, сначала временно переключается 
  на секцию данных, используя при этом примитивную форму директивы <font color="#000099">SECTION</font>, 
  не модифицирующую<font color="#000099"> __SECT__</font>. Далее в секции данных 
  объявляется строка и затем вызывается <font color="#000099">__SECT__</font>, 
  переключающий контекст на любую секцию, в которой пользователь работал до этого. 
  Это исключает необходимость использования инструкции <font color="#000099">JMP</font> 
  (как в предыдущей версии макроса) для "перескакивания" данных, а также предотвращает 
  возникновение ошибок в модуле <font color="#000099">OBJ</font> формата, где 
  пользователь потенциально может использовать различные секции кода. 
<h3><a name="nasm_ru5_html_section-5.3">5.3 <font color="#000099">ABSOLUTE</font>: Определение 
  абсолютных меток</a></h3>
<p>О директиве <font color="#000099">ABSOLUTE</font> можно думать как об альтернативной 
  форме <font color="#000099">SECTION</font>: она направляет последующий код не 
  в физическую секцию, а в гипотетическую, начинающуюся с указанного абсолютного 
  адреса. В данном режиме вы можете использовать только инструкции семейства <font color="#000099">RESB</font>. 
<p><font color="#000099">ABSOLUTE</font> используется следующим образом: 
<p><pre>
          absolute 0x1A 
kbuf_chr  resw 1 
kbuf_free resw 1 
kbuf      resw 16
</pre>
<p>В данном примере область данных PC BIOS описана как сегмент, начинающийся с 
  адреса 0х1А: приведенный выше код определяет <font color="#000099">kbuf_chr</font> 
  по адресу <font color="#000099">0x1A</font>, <font color="#000099">kbuf_free</font> 
  по адресу <font color="#000099">0x1C</font> и <font color="#000099">kbuf</font> 
  по адресу <font color="#000099">0x1E</font>. 
<p>Пользовательская форма <font color="#000099">ABSOLUTE</font>, так же, как и 
  <font color="#000099">SECTION</font>, переопределяет макрос <font color="#000099">__SECT__</font> 
  в месте своего вызова. Директивы <font color="#000099">STRUC</font> и <font color="#000099">ENDSTRUC</font> 
  определены как макросы, использующие директиву <font color="#000099">ABSOLUTE</font> 
  (и соответственно,<font color="#000099"> __SECT__</font>). 
<p>ABSOLUTE в качестве аргумента принимает не только абсолютные константы: это 
  может быть выражение (на самом деле критическое выражение: см. <a href="#nasm_ru3_html_section_3_7">параграф 
  3.7</a>), а также какое-то значение в сегменте. Например, TSR может реутилизировать 
  свой настроечный код в качестве run-time BSS следующим образом: 
<p>
<pre>          org 100h               ; это .COM - программа 
          jmp setup              ; код setup идет последним 
          ; здесь расположена резидентная часть TSR 
setup:    ; теперь идет код, инсталлирующий TSR 
          absolute setup 
runtimevar1 resw 1 
runtimevar2 resd 20 
tsr_end:
</pre>
<p>Здесь определяется несколько переменных "на верхушке" setup-кода, так что после 
  завершения его работы это пространство может быть реутилизировано как хранилище 
  данных для работающей TSR. Символ '<font color="#000099">tsr_end</font>' может 
  быть использован для расчета общего размера резидентной части TSR. 
<h3><a name="nasm_ru5_html_section-5.4">5.4 <font color="#000099">EXTERN</font>: Импорт символов 
  из других модулей</a></h3>
<p>Директива <font color="#000099">EXTERN</font> подобна директиве MASM <font color="#000099">EXTRN</font> 
  и ключевому слову <font color="#000099">extern</font> в С: она используется 
  для объявления символа, который определен в некотором другом модуле. Не все 
  объектные форматы поддерживают внешние переменные: формат <font color="#000099">bin</font> 
  этого не может. 
<p>Директива <font color="#000099">EXTERN</font> принимает столько аргументов, 
  сколько вам необходимо. Каждый аргумент является именем символа: 
<p><pre>
          extern _printf 
          extern _sscanf,_fscanf
</pre>
<p>Некоторые объектные форматы обеспечивают дополнительные возможности директивы 
  <font color="#000099">EXTERN</font>. В любом случае, дополнительный синтаксис 
  отделяется от имени символа двоеточием. Например, формат <font color="#000099">obj</font> 
  при помощи следующей директивы позволяет вам объявить, что базой сегмента внешних 
  символов по умолчанию должна быть группа <font color="#000099">dgroup</font>: 
<p><pre>
          extern _variable:wrt dgroup
</pre>
<p>Примитивная форма <font color="#000099">EXTERN</font> отличается от пользовательской 
  тем, что одновременно может принять только один аргумент: поддержка списка аргументов 
  реализуется на уровне препроцессора. 
<p>Вы можете объявить одну и ту же переменную как <font color="#000099">EXTERN</font> 
  более одного раза: NASM спокойно проигнорирует второе и последующие переопределения. 
<h3><a name="nasm_ru5_html_section-5.5">5.5 <font color="#000099">GLOBAL</font>: Экспорт символов 
  в другие модули</a></h3>
<p>Директива <font color="#000099">GLOBAL</font> &#151; это обратная сторона <font color="#000099">EXTERN</font>: 
  если один модуль объявляет символ как <font color="#000099">EXTERN</font> и 
  ссылается на него, то для предотвращения ошибок компоновщика необходимо, чтобы 
  некоторый другой модуль <i>определил</i> этот символ и объявил его как <font color="#000099">GLOBAL</font>. 
  Некоторые ассемблеры для этой цели используют директиву <font color="#000099">PUBLIC</font>. 
<p>Директива <font color="#000099">GLOBAL</font>, применяемая к символу, должна 
  появляться перед определением этого символа. Она использует тот же самый синтаксис, 
  что и <font color="#000099">EXTERN</font>, за исключением того, что ссылается 
  на символ, определяемый в этом же модуле. Например: 
<p>
<pre>
          global _main 
_main:    ; некоторый код
</pre>
<p><font color="#000099">GLOBAL</font>, как и <font color="#000099">EXTERN</font>, 
  позволяет вводить после двоеточия специфичный синтаксис объектных форматов. 
  К примеру объектный формат <font color="#000099">elf</font> позволяет вам указать, 
  чем являются глобальные символы: функциями или данными: 
<p><pre>
          global hashlookup:function, hashtable:data
</pre>
<p>Как и в случае <font color="#000099">EXTERN</font>, примитивная форма <font color="#000099">GLOBAL</font> 
  отличается от пользовательской восприятием одновременно только одного аргумента. 
<h3><a name="nasm_ru5_html_section-5.6">5.6 <font color="#000099">COMMON</font>: Определение 
  общих данных</a></h3>
<p>Директива <font color="#000099">COMMON</font> используется для объявления <i>общих 
  переменных</i>. Общая переменная &#151; это глобальная переменная, объявленная 
  в секции неинициализированных данных, поэтому 
<p><pre>
          common intvar 4
</pre>
<p>работает так же, как и 
<p><pre>
          global intvar 
          section .bss 
intvar    resd 1
</pre>
<p>Отличие состоит в том, что если одна и та же переменная определена в разных 
  модулях, во время связывания (сборки) эти переменные будут <i>объединены</i> 
  и ссылки на <font color="#000099">intvar</font> во всех модулях будут указывать 
  на одно и то же место в памяти. 
<p>Директива <font color="#000099">COMMON</font>, так же как <font color="#000099">GLOBAL</font> 
  и <font color="#000099">EXTERN</font>, поддерживает специфичный синтаксис объектных 
  форматов. Например, формат <font color="#000099">obj</font> позволяет общим 
  переменным быть близкими (near) или дальними (far), а формат <font color="#000099">elf</font> 
  &#151; задать их выравнивание: 
<p>
<pre>          common commvar 4:near  ; работает в OBJ 
          common intarray 100:4  ; работает в ELF: выравнивание про 4-байтной границе
</pre>
<p>И наконец, примитивная форма <font color="#000099">COMMON</font>, как и в случае 
  <font color="#000099">EXTERN</font> и <font color="#000099">GLOBAL</font>, отличается 
  от пользовательской тем, что одновременно принимает только один аргумент. 
<p align=center><a href="#nasm_ru6_html">Следующая глава</a> | <a href="#nasm_ru4_html">Предыдущая 
  глава </a> | <a href="#contents_html">Содержание</a>
<hr>

<!--#include virtual="/footer.raw"-->

</body></html>