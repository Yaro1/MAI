<html><head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r"><title>Руководство по NASM</title>

<META NAME="GENERATOR" CONTENT="Super-Puper-Mega-Proga"></head>
<body bgcolor="#DDE1C2"><b><a href="http://www.opennet.ru/docs/">Архив документации OpenNet.ru</a> / 
Раздел "<a href="http://www.opennet.ru/docs/124.shtml">Программирование, языки</a>" /
<a href="index.html">Индекс</a>
</b>
<hr noshade size=1>

<h1 align=center>Расширенный ассемблер: NASM</h1>

<p align=center><a href="nasm_ru6.html">Следующая глава</a> | <a href="nasm_ru4.html">Предыдущая 
  глава </a> | <a href="contents.html">Содержание</a> | Указатель</p>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr> 
    <td width="60%"> 
      <h2><a name="chapter-5">Глава 5: Директивы ассемблера</a></h2>
    </td>
    <td> 
      <div align="right"><font size="-1" color="#666666">Перевод: <a href="http://asmdev.narod.ru/asmos.html">AsmOS 
        group</a>, &copy; 2001</font></div>
    </td>
  </tr>
</table>
Хотя NASM и пытается избежать бюрократизм ассемблеров наподобие MASM и TASM, 
  он вынужден поддерживать <i>несколько</i> директив. Все они описаны в этой главе. 
<p>Существует два типа директив NASM: <i>пользовательские</i> и <i>примитивные</i>. 
  Обычно каждая директива имеет как пользовательскую, так и примитивную форму. 
  В большинстве случаев рекомендуется использовать пользовательскую форму директив, 
  которая реализована как макрос, вызывающий примитивные формы. Примитивные директивы 
  заключаются в квадратные скобки; для пользовательских директив этого не требуется. 
<p>В дополнение к описанным в этой главе универсальным директивам каждый объектный 
  формат может опционально предоставлять дополнительные директивы, служащие для 
  управления особенностями этого формата. Такие дополнительные директивы описываются 
  далее в главе, посвященной выходным форматам файлов (<a href="nasm_ru6.html">глава 
  6</a>). 
<h3><a name="section-5.1">5.1 <font color="#000099">BITS</font>: </a>Указание 
  разрядности выполняемого кода</h3>
<p>Директива <font color="#000099">BITS</font> указывает, код какой разрядности 
  должен генерировать NASM: для процессора, работающего в 16-битном режиме, или 
  для процессора в 32-битном режиме. Соответствующим синтаксисом будет <font color="#000099">BITS 
  16</font> или <font color="#000099">BITS 32</font>. 
<p>В большинстве случаев вам не потребуется использовать <font color="#000099">BITS</font> 
  явно. Объектные форматы <font color="#000099">aout, coff, elf</font> и <font color="#000099">win32</font>, 
  разработанные для 32-битных операционных систем, вынуждают NASM выбирать 32-битный 
  режим по умолчанию. Объектный формат <font color="#000099">obj</font> позволяет 
  вам описывать каждый сегмент как <font color="#000099">USE16</font> или <font color="#000099">USE32</font>, 
  поэтому NASM будет соответственно настраивать режим работы и здесь использование 
  директивы <font color="#000099">BITS</font> также не требуется. 
<p>Наиболее вероятным использование директивы <font color="#000099">BITS</font> 
  представляется при написании 32-битного плоского бинарного файла. (Выходной 
  формат <font color="#000099">bin</font> по умолчанию предназначен для 16-битного 
  режима, т.к. он наиболее часто используется для написания DOS <font color="#000099">.COM</font> 
  программ, DOS <font color="#000099">.SYS</font> драйверов устройств, а также 
  загрузчиков). 
<p><i>Не нужно</i> задавать <font color="#000099">BITS 32</font> для использования 
  32-битных инструкций в 16-битных DOS-программах; если вы это сделаете, ассемблер 
  сгенерирует некорректный код, так как он получится 32-битным и на 16-битных 
  платформах будет не работоспособен. 
<p>Когда NASM находится в состоянии <font color="#000099">BITS 16</font>, инструкции, 
  использующие 32-битные данные, префиксируются байтом 0х66, а 32-битные адреса 
  √ байтом 0х67. В состоянии <font color="#000099">BITS 32</font> справедливо 
  обратное: 32-битные инструкции не нуждаются в префиксе, инструкции, использующие 
  16-битные данные, префиксируются байтом 0х66, а 16-битные адреса √ байтом 0х67. 
<p>Директива <font color="#000099">BITS</font> имеет абсолютно эквивалентные примитивные 
  формы: <font color="#000099">[BITS 16]</font> и <font color="#000099">[BITS 
  32]</font>. Пользовательская форма инструкции является макросом, который не 
  делает ничего, кроме как вызывает соответствующую примитивную форму. 
<h3><a name="section-5.2">5.2 <font color="#000099">SECTION</font> или <font color="#000099">SEGMENT</font>: 
  Описание и изменение секций</a></h3>
<p>Директива <font color="#000099">SECTION</font> (<font color="#000099">SEGMENT</font> 
  &#151; это абсолютно эквивалентный синоним) указывает, в какую секцию выходного 
  файла будет ассемблирован код, который вы пишете. В некоторых объектных форматах 
  количество и имена секций фиксированы; в других пользователь может сделать их 
  столько, сколько захочет. Поэтому если вы захотите переключиться на секцию, 
  которая в данный момент не существует, директива <font color="#000099">SECTION</font> 
  может либо вызвать сообщение об ошибке, либо создать новую секцию. 
<p>Объектные форматы Unix и <font color="#000099">bin</font> поддерживают стандартизованные 
  имена секций: <font color="#000099">.text</font> &#151; для кода, <font color="#000099">.data</font> 
  &#151; для данных и <font color="#000099">.bss</font> &#151; для неинициализированных 
  данных. Формат <font color="#000099">obj</font> наоборот, не признает эти имена 
  секций специальными и более того, удаляет ведущую точку в имени любой секции. 
<h4><a name="section-5.2.1">5.2.1 Макрос <font color="#000099">__SECT__</font> 
  </a></h4>
<p>Директива <font color="#000099">SECTION</font> необычна тем, что ее пользовательская 
  форма функционально отличается от примитивной. Примитивная форма <font color="#000099">[SECTION 
  xyz]</font> просто переключает текущую секцию на указанную. Пользовательская 
  форма <font color="#000099">SECTION xyz</font> сначала определяет однострочный 
  макрос <font color="#000099">__SECT__</font> для примитивной директивы <font color="#000099">[SECTION]</font>, 
  которую собирается выдать, и затем выдает ее. Таким образом, пользовательская 
  директива 
<p><pre>
          SECTION .text
</pre>
<p>развернется в две строки: 
<p><pre>
%define __SECT__ [SECTION .text] 
          [SECTION .text]
</pre>
<p>Пользователи могут использовать это в своих собственных макросах. Например, 
  макрос <font color="#000099">writefile</font>, описанный в <a href="nasm_ru4.html#section-4.2.3">параграфе 
  4.2.3</a>, может быть с успехом переписан в следующей, более изощренной форме: 
<p><pre>
%macro writefile 2+ 
          [section .data] 
%%str:    db %2 
%%endstr: 
          __SECT__ 
          mov dx,%%str 
          mov cx,%%endstr-%%str 
          mov bx,%1 
          mov ah,0x40 
          int 0x21 
%endmacro
</pre>
<p>Данная форма макроса, записывающего строку в файл, сначала временно переключается 
  на секцию данных, используя при этом примитивную форму директивы <font color="#000099">SECTION</font>, 
  не модифицирующую<font color="#000099"> __SECT__</font>. Далее в секции данных 
  объявляется строка и затем вызывается <font color="#000099">__SECT__</font>, 
  переключающий контекст на любую секцию, в которой пользователь работал до этого. 
  Это исключает необходимость использования инструкции <font color="#000099">JMP</font> 
  (как в предыдущей версии макроса) для "перескакивания" данных, а также предотвращает 
  возникновение ошибок в модуле <font color="#000099">OBJ</font> формата, где 
  пользователь потенциально может использовать различные секции кода. 
<h3><a name="section-5.3">5.3 <font color="#000099">ABSOLUTE</font>: Определение 
  абсолютных меток</a></h3>
<p>О директиве <font color="#000099">ABSOLUTE</font> можно думать как об альтернативной 
  форме <font color="#000099">SECTION</font>: она направляет последующий код не 
  в физическую секцию, а в гипотетическую, начинающуюся с указанного абсолютного 
  адреса. В данном режиме вы можете использовать только инструкции семейства <font color="#000099">RESB</font>. 
<p><font color="#000099">ABSOLUTE</font> используется следующим образом: 
<p><pre>
          absolute 0x1A 
kbuf_chr  resw 1 
kbuf_free resw 1 
kbuf      resw 16
</pre>
<p>В данном примере область данных PC BIOS описана как сегмент, начинающийся с 
  адреса 0х1А: приведенный выше код определяет <font color="#000099">kbuf_chr</font> 
  по адресу <font color="#000099">0x1A</font>, <font color="#000099">kbuf_free</font> 
  по адресу <font color="#000099">0x1C</font> и <font color="#000099">kbuf</font> 
  по адресу <font color="#000099">0x1E</font>. 
<p>Пользовательская форма <font color="#000099">ABSOLUTE</font>, так же, как и 
  <font color="#000099">SECTION</font>, переопределяет макрос <font color="#000099">__SECT__</font> 
  в месте своего вызова. Директивы <font color="#000099">STRUC</font> и <font color="#000099">ENDSTRUC</font> 
  определены как макросы, использующие директиву <font color="#000099">ABSOLUTE</font> 
  (и соответственно,<font color="#000099"> __SECT__</font>). 
<p>ABSOLUTE в качестве аргумента принимает не только абсолютные константы: это 
  может быть выражение (на самом деле критическое выражение: см. <a href="nasm_ru3.html#section-3.7">параграф 
  3.7</a>), а также какое-то значение в сегменте. Например, TSR может реутилизировать 
  свой настроечный код в качестве run-time BSS следующим образом: 
<p>
<pre>          org 100h               ; это .COM - программа 
          jmp setup              ; код setup идет последним 
          ; здесь расположена резидентная часть TSR 
setup:    ; теперь идет код, инсталлирующий TSR 
          absolute setup 
runtimevar1 resw 1 
runtimevar2 resd 20 
tsr_end:
</pre>
<p>Здесь определяется несколько переменных "на верхушке" setup-кода, так что после 
  завершения его работы это пространство может быть реутилизировано как хранилище 
  данных для работающей TSR. Символ '<font color="#000099">tsr_end</font>' может 
  быть использован для расчета общего размера резидентной части TSR. 
<h3><a name="section-5.4">5.4 <font color="#000099">EXTERN</font>: Импорт символов 
  из других модулей</a></h3>
<p>Директива <font color="#000099">EXTERN</font> подобна директиве MASM <font color="#000099">EXTRN</font> 
  и ключевому слову <font color="#000099">extern</font> в С: она используется 
  для объявления символа, который определен в некотором другом модуле. Не все 
  объектные форматы поддерживают внешние переменные: формат <font color="#000099">bin</font> 
  этого не может. 
<p>Директива <font color="#000099">EXTERN</font> принимает столько аргументов, 
  сколько вам необходимо. Каждый аргумент является именем символа: 
<p><pre>
          extern _printf 
          extern _sscanf,_fscanf
</pre>
<p>Некоторые объектные форматы обеспечивают дополнительные возможности директивы 
  <font color="#000099">EXTERN</font>. В любом случае, дополнительный синтаксис 
  отделяется от имени символа двоеточием. Например, формат <font color="#000099">obj</font> 
  при помощи следующей директивы позволяет вам объявить, что базой сегмента внешних 
  символов по умолчанию должна быть группа <font color="#000099">dgroup</font>: 
<p><pre>
          extern _variable:wrt dgroup
</pre>
<p>Примитивная форма <font color="#000099">EXTERN</font> отличается от пользовательской 
  тем, что одновременно может принять только один аргумент: поддержка списка аргументов 
  реализуется на уровне препроцессора. 
<p>Вы можете объявить одну и ту же переменную как <font color="#000099">EXTERN</font> 
  более одного раза: NASM спокойно проигнорирует второе и последующие переопределения. 
<h3><a name="section-5.5">5.5 <font color="#000099">GLOBAL</font>: Экспорт символов 
  в другие модули</a></h3>
<p>Директива <font color="#000099">GLOBAL</font> &#151; это обратная сторона <font color="#000099">EXTERN</font>: 
  если один модуль объявляет символ как <font color="#000099">EXTERN</font> и 
  ссылается на него, то для предотвращения ошибок компоновщика необходимо, чтобы 
  некоторый другой модуль <i>определил</i> этот символ и объявил его как <font color="#000099">GLOBAL</font>. 
  Некоторые ассемблеры для этой цели используют директиву <font color="#000099">PUBLIC</font>. 
<p>Директива <font color="#000099">GLOBAL</font>, применяемая к символу, должна 
  появляться перед определением этого символа. Она использует тот же самый синтаксис, 
  что и <font color="#000099">EXTERN</font>, за исключением того, что ссылается 
  на символ, определяемый в этом же модуле. Например: 
<p>
<pre>
          global _main 
_main:    ; некоторый код
</pre>
<p><font color="#000099">GLOBAL</font>, как и <font color="#000099">EXTERN</font>, 
  позволяет вводить после двоеточия специфичный синтаксис объектных форматов. 
  К примеру объектный формат <font color="#000099">elf</font> позволяет вам указать, 
  чем являются глобальные символы: функциями или данными: 
<p><pre>
          global hashlookup:function, hashtable:data
</pre>
<p>Как и в случае <font color="#000099">EXTERN</font>, примитивная форма <font color="#000099">GLOBAL</font> 
  отличается от пользовательской восприятием одновременно только одного аргумента. 
<h3><a name="section-5.6">5.6 <font color="#000099">COMMON</font>: Определение 
  общих данных</a></h3>
<p>Директива <font color="#000099">COMMON</font> используется для объявления <i>общих 
  переменных</i>. Общая переменная &#151; это глобальная переменная, объявленная 
  в секции неинициализированных данных, поэтому 
<p><pre>
          common intvar 4
</pre>
<p>работает так же, как и 
<p><pre>
          global intvar 
          section .bss 
intvar    resd 1
</pre>
<p>Отличие состоит в том, что если одна и та же переменная определена в разных 
  модулях, во время связывания (сборки) эти переменные будут <i>объединены</i> 
  и ссылки на <font color="#000099">intvar</font> во всех модулях будут указывать 
  на одно и то же место в памяти. 
<p>Директива <font color="#000099">COMMON</font>, так же как <font color="#000099">GLOBAL</font> 
  и <font color="#000099">EXTERN</font>, поддерживает специфичный синтаксис объектных 
  форматов. Например, формат <font color="#000099">obj</font> позволяет общим 
  переменным быть близкими (near) или дальними (far), а формат <font color="#000099">elf</font> 
  &#151; задать их выравнивание: 
<p>
<pre>          common commvar 4:near  ; работает в OBJ 
          common intarray 100:4  ; работает в ELF: выравнивание про 4-байтной границе
</pre>
<p>И наконец, примитивная форма <font color="#000099">COMMON</font>, как и в случае 
  <font color="#000099">EXTERN</font> и <font color="#000099">GLOBAL</font>, отличается 
  от пользовательской тем, что одновременно принимает только один аргумент. 
<p align=center><a href="nasm_ru6.html">Следующая глава</a> | <a href="nasm_ru4.html">Предыдущая 
  глава </a> | <a href="contents.html">Содержание</a> | Указатель
<hr noshade size=1>
<b><a href="http://www.opennet.ru/docs/">Архив документации на OpenNet.ru</a>
</body></html>
