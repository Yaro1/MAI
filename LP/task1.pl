% Реализация стандартных предикатов обработки списков

% Длина списка
% (список, длина)
my_length([], 0).
my_length([_|T], N):-my_length(T, M), N is M + 1.

% Принадлежность элемента списку
% (элемент, список)
my_member(X, [X|_]).
my_member(X, [_|T]):-my_member(X, T).

% Конкатeнация списков
% (список1, список2, список1+2)
my_append([], L, L).
my_append([X|L1], L2, [X|Res]):-my_append(L1, L2, Res).

% Удаление элемента из списка
% (элемент, список, список без элемента)
my_remove(X, [X|T], T).
my_remove(X, [Y|T], [Y|Res]):-my_remove(X, T, Res).

% Перестановки элементов в списке
% (список, перестановка)
my_permute([], []).
my_permute(Res, [X|T]):-my_remove(X, Res, Y), my_permute(Y, T).

% Подсписки списка
% (подсписок, список)
my_sublist(S, L):-my_append(_, L1, L), my_append(S, _, L1).







getLast([], _, _):-!, fail. % из пустого списка нельзя выделить последний элемент
getLast([H], H, []):-!. % если список состоит из 1 элемента - то этот элемент и есть последний, а остаток - пустой список
getLast([H|T], R, [H|RL]):- % иначе отделяет от списка первый элемент (Н), у того что осталось (Т) выделяем рекурсивно последний элемент (R) и остаток (RL), прилепляем к RL элемент H чтобы получить результат
  getLast(T, R, RL).

shift(L, [E|RL]):- % сдвиг на 1 элемент. из исходного списка L получаем последний элемент E и остаток (RL). Тогда чтобы получить результат надо к RL в начало приделать E
  getLast(L, E, RL),!.

shift(0, L, L):-!. % если требуется сдвинуть список на 0 элемент-  ничего делать ненадо
shift(N, L, R):- % если надо сдвинуть на N элементов - то
  NN is N - 1,
  shift(L, TL), % сдвинем на 1 элемент
  shift(NN, TL, R), !. % и рекурсивно сдвинем еще на N-1 элемент

mymove:-
  L = [1,2,3,4,5], N is 1,
  shift(N, L, R), write(L), nl, write(R), nl.

% сдвиг на 1 элемент. из исходного списка L получаем последний элемент E и остаток (RL). Тогда чтобы получить результат надо к RL в начало приделать E
sshift(L, [E|L]):-last(L,E),select(E,L,L),!.

% если требуется сдвинуть список на 0 элемент-  ничего делать ненад
sshift(0, L, L):-!.
 % если надо сдвинуть на N элементов - то
sshift(N, L, R):-
  NN is N - 1,
  sshift(L, TL), % сдвинем на 1 элемент
  sshift(NN, TL, R), !. % и рекурсивно сдвинем еще на N-1 элемент

standartmove:-
  L = [7,10,20,0], N is 1,
  shift(N, L, R), write(L), nl, write(R), nl.

min1(A,B, Min):- A >= B, Min is B; Min is A.

findmin([L|Ls], Min) :-
    findmin(Ls, L, Min).

findmin([], Min, Min).
findmin([L|Ls], Min0, Min) :-
    min1(L, Min0,A),
    Min1 is A,
    findmin(Ls, Min1, Min).


mymin:-
  L = [10,0,7,3,3],
  write(L), nl,
  findmin(L,Min),
  write(Min), nl.

standartmin:-
  L = [10,2,7,3,6],
  min_list(L,Min),
  write(L), nl, write(Min), nl.



