<html><head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r"><title>Руководство по NASM</title>

<META NAME="GENERATOR" CONTENT="Super-Puper-Mega-Proga">
</head>
<body bgcolor="#DDE1C2"><b><a href="http://www.opennet.ru/docs/">Архив документации OpenNet.ru</a> / 
Раздел "<a href="http://www.opennet.ru/docs/124.shtml">Программирование, языки</a>" /
<a href="index.html">Индекс</a>
</b>
<hr noshade size=1>

<h1 align=center>Расширенный ассемблер: NASM</h1>
<p align=center><a href="nasm_ru4.html">Следующая глава</a> | <a href="nasm_ru2.html">Предыдущая 
  глава </a> | <a href="contents.html">Содержание</a> | Указатель
</p>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr> 
    <td width="60%"> 
      <h2><a name="chapter-3">Глава 3: Язык NASM</a></h2>
    </td>
    <td> 
      <div align="right"><font size="-1" color="#666666">Перевод: <a href="http://asmdev.narod.ru/asmos.html">AsmOS 
        group</a>, &copy; 2001</font></div>
    </td>
  </tr>
</table>
<h3><a name="section-3.1">3.1 Обзор ассемблерной строки NASM</a></h3>
<p>Как и в большинстве ассемблеров, каждая строка NASM содержит (если это не макрос, 
  препроцессорная или ассемблерная директива √ см. <a href="nasm_ru4.html">главу 
  4</a> и <a href="nasm_ru5.html">главу 5</a>) комбинацию четырех полей: </p>
<pre><font color="#666666">     метка: инструкция операнды ; комментарий</font></pre>
<p>Как обычно, большинство этих полей необязательны; допускается присутствие или 
  отсутствие любой комбинации метки, инструкции и комментария. Конечно, необходимость 
  поля операндов определяется инструкцией процессора. </p>
<p>NASM не накладывает ограничений на количество пробелов в строке: метки могут 
  иметь пробелы вначале, а инструкции могут не иметь никаких пробелов и т.п. Двоеточие 
  после метки также необязательно. (Это означает, что если вы хотите поместить 
  в строку инструкцию <font color="#000099">lodsb</font>, а введете <font color="#000099">lodab</font>, 
  строка останется корректной, но вместо инструкции будет объявлена метка. Выявить 
  данные опечатки отчасти можно, введя в строке запуска NASM ключ <font color="#000099">-w+orphan-labels</font> 
  &#151; в этом случае при обнаружении метки без заключительного двоеточия будет 
  выдаваться предупреждение). </p>
<p>Допустимыми символами в метках являются буквы, цифры, знаки <font color="#000099">_, 
  $, #, @, ~, .</font> и <font color="#000099">?</font>. Допустимые символы в 
  начале метки (первый символ метки) &#151; только буквы, точка (<font color="#000099">.</font>) 
  (со специальным значением, см. <a href="#section-3.8">параграф 3.8</a>), знак 
  подчеркивания (<font color="#000099">_</font>) и вопросительный знак (<font color="#000099">?</font>). 
  В идентификаторе может также присутствовать префикс <font color="#000099">$</font> 
  для указания того, что это действительно идентификатор, а не зарезервированное 
  слово; таким образом, если некоторый компонуемый вами модуль описывает символ 
  <font color="#000099">eax</font>, вы можете в коде NASM (для указания того, 
  что это не регистр) сослаться на него так: <font color="#000099">$eax</font>. 
</p>
<p>Поле инструкций может содержать любые процессорные инструкции: поддерживаются 
  инструкции Pentium и P6, FPU, MMX, а также некоторые недокументированные инструкции. 
  Перед инструкциями могут присутствовать префиксы <font color="#000099">LOCK, 
  REP, REPE/REPZ</font> или <font color="#000099">REPNE/REPNZ</font>, используемые 
  по их обычному предназначению. Поддерживаются префиксы размера адреса и операнда 
  <font color="#000099">A16, A32, O16</font> и <font color="#000099">O32</font> 
  &#151; пример их использования приведен в <a href="nasm_ru9.html">главе 9</a>. 
  В качестве префикса инструкции вы можете использовать также обозначение сегментного 
  регистра: код <font color="#000099">mov [bx],ax</font> эквивалентен коду <font color="#000099">mov 
  [es:bx],ax</font>. Мы рекомендуем использовать последний синтаксис, т.к. он 
  согласуется с другими синтаксическими особенностями языка, однако для инструкций, 
  не имеющих операндов (например, <font color="#000099">LODSB</font>) и требующих 
  в некоторых случаях замены сегмента, на данный момент не существует никакого 
  синтаксического способа обойти конструкцию <font color="#000099">es lodsb</font>. 
</p>
<p>Префиксы, такие как <font color="#000099">CS, A32, LOCK</font> или <font color="#000099">REPE</font> 
  могут присутствовать в строке самостоятельно и при этом NASM будет генерировать 
  соответствующие префикс-байты. </p>
<p>В дополнение к инструкциям процессора, NASM поддерживает также несколько псевдо-инструкций, 
  описанных в <a href="#section-3.2">параграфе 3.2</a>. </p>
<p>Операнды инструкций могут принимать несколько форм: они могут быть регистрами 
  (например ax, bp, ebx, cr0: NASM не использует синтаксис стиля а-ля-gas, где 
  имена регистров должны предваряться знаком %), эффективными адресами (см. <a href="#section-3.3">параграф 
  3.3</a>), константами (<a href="#section-3.4">параграф 3.4</a>) или выражениями 
  (<a href="#section-3.5">параграф 3.5</a>). </p>
<p>Для инструкций сопроцессора NASM допускает различные формы синтаксиса: вы можете 
  использовать двух-операндную форму, поддерживаемую MASMом, а также чисто NASMовскую 
  одно-операндную форму. Подробности о форме каждой поддерживаемой инструкции 
  приведены в <a href="nasm_rua.html">приложении A</a>. Например, вы можете написать: 
</p>

<pre><font color="#666666">     fadd st1               ; это значит st0 := st0 + st1 
     fadd st0,st1           ; это то же самое 

     fadd st1,st0           ; это значит st1 := st1 + st0 
     fadd to st1            ; это то же самое</font></pre>
<p>Почти любая инструкция сопроцессора, ссылающаяся на содержимое памяти, должна 
  использовать один из префиксов <font color="#000099">DWORD, QWORD</font> или 
  <font color="#000099">TWORD</font> для указания на то, операнд какого размера 
  должен участвовать в команде. </p>

<h3><a name="section-3.2">3.2 Псевдо-инструкции</a></h3>
<p>Псевдо-инструкции не являются реальными инструкциями х86 процессора, но все 
  равно помещаются в поле инструкций, т.к. это наиболее подходящее место для них. 
  Текущими псевдо-инструкциями являются <font color="#000099">DB, DW, DD, DQ</font> 
  и <font color="#000099">DT</font>, их копии для работы с неинициализированной 
  памятью <font color="#000099">RESB, RESW, RESD, RESQ</font> и <font color="#000099">REST</font>, 
  команды <font color="#000099">INCBIN, EQU</font> и префикс <font color="#000099">TIMES</font>. 
<h4><a name="section-3.2.1">3.2.1 <font color="#000099">DB</font> </a>и ее друзья: 
  Объявление инициализированных данных</h4>
<p>Как и в MASM, <font color="#000099">DB, DW, DD, DQ</font> и <font color="#000099">DT</font> 
  используются для объявления инициализированных данных в выходном файле. Они 
  могут использоваться достаточно многими способами: </p>
<pre><font color="#666666">     db 0x55                ; просто байт 0x55 
     db 0x55,0x56,0x57      ; последовательно 3 байта 
     db 'a',0x55            ; символьная константа 
     db 'hello',13,10,'$'   ; это строковая константа 
     dw 0x1234              ; 0x34 0x12 
     dw 'a'                 ; 0x41 0x00 (это просто число)
     dw 'ab'                ; 0x41 0x42 (символьная константа) 
     dw 'abc'               ; 0x41 0x42 0x43 0x00 (строка) 
     dd 0x12345678          ; 0x78 0x56 0x34 0x12 
     dd 1.234567e20         ; константа с плавающей точкой 
     dq 1.234567e20         ; двойной точности 
     dt 1.234567e20         ; расширенной точности</font></pre>

<p><font   color="#000099">DQ</font> и <font color="#000099">DT</font> не допускают 
  в качестве операндов числовые или строковые константы. </p>
<p>
<h4><a name="section-3.2.2">3.2.2 <font color="#000099">RESB</font> и ее друзья: 
  Объявление неинициализированных данных</a></h4>
<p><font   color="#000099">RESB, RESW, RESD, RESQ</font> и <font color="#000099">REST</font> 
  разработаны для использования в BSS-секции модуля: они объявляют <i>не инициализированное</i> 
  пространство для хранения данных. Каждая принимает один операнд, являющийся 
  числом резервируемых байт, слов, двойных слов и т.д. Как было указано в <a href="nasm_ru2.html#section-2.2.7">параграфе 
  2.2.7</a>, NASM не поддерживает синтаксис резервирования неинициализированного 
  пространства, реализованный в MASM/TASM, где можно делать <font color="#000099">DW 
  ?</font> или подобные вещи: это заменено полностью. Операнд псевдо-инструкций 
  класса <font color="#000099">RESB</font> является <i>критическим выражением</i>: 
  см. <a href="#section-3.7">параграф 3.7</a>. </p>
<p>Например: </p>
<pre><font color="#666666">     buffer:   resb 64                ; резервирование 64 байт 
     wordvar:  resw 1                 ; резервирование слова 
     realarray resq 10                ; массив из 10 чисел с плавающей точкой</font></pre>
<p>
<h4><a name="section-3.2.3">3.2.3 <font color="#000099">INCBIN</font>: Включение 
  внешних бинарных файлов</a></h4>
<p>INCBIN заимствована из старого ассемблера DevPac, работавшего на Amigе: она 
  включает бинарный файл в выходной файл, оставляя его (бинарный файл) неизменным. 
  Это может быть полезно (например) для включения картинок и музыки непосредственно 
  исполняемый файл игрушки. Эта псевдо-инструкция может быть вызвана тремя разными 
  способами: </p>
<pre><font color="#666666">     incbin "file.dat"      ; включение файла целиком 
     incbin "file.dat",1024 ; пропуск первых 1024 байт 
     incbin "file.dat",1024,512 ; пропуск первых 1024 и
                            ; включение следующих 512 байт</font></pre>
<p>
<h4><a name="section-3.2.4">3.2.4 <font color="#000099">EQU</font>: Определение 
  констант</a></h4>
<p><font   color="#000099">EQU</font> вводит символ для указанного константного 
  значения: если используется <font color="#000099">EQU</font>, в этой строке 
  кода должна присутствовать метка. Смысл <font color="#000099">EQU</font> &#151; 
  связать имя метки со значением ее (только) операнда. Данное определение абсолютно 
  и не может быть позднее изменено. Например, </p>
<pre><font color="#666666">     message   db 'Привет, фуфел!' 
     msglen    equ $-message</font></pre>

<p>определяет <font color="#000099">msglen</font> как константу 12. <font color="#000099">msglen</font> 
  не может быть позднее переопределено. Это не определение препроцессора: значение 
  <font color="#000099">msglen</font> обрабатывается здесь только <i>один раз</i> 
  при помощи значения <font color="#000099">$</font> (что такое <font color="#000099">$</font> 
  √ см. <a href="#section-3.5">параграф 3.5</a>) в месте определения. Имейте в 
  виду, что операнд <font color="#000099">EQU</font> также является критическим 
  выражением (<a href="#section-3.7">параграф 3.7</a>). </p>
<h4><a name="section-3.2.5">3.2.5 <font color="#000099">TIMES</font>: Повторение 
  инструкций или данных</a></h4>
<p>Префикс <font color="#000099">TIMES</font> заставляет инструкцию ассемблироваться 
  несколько раз. Данная псевдо-инструкция отчасти представляет NASM-эквивалент 
  синтаксиса <font color="#000099">DUP</font>, поддерживающегося MASM-совместимыми 
  ассемблерами. Вы можете написать, например </p>
<pre><font color="#666666">     zerobuf: times 64 db 0</font></pre>
<p>или что-то подобное; однако <font color="#000099">TIMES</font> более разносторонняя 
  инструкция. Аргумент <font color="#000099">TIMES</font> &#151; не просто числовая 
  константа, а <i>числовое выражение</i>, поэтому вы можете писать следующие вещи: 
</p>
<pre><font color="#666666">buffer:   db 'Привет, фуфел!' 
     times 64-$+buffer db ' '</font></pre>
<p>При этом будет резервироваться строго определенное пространство, начиная от 
  метки <font color="#000099">buffer</font> и длиной 64 байта. Наконец, <font color="#000099">TIMES</font> 
  может использоваться в обычных инструкциях, так что вы можете писать тривиальные 
  развернутые циклы: </p>
<pre><font color="#666666">     times 100 movsb</font></pre>
<p>Заметим, что нет никакой принципиальной разницы между <font color="#000099">times 
  100 resb 1</font> и <font color="#000099">resb 100</font> за исключением того, 
  что последняя инструкция будет обрабатываться примерно в 100 раз быстрее из-за 
  внутренней структуры ассемблера. </p>
<p>Операнд псевдо-инструкции <font color="#000099">TIMES</font>, подобно <font color="#000099">EQU</font> 
  и <font color="#000099">RESB</font>, является критическим выражением (<a href="#section-3.7">параграф 
  3.7</a>). </p>
<p>Имейте также в виду, что <font color="#000099">TIMES</font> не применима в 
  макросах: причиной служит то, что <font color="#000099">TIMES</font> обрабатывается 
  после макро-фазы, позволяющей аргументу <font color="#000099">TIMES</font> содержать 
  выражение, подобное <font color="#000099">64-$+buffer</font>. Для повторения 
  более одной строки кода или в сложных макросах используйте директиву препроцессора 
  <font color="#000099">%rep</font>. </p>
<h3><a name="section-3.3">3.3 Эффективные адреса</a></h3>
<p>Эффективный адрес &#151; это любой операнд инструкции со ссылкой на память. 
  Эффективные адреса в NASM имеют очень простой синтаксис: они содержат выражение 
  (в результате вычислений которого получается нужный адрес), обрамленное квадратными 
  скобками. Например: </p>
<pre><font color="#666666">wordvar   dw 123 
     mov ax,[wordvar] 
     mov ax,[wordvar+1] 
     mov ax,[es:wordvar+bx]</font></pre>
<p>Любая другая ссылка, не соответствующая этой простой системе, для NASM недействительна, 
  например<font color="#000099"> es:wordvar[bx]</font>. </p>
<p>Более сложные эффективные адреса, когда вовлечено более одного регистра, работают 
  точно также: </p>
<pre><font color="#666666">     mov eax,[ebx*2+ecx+offset] 
     mov ax,[bp+di+8]</font></pre>
<p>NASM способен воспринимать алгебру таких выражений, поэтому он правильно транслирует 
  вещи, выглядящие <i>на первый взгляд</i> недопустимыми: </p>
<pre><font color="#666666">     mov eax,[ebx*5]        ; ассемблируется как [ebx*4+ebx] 
     mov eax,[label1*2-label2] ; то есть [label1+(label1-label2)]</font></pre>
<p>Некоторые варианты эффективных адресов имеют более одной ассемблерной формы; 
  в большинстве таких ситуаций NASM будет генерировать самую короткую из них. 
  Например, у нас имеются простые ассемблерные инструкции <font color="#000099">[eax*2+0]</font> 
  и <font color="#000099">[eax+eax]</font>. NASM будет генерировать последнюю 
  из них, т.к. первый вариант требует дополнительно 4 байта для хранения нулевого 
  смещения. </p>
<p>NASM имеет механизм подсказок, позволяющий создавать из <font color="#000099">[eax+ebx]</font> 
  и <font color="#000099">[ebx+eax]</font> разные инструкции; это порой полезно, 
  т.к. например <font color="#000099">[esi+ebp]</font> и <font color="#000099">[ebp+esi]</font> 
  по умолчанию имеют разные сегментные регистры. </p>
<p>Несмотря на это, вы можете заставить NASM генерировать требуемые формы эффективных 
  адресов при помощи ключевых слов <font color="#000099">BYTE, WORD, DWORD</font> 
  и <font color="#000099">NOSPLIT</font>. Если вам нужно, чтобы <font color="#000099">[eax+3]</font> 
  ассемблировалась со смещением в двойное слово, вместо одного байта по умолчанию, 
  вы можете написать <font color="#000099">[dword eax+3]</font>. Точно также при 
  помощи <font color="#000099">[byte eax+offset]</font> вы можете заставить NASM 
  использовать байтовые смещения для небольших значений, не определяемых при первом 
  проходе (см. пример такого кода в <a href="#section-3.7">параграфе 3.7</a>). 
  В особых случаях, <font color="#000099">[byte eax]</font> будет кодироваться 
  как <font color="#000099">[eax+0]</font> с нулевым байтовым смещением, а <font color="#000099">[dword 
  eax]</font> будет кодироваться с нулевым смещением в двойное слово. Обычная 
  форма, <font color="#000099">[eax]</font>, будет оставлена без смещения. </p>
<p>NASM будет разделять <font color="#000099">[eax*2]</font> на <font color="#000099">[eax+eax]</font>, 
  т.к. это позволяет избежать использования поля смещения и сэкономить некоторое 
  пространство; соответственно, <font color="#000099">[eax*2+offset]</font> будет 
  разделено на <font color="#000099">[eax+eax+offset]</font>. При помощи ключевого 
  слова <font color="#000099">NOSPLIT</font> вы можете запретить такое поведение 
  NASM: <font color="#000099">[nosplit eax*2]</font> будет буквально оттранслировано 
  в <font color="#000099">[eax*2+0]</font>. </p>

<h3><a name="section-3.4">3.4 Константы</a></h3>
<p>NASM знает четыре различных типа констант: числовые, символьные, строковые 
  и с плавающей точкой. 
<h4><a name="section-3.4.1">3.4.1 </a>Числовые константы</h4>
<p>Числовая константа &#151; это просто число. NASM позволят определять числа 
  в различных системах счисления и различными способами: вы можете использовать 
  суффиксы <font color="#000099">H, Q</font> и <font color="#000099">B</font> 
  для шестнадцатеричных, восьмеричных и двоичных чисел соответственно; можете 
  использовать для шестнадцатеричных чисел префикс <font color="#000099">0х</font> 
  в стиле С, а также префикс <font color="#000099">$</font> в стиле Borland Pascal. 
  Однако имейте в виду, что префикс <font color="#000099">$</font> может быть 
  также префиксом идентификаторов (см. <a href="#section-3.1">параграф 3.1</a>), 
  поэтому первой цифрой шестнадцатеричного числа при использовании этого префикса 
  должна быть обязательно цифра, а не буква. </p>
<p>Некоторые примеры числовых констант: </p>
<pre><font color="#666666">     mov ax,100             ; десятичная 
     mov ax,0a2h            ; шестнадцатеричная 
     mov ax,$0a2            ; снова hex: нужен 0 
     mov ax,0xa2            ; опять hex 
     mov ax,777q            ; восьмеричная 
     mov ax,10010011b       ; двоичная</font></pre>
<h4><a name="section-3.4.2">3.4.2 Символьные константы</a></h4>
<p>Символьная константа содержит от одного до четырех символов, заключенных в 
  одиночные или двойные кавычки. Тип кавычек для NASM несущественен, поэтому если 
  используются одинарные кавычки, двойные могут выступать в роли символа и, соответственно, 
  наоборот. </p>
<p>Символьная константа, содержащая более одного символа, будет загружаться в 
  обратном порядке следования байт: если вы пишете </p>

<pre><font color="#666666">     mov eax,'abcd'</font></pre>
<p>сгенерированной константой будет не <font color="#000099">0x61626364</font>, 
  а <font color="#000099">0x64636261</font>, поэтому если сохранить эту константу 
  в память, а затем прочитать, получится снова <font color="#000099">abcd</font>, 
  но никак не <font color="#000099">dcba</font>. Это также влияет на инструкцию 
  <font color="#000099">CPUID</font> Пентиумов (см. <a href="nasm_rua.html#section-A.29">section 
  A.29</a>). </p>
<h4><a name="section-3.4.3">3.4.3 Строковые константы</a></h4>
<p>Строковые константы допустимы только в некоторых псевдо-инструкциях, а именно 
  в семействе <font color="#000099">DB</font> и инструкции <font color="#000099">INCBIN</font>. 
  Строковые константы похожи на символьные, только длиннее. Они обрабатываются 
  как сцепленные друг с другом символьные константы. Так, например, следующие 
  строки кода эквивалентны. </p>
<pre><font color="#666666">     db 'hello'             ; строковая константа
     db 'h','e','l','l','o' ; эквивалент из символьных констант</font></pre>
<p>Следующие строки также эквивалентны: </p>
<pre><font color="#666666">     dd 'ninechars'         ; строковая константа в двойное слово 
     dd 'nine','char','s'   ; три двойных слова 
     db 'ninechars',0,0,0   ; и действительно похоже</font></pre>
<p>Обратите внимание, что когда используется <font color="#000099">db</font>, 
  константа типа <font color="#000099">'ab'</font> обрабатывается как строковая, 
  хотя и достаточно коротка, чтобы быть символьной, потому что иначе db <font color="#000099">'ab'</font> 
  имело бы тот же смысл, какой и <font color="#000099">db 'a'</font>, что глупо. 
  Соответственно, трех- или четырехсимвольные константы, являющиеся операндами 
  инструкции <font color="#000099">dw</font>, обрабатываются также как строки. 
</p>

<h4><a name="section-3.4.4">3.4.4 Константы с плавающей точкой</a></h4>
<p>Константы с плавающей точкой допустимы только в качестве аргументов <font color="#000099">DD, 
  DQ</font> и <font color="#000099">DT</font>. Выражаются они традиционно: цифры, 
  затем точка, затем возможно цифры после точки, и наконец, необязательная <font color="#000099"> 
  Е</font> с последующей степенью. Точка обязательна, т.к. <font color="#000099">dd 
  1</font> NASM воспримет как объявление целой константы, в то время как <font color="#330099">dd 
  1.0</font> будет воспринята им правильно. </p>
<p>Несколько примеров: </p>
<pre><font color="#666666">     dd 1.2                 ; "простое" число 
     dq 1.e10               ; 10,000,000,000 
     dq 1.e+10              ; синоним 1.e10 
     dq 1.e-10              ; 0.000 000 000 1 
     dt 3.141592653589793238462 ; число pi</font></pre>
<p>В процессе компиляции NASM не может проводить вычисления над константами с 
  плавающей точкой (это сделано с целью переносимости). Несмотря на то, что NASM 
  генерирует код для х86 процессоров, сам по себе ассемблер может работать на 
  любой системе с ANCI C компилятором. Само собой, ассемблер не может гарантировать 
  присутствия устройства, обрабатывающего числа с плавающей точкой в формате Intel, 
  поэтому стало бы необходимо включить собственный полный набор подпрограмм для 
  работы с такими числами, что неизбежно привело бы к значительному увеличению 
  размера самого ассемблера, хотя польза от этого была бы минимальна. </p>

<h3><a name="section-3.5">3.5 Выражения</a></h3>
<p>Синтаксис выражений NASM подобен синтаксису выражений языка C. </p>
<p>NASM не гарантирует размер целых чисел, используемых для вычисления выражений 
  при компиляции: с тех пор как NASM может вполне успешно компилировать и выполняться 
  на 64-разрядных платформах, не будьте так уверены, что выражения вычисляются 
  в 32-битных регистрах и что можно попробовать умышленно сделать переполнение. 
  Это сработает не всегда. NASM гарантирует только то, что и ANSI C: вы всегда 
  имеете дело <i>как минимум</i> с 32-битными регистрами. </p>
<p>В выражениях NASM поддерживает два специальных символа, позволяющих при вычислениях 
  выражений получать текущую позицию (смещение) ассемблирования: это знаки <font color="#000099">$</font> 
  и <font color="#000099">$$</font>. Знак <font color="#000099">$</font> вычисляет 
  позицию начала строки, содержащей выражение, т.е. вы можете сделать бесконечный 
  цикл при помощи команды <font color="#000099">JMP $</font>. Знак <font color="#000099">$$</font> 
  определяет начало текущей секции (сегмента), поэтому вы можете узнать, как далеко 
  находитесь от начала секции при помощи выражения (<font color="#000099">$-$$</font>). 
</p>
<p>Ниже перечислены арифметические операции NASM в порядке возрастания приоритета. 
</p>
<h4><a name="section-3.5.1">3.5.1<font color="#000099"> |</font>: Побитовый оператор 
  ИЛИ</a></h4>
<p>Оператор <font color="#000099">|</font> производит побитовую операцию ИЛИ, 
  соответствующую процессорной инструкции <font color="#000099">OR</font>. Побитовое 
  ИЛИ имеет самый низкий приоритет среди арифметических операторов, поддерживаемых 
  NASMом. 
<h4><a name="section-3.5.2">3.5.2 <font color="#000099">^</font>: Побитовый оператор 
  ИСКЛЮЧАЮЩЕЕ ИЛИ</a></h4>
<p>Оператор <font color="#000099">^</font> обеспечивает выполнение побитовой операции 
  ИСКЛЮЧАЮЩЕЕ ИЛИ. 
<h4><a name="section-3.5.3">3.5.3 <font color="#000099">&amp;</font>: Побитовый 
  оператор И</a></h4>
<p>Оператор <font color="#000099">&</font> обеспечивает выполнение побитовой операции 
  И. 
<h4><a name="section-3.5.4">3.5.4 <font color="#000099">&lt;&lt;</font> и <font color="#000099">&gt;&gt;</font>: 
  Операторы сдвига бит</a></h4>
<p><font   color="#000099"><<</font> производит сдвиг бит влево точно так, как 
  это делается в С. Так, <font color="#000099">5<<3</font> обрабатывается как 
  5 умножить на 8, или 40. <font color="#000099">>></font> производит сдвиг бит 
  вправо; в NASM этот сдвиг всегда <i>беззнаковый</i>, поэтому биты, освобождаемые 
  слева в результате сдвига, заполняются нулями, а не старшим знаковым разрядом. 
<h4><a name="section-3.5.5">3.5.5 <font color="#000099">+</font> и <font color="#0000CC">&#151;</font>: 
  Операторы сложения и вычитания</a></h4>
<p>Операторы <font color="#000099">+</font> и <font color="#000099">&#151;</font> 
  выполняют обычное сложение и вычитание. 
<h4><a name="section-3.5.6">3.5.6 <font color="#000099">*, /, //, %</font> и <font color="#000099">%%</font>: 
  </a>Умножение и деление</h4>
<p><font   color="#000099">*</font> является оператором умножения. Операторы <font color="#000099">/</font> 
  и <font color="#000099">//</font> обозначают деление: <font color="#0000CC">/</font> 
  соответствует беззнаковому делению, а<font color="#000099"> //</font> &#151; 
  знаковому. Подобно этому, операторы <font color="#000099">%</font> и <font color="#000099">%%</font> 
  обеспечивают соответственно беззнаковое и знаковое получение остатка от деления 
  (взятие по модулю). </p>
<p>NASM, также как и ANSI C, не дает никаких гарантий о физическом смысле знакового 
  оператора взятия по модулю.</p>
<p>Так как символ <font color="#000099">%</font> часто используется макропроцессором, 
  будьте внимательны при применении знакового и беззнакого операторов взятия по 
  модулю &#151; они должны отделяться от других символов строки по крайней мере 
  одним пробелом. </p>
<h4><a name="section-3.5.7">3.5.7 Унарные операторы: +, -, ~ и SEG</a></h4>
<p>Наивысший приоритет в грамматике выражений NASM имеют операторы, применяемые 
  к одному аргументу: оператор &quot;минус&quot; (<font color="#000099">&#151;</font>) 
  изменяет знак своего операнда, оператор &quot;плюс&quot; (<font color="#000099">+</font>) 
  ничего не делает (введен для симметричности с минусом), оператор &quot;тильда&quot; 
  (<font color="#000099">~</font>) вычисляет дополнение операнда, а оператор <font color="#000099">SEG</font> 
  извлекает сегментный адрес операнда (более подробно описывается в <a href="#section-3.6">параграфе 
  3.6</a>). 
<h3><a name="section-3.6">3.6 SEG и WRT</a></h3>
<p>При написании больших 16-битных программ, которые должны быть разделены на 
  несколько сегментов, часто необходимо получить сегментную часть адреса некоторого 
  символа. Для выполнения этой функции в NASM имеется оператор <font color="#000099">SEG</font>. 
</p>
<p>Оператор <font color="#000099">SEG</font> возвращает базу <i>предопределенного</i> 
  сегмента символа, относительно которой вычисляется смещение последнего. Так 
  следующий код </p>
<pre><font color="#666666">     mov ax,seg symbol 
     mov es,ax 
     mov bx,symbol</font></pre>
<p>будет загружать в пару <font color="#000099">ES:BX</font> корректный указатель 
  на символ <font color="#000099">symbol</font>. </p>
<p>Бывают и более сложные случаи: т.к. 16-битные сегменты и группы способны перекрываться, 
  вы возможно захотите иногда сослаться на некоторый символ при помощи базы сегмента, 
  отличного от предопределенного. NASM позволяет это сделать при помощи ключевого 
  слова <font color="#000099">WRT</font> (With Reference To). Например, код </p>
<pre><font color="#666666">     mov ax,weird_seg       ; weird_seg является базой сегмента 
     mov es,ax 
     mov bx,symbol wrt weird_seg</font></pre>
<p>загрузит в <font color="#000099">ES:BX</font> другой, но функционально эквивалентный 
  указатель на символ <font color="#000099">symbol</font>. </p>
<p>NASM поддерживает дальние (межсегментные) вызовы подпрограмм и передачи управления 
  при помощи синтаксиса <font color="#000099">call segment:offset</font>, где 
  <font color="#000099">segment</font> и <font color="#000099">offset</font> являются 
  непосредственными значениями, поэтому для вызова дальней процедуры вы можете 
  использовать следующий синтаксис: </p>
<pre><font color="#666666">     call (seg procedure):procedure 
     call weird_seg:(procedure wrt weird_seg)</font></pre>
<p>(Круглые скобки включены для большей ясности приведенных инструкций. На практике 
  они не нужны). </p>
<p>&nbsp;</p>
<p>NASM также поддерживает синтаксис <font color="#000099">call far</font>, являющийся 
  аналогом первой из выше приведенных инструкций. В этих примерах инструкция <font color="#000099">JMP</font> 
  будет работать также, как <font color="#000099">CALL</font>. </p>
<p>Для объявления дальнего указателя на сегмент данных, вы можете писать: </p>
<pre><font color="#666666">     dw symbol, seg symbol</font></pre>
<p>NASM не поддерживает более удобных аналогов этому объявлению, однако при помощи 
  макропроцессора вы всегда можете их придумать. </p>
<h3><a name="section-3.7">3.7 Критические выражения</a></h3>
<p>В отличие от TASM и других, NASM является двухпроходным ассемблером; он всегда 
  делает <i>только</i> два прохода. Из-за этого он не способен "справиться" со 
  сложными исходными файлами, требующими три и более проходов. </p>
<p>Первый проход используется для определения размера всех ассемблируемых инструкций 
  и данных, поэтому на втором проходе (где генерируется код) известны адреса всех 
  символов, на которые имеются ссылки. Таким образом, NASM не сможет обработать 
  код, в котором размер зависит от значения символа, объявленного позднее, например: 
</p>
<pre><font color="#666666">          times (label-$) db 0 
label:    db 'Где это я?'</font></pre>
<p>Аргумент <font color="#666666">TIMES</font> в этом случае должен точно рассчитываться 
  для всех меток; NASM воспримет этот пример ошибочным, т.к. он не сможет узнать 
  размер строки с <font color="#000099">TIMES</font>. Для него это будет то же, 
  что и заведомо ошибочный код </p>
<pre><font color="#666666">          times (label-$+1) db 0 
label:    db 'А теперь я где?'</font></pre>
<p>где <i>любое</i> значение аргумента <font color="#000099">TIMES</font> по определению 
  неверно! </p>
<p>NASM отклоняет такой код при помощи концепции т.н. <i>критического выражения</i>, 
  определяемого как выражение, значение которого должно быть рассчитано на первом 
  проходе и которое, следовательно, должно зависеть только от символов, описанных 
  перед ним. Аргумент префикса <font color="#000099">TIMES</font> является критическим 
  выражением; по некоторым причинам аргументы псевдо-инструкций семейства <font color="#000099">RESB</font> 
  также являются критическими выражениями. </p>
<p>Критическое выражение может неожиданно возникнуть в следующем контексте: </p>
<pre><font color="#666666">          mov ax,symbol1 
symbol1   equ symbol2 
symbol2:</font></pre>
<p>На первом проходе NASM не может определить значение <font color="#000099">symbol1</font>, 
  т.к. он объявлен равным <font color="#000099">symbol2</font>, который, в свою 
  очередь, NASM еще "не видит". Соответственно на втором проходе, при обработке 
  строки <font color="#000099">mov ax,symbol1</font> он не способен сгенерировать 
  правильный код, потому что значение <font color="#000099">symbol1</font> остается 
  неизвестным. На следующей строке, увидев <font color="#000099">EQU</font>, NASM 
  сможет определить значение <font color="#000099">symbol1</font>, однако будет 
  уже поздно.</p>
<p>NASM предотвращает возникновение данных проблем, вводя для критических выражений 
  правосторонний оператор <font color="#000099">EQU</font>, при котором объявление 
  <font color="#000099">symbol1</font> будет отбраковано на первом проходе. </p>
<p>Еще одна похожая проблема, связанная с опережающими ссылками: рассмотрите следующий 
  фрагмент кода.</p>
<pre><font color="#666666">          mov eax,[ebx+offset] 
offset    equ 10</font></pre>
<p>На первом проходе NASM должен вычислить длину инструкции <font color="#000099">mov 
  eax,[ebx+offset]</font>, не зная значение <font color="#000099">offset</font>. 
  Он никак не сможет узнать, что смещение <font color="#000099">offset</font> 
  представляет собой малую величину, вписывающуюся в однобайтное поле смещения 
  и что можно "безбоязненно" сгенерировать более короткую форму эффективного адреса. 
  Однако на первом проходе еще не известно, что такое <font color="#000099">offset</font> 
  &#151; это может быть символ в сегменте кода и для него возможно нужна полная 
  четырехбайтовая форма инструкции. Таким образом, размер инструкции рассчитывается 
  исходя из четырехбайтовой адресной части. Сделав это предположение, на втором 
  проходе NASM вынужден оставлять длину инструкции как есть, генерируя при этом 
  не совсем оптимальный код. Данная проблема может быть разрешена путем объявления 
  <font color="#000099">offset</font> <i>перед</i> ее первым использованием или 
  явным указанием на байтовый размер смещения: <font color="#000099">[byte ebx+offset]</font>. 
</p>

<h3><a name="section-3.8">3.8 Локальные метки</a></h3>
<p>NASM дает специальную трактовку символов, начинающихся с точки. Метка, начинающаяся 
  с точки, обрабатывается как <i>локальная</i>. Это означает, что она неразрывно 
  связана с предыдущей нелокальной меткой. Например: </p>
<pre><font color="#666666">label1    ; некоторый код 
.loop     ; еще какой-то  код 
     jne .loop 
     ret 
label2    ; некоторый код 
.loop     ; еще какой-то  код  
     jne .loop 
     ret</font></pre>
<p>В приведенном фрагменте каждая инструкция <font color="#000099">JNE</font> 
  переходит на строку непосредственно перед ней, т.к. два определения <font color="#000099">.loop</font> 
  остаются разделены в силу того, что каждое связано с предшествующей нелокальной 
  меткой. </p>
<p>Данный способ обработки локальных меток позаимствован из ассемблера DevPac 
  (Amiga); однако NASM делает шаг вперед &#151; он позволяет обращаться к локальным 
  меткам из другой части кода. Это достигается путем описания локальной метки 
  на основе предыдущей нелокальной. Описания <font color="#000099">.loop</font> 
  в примере выше в действительности описывают два разных символа: <font color="#000099">label1.loop</font> 
  и <font color="#000099">label2.loop</font>, поэтому если вам это действительно 
  надо, то можете написать: </p>
<pre><font color="#666666">label3    ; некоторый код 
     ; и т.д. 
     jmp label1.loop</font></pre>
<p>Иногда бывает полезно, например, в макросах &#151; определить метку, на которую 
  можно ссылаться отовсюду, но которая не пересекается с обычным механизмом локальных 
  меток. Такая метка не может быть нелокальной, так как существует последующее 
  описание и ссылки на локальные метки; она также не может быть и локальной, вследствие 
  того, что описывающий ее макрос не будет знать полное имя метки. Для разрешения 
  этой проблемы в NASM введен третий тип меток, которые обычно используются только 
  в описаниях макросов: если метка начинается со специального префикса <font color="#000099">..@</font>, 
  она ничего не делает по отношению к механизму локальных меток. Таким образом, 
  вы можете написать: </p>
<pre><font color="#666666">label1:   ; нелокальная метка 
.local:   ; это label1.local 
..@foo:   ; это специальный символ
label2:   ; другая нелокальная метка 
.local:   ; это label2.local 
     jmp ..@foo             ; переход на три строки вверх</font></pre>
<p>NASM имеет возможность определять другие специальные символы, начинающиеся 
  с двух точек: например, <font color="#000099">..start </font>используется для 
  указания точки входа в объектном формате <font color="#000099">obj</font> (см. 
  <a href="nasm_ru6.html#section-6.2.6">параграф 6.2.6</a>). </p>

<p align=center><a href="nasm_ru4.html">Следующая глава</a> | <a href="nasm_ru2.html">Предыдущая 
  глава </a> | <a href="contents.html">Содержание</a> | Указатель
<hr noshade size=1>
<b><a href="http://www.opennet.ru/docs/">Архив документации на OpenNet.ru</a>
</body></html>
