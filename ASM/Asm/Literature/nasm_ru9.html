<html><head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r"><title>Руководство по NASM</title>

<META NAME="GENERATOR" CONTENT="Super-Puper-Mega-Proga"></head>
<body bgcolor="#DDE1C2"><b><a href="http://www.opennet.ru/docs/">Архив документации OpenNet.ru</a> / 
Раздел "<a href="http://www.opennet.ru/docs/124.shtml">Программирование, языки</a>" /
<a href="index.html">Индекс</a>
</b>
<hr noshade size=1>

<h1 align=center>Расширенный Ассемблер: NASM</h1>

<p align=center><a href="nasm_r10.html">Следующая глава</a> | <a href="nasm_ru8.html">Предыдущая 
  глава</a> | <a href="contents.html">Содержание</a> | Указатель</p> 
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr> 
    <td width="71%"> 
      <h2><a name="chapter-9">Глава 9: Смешивание 16- 
        и 32-битного кода.</a></h2>
    </td>
    <td width="29%"> 
      <div align="right"><font size="-1" color="#666666">Перевод: <a href="http://asmdev.narod.ru/asmos.html">AsmOS 
        group</a>, &copy; 2001</font></div>
    </td>
  </tr>
</table>
Эта глава повествует о некоторых проблемах, связанных с использованием необычных 
способов адресации и инструкций перехода, возникающих при написании кода операционных 
систем, таких мест как инициализация защищенного режима, которые требуют, чтобы 
код, который оперирует с сегментами смешанных адресаций, например, код из 16-битного 
сегмента пытается модифицировать данные в 32-битном, или инструкции перехода между 
сегментами разной разрядности. 
<h3><a name="section_9_1">9.1 Переходы между сегментами смешанной разрядности</a></h3>

<p>Наиболее распространенные формы инструкций смешанной разрядности 
встречаются при написании 32-битной ОС: как только закончился ваш код 
настройки в 16-битном режиме, например, загрузка ядра, вам придется 
запускать его, переключаясь в защищенный режим и прыгая в 32-битный 
сегмент на точку входя ядра. В полностью 32-биной ОС, есть 
потребность в использовании только инструкций смешанной разрядности, 
потому что любой код до ее создания может быть выполнен как 
чистый 16-битный, и все написанное для нее после, может быть 
чистым 32-битным.

<p>Пусть переход должен быть осуществлен по 48-битному дальнему адресу, так как 
  сегмент, в который происходит переход &#151; 32-битный. Однако, он должен быть 
  ассемблирован в 16-битном сегменте, поэтому, если мы для примера напишем, 
<pre>          jmp 0x1234:0x56789ABC  ; ошибка!</pre>

<p>то это будет неправильно работать, так как смещение будет обрезано до <font color="#000099">0x9ABC</font> 
  и переход окажется обычным 16-битным. 
<p>В коде инициализации ядра Линукса, из-за неспособности <font color="#000099">as86</font> 
  генерировать необходимые инструкции, их кодируют вручную, используя директиву 
  <font color="#000099">DB</font>. NASM способен сделать это лучше, он действительно 
  самостоятельно генерирует правильный код. Вот как это делается правильно: 
<pre>          jmp dword 0x1234:0x56789ABC  ; правильно</pre>
Префикс <font color="#000099">DWORD</font> (строго говоря, он должен следовать 
<I>после</I> двоеточия, так как это объявление размера двойного слова для смещения, 
но NASM поддерживает и такую форму записи, потому что обе они не двусмысленны) 
сообщает, что смещение должно рассматриваться как дальнее, в предположении, что 
вы умышленно совершаете переход их 16-битного сегмента в 32-битный. 
<p>Вы можете сделать обратное действие, делая переход из 32-битного сегмента в 
  16-битный, указав префикс <font color="#000099">WORD</font>: 
<p><pre>          jmp word 0x8765:0x4321 ; 32 to 16 bit</pre>
<p>Если префикс <font color="#000099">WORD</font> указан в 16-битном режиме, или 
  префикс <font color="#000099">DWORD</font> в 32-битном, они будут проигнорированы, 
  потому что они переводят NASM в режим, в котором он и так находится. 
<h3><a name="section-9.2">9.2 Адресация между сегментами различной разрядности</a></h3>

<p>Если ваша ОС является смесью 16 и 32-битной, или если вы пишете
расширитель ДОС, наверняка захотите использовать несколько 16-битных
и несколько 32-битных сегментов. Но с другой стороны, вам придется писать
код в 16-битном сегменте, который обращается к данным в 32-битном сегменте,
или наоборот.

<p>Если данные в 32-битном сегменте расположены в передлах первых 64К
сегмента, то к ним можно обращаться, используя обычные 16-битные операции,
но рано или поздно, вам понадобится совершать 32-битную адресацию
из 16-битного сегмента.

<p>Самый легкий путь сделать это, убедится, что вы используете
регистр для адреса, с этих пор каждый эффективный адрес, содержащийся
в 32-битном регистре принудительно будет 32-битным адресом.  Поэтому
вы можете сделать так
<p><pre>
          mov eax,offset_into_32_bit_segment_specified_by_fs 
          mov dword [fs:eax],0x11223344
</pre>

<p>Это хорошо, но немного громоздко (потому что мы проигрываем инструкцию и регистр) 
  если вам уже известно точное смещение. Архитектура <font color="#0000CC">x86</font> 
  поддерживает 32-битную эффективную адресацию, чтобы указать только 4-байтное 
  смещение, поэтому почему NASM не мог бы генерировать инструкцию лучше для этих 
  целей? 
<p>Он может. Как описано в <a href="#section-9.1">параграфе 9.1</a>, понадобится 
  только предварить адрес ключевым словом <font color="#000099">DWORD</font>, 
  и это будет 32-битным адресом: 
<p><pre>
          mov dword [fs:dword my_offset],0x11223344
</pre>
<p>Еще, как описано в <a href="#section-9.1">параграфе 9.1</a>, NASM не придирчив 
  к использованию префикса <font color="#000099">DWORD</font>, он может идти до 
  или после замещения сегмента, поэтому неплохо будет выглядеть код с этой инструкцией 
  вот так: 
<p><pre>
          mov dword [dword fs:my_offset],0x11223344
</pre>
<p>Не удивляйтесь, что префикс <font color="#000099">DWORD</font> <em>вне</em> 
  квадратных скобок, он контролирует размер данных, сохраняемых по этому адресу, 
  а один внутри квадратных скобок, который указывает на длину адреса. Последнее 
  можно очень просто продемонстрировать: 
<p><pre>
          mov word [dword 0x12345678],0x9ABC
</pre>

<p>Это объявление помещает 16 бит данных по адресу, указанному по 
32-битному смещению.

<p>Вы также можете указать префикс <font color="#000099">WORD</font> или <font color="#000099">DWORD</font> 
  месте с префиксом <font color="#000099">FAR</font> для косвенных дальних переходов 
  или вызовов. Например: 
<p><pre>
          call dword far [fs:word 0x4321]
</pre>

<p>Эта инструкция содержит адрес, указанный 16 битным смещением; она
загружает 48-битный дальний указатель из него (16-битного сегмента
и 32-битного смещения), и вызывает этот адрес.

<h3><a name="section-9.3">9.3 Другие инструкции смешанного размера</a></h3>

<p>Другой способ, который вы можете использовать для доступа к данным, является 
  применение инструкций для работы со строками (<font color="#000099">LODSx</font>, 
  <font color="#000099">STOSx</font> и так далее) или инструкции <font color="#000099">XLATB</font>. 
  Поскольку эти инструкции не имеют параметров, может показаться, что нет простого 
  способа заставить их работать с 32-битными адресами из 16-битного сегмента. 
<p>Как раз для этого и предназначены префиксы <font color="#000099">a16</font> 
  и <font color="#000099">a32</font> NASM-а. Если вы пишите <font color="#000099">LODSB</font> 
  в 16-битном сегменте, но предполагаете обращаться к строке из 32-битного сегмента, 
  загрузите адрес в <font color="#000099">ESI</font> и затем напишите 
<p><pre>
          a32 lodsb
</pre>
<p>Этот префикс даставит использовать 32-битную адресацию, это означает, что <font color="#000099">LODSB</font> 
  загружает из <font color="#000099">[DS:ESI]</font> вместо <font color="#000099">[DS:SI]</font>. 
  Чтобы получить доступ к строке в 16-битном сегменте из 32-битного, можно использовать 
  соответствующий префикс <font color="#000099">a16</font>. 
<p>Префиксы <font color="#000099">a16</font> и <font color="#000099">a32</font> 
  могут быть применимы к любой инструкции из таблицы инструкций NASM-а, но для 
  большинства из них создаются необходимые формы адресации и без них. Эти префиксы 
  необходимы только для инструкций с неявной адресацией: <font color="#000099">CMPSx</font> 
  (<a href="nasm_rua.html#section-A.24">параграф A.24</a>), <font color="#000099">SCASx</font> 
  (<a href="nasm_rua.html#section-A.229">параграф A.229</a>), <font color="#000099">LODSx</font> 
  (<a href="nasm_rua.html#section-A.117">параграф A.117</a>), <font color="#000099">STOSx</font> 
  (<a href="nasm_rua.html#section-A.243">параграф A.243</a>), <font color="#000099">MOVSx</font> 
  (<a href="nasm_rua.html#section-A.137">параграф A.137</a>), <font color="#000099">INSx</font> 
  (<a href="nasm_rua.html#section-A.98">параграф A.98</a>), <font color="#000099">OUTSx</font> 
  (<a href="nasm_rua.html#section-A.149">параграф A.149</a>) и <font color="#000099">XLATB</font> 
  (<a href="nasm_rua.html#section-A.269">параграф A.269</a>). Также, различные 
  инструкции <font color="#000099">push</font> и <font color="#000099">pop</font> 
  (<font color="#000099">PUSHA</font> и <font color="#000099">POPF</font> также 
  как и более частоиспользуемые <font color="#000099">PUSH</font> и <font color="#000066">POP</font>) 
  могут использоваться с префиксами <font color="#000099">a16</font> и <font color="#000099">a32</font> 
  для выбора <font color="#000099">SP</font> или <font color="#000099">ESP</font> 
  для использования в качестве указателя стека, в случае, если размер сегмента 
  стека имеет разрядность, отличную от кодового сегмента. 
<p><font color="#000099">PUSH</font> и <font color="#000099">POP</font>, когда 
  они используются с сегментными регистрами в 32-битном режиме, также имеют немного 
  необычное поведение, когда они помещают в стек и выталкивают из него 4 байта 
  за один раз, из них два верхних игнорируются и нижние два используются как значения 
  сегментых регистров, с которыми вызывались инструкции. Чтобы зафиксировать 16-битное 
  поведение инструкций <font color="#000099">push</font> и <font color="#000099">pop</font> 
  для операций с сегментными регистрами, вы можете использовать префикс размера 
  операнда <font color="#000099">o16</font>: 
<p><pre>
          o16 push ss 
          o16 push ds
</pre>
<p>Этот код сохраняет двойные слово стекового пространства, запихивая
два сегментных регистра в пространство, которое при нормальных 
обстоятельствах используется только под одну операцию помещения в стек.

<p>(Вы также можете использовать префикс <font color="#000099">o32</font> для 
  указания 32-битного поведения, когда вы в 16-битном режиме, но это оказывается 
  менее полезно.) 
<p align=center><a href="nasm_r10.html">Следующая глава</a> | <a href="nasm_ru8.html">Предыдущая 
  глава</a> | <a href="contents.html">Содержание</a> | Указатель
<hr noshade size=1>
<b><a href="http://www.opennet.ru/docs/">Архив документации на OpenNet.ru</a>
</body></html>


